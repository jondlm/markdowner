{"mappings":"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AAO,CACzB,IACA,OACA,UACA,UACA,OACA,UACA,QACA,QACA,IACA,MACA,MACA,MACA,QACA,aACA,OACA,KACA,SACA,SACA,UACA,SACA,OACA,OACA,MACA,WACA,UACA,OACA,WACA,KACA,YACA,MACA,UACA,MACA,SACA,MACA,MACA,KACA,KACA,UACA,KACA,WACA,aACA,SACA,OACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,MACA,QACA,MACA,MACA,QACA,SACA,KACA,OACA,MACA,OACA,UACA,OACA,WACA,QACA,MACA,OACA,KACA,WACA,SACA,SACA,IACA,UACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,UACA,SACA,SACA,QACA,SACA,SACA,OACA,SACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,WACA,QACA,KACA,QACA,OACA,KACA,QACA,KACA,IACA,KACA,MACA,QACA,MArHwB,EAyHbyE,EAAMzE,EAAO,CACxB,MACA,IACA,WACA,cACA,eACA,eACA,gBACA,mBACA,SACA,WACA,OACA,OACA,UACA,SACA,OACA,IACA,QACA,WACA,QACA,QACA,OACA,iBACA,SACA,OACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,OACA,QACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,OACA,QA3CuB,EA8CZmE,EAAanE,EAAO,CAC/B,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,eACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,eAzB8B,EAgCnBoE,EAAgBpE,EAAO,CAClC,UACA,gBACA,SACA,UACA,YACA,mBACA,iBACA,gBACA,gBACA,gBACA,QACA,YACA,OACA,eACA,YACA,UACA,gBACA,SACA,MACA,aACA,UACA,MAtBiC,EAyBtB0E,EAAS1E,EAAO,CAC3B,OACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,gBACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,SACA,QACA,SACA,OACA,OACA,UACA,SACA,MACA,QACA,MACA,SACA,aACA,cA9B0B,EAmCfsE,EAAmBtE,EAAO,CACrC,UACA,cACA,aACA,WACA,YACA,UACA,UACA,SACA,SACA,QACA,YACA,aACA,iBACA,cACA,OAfoC,EAkBzBuE,EAAOvE,EAAO,CAAC,QAAF,ECrRbwE,EAAOxE,EAAO,CACzB,SACA,SACA,QACA,MACA,iBACA,eACA,uBACA,WACA,aACA,UACA,SACA,UACA,cACA,cACA,UACA,OACA,QACA,QACA,QACA,OACA,UACA,WACA,eACA,SACA,cACA,WACA,WACA,UACA,MACA,WACA,0BACA,wBACA,WACA,YACA,UACA,eACA,OACA,MACA,UACA,SACA,SACA,OACA,OACA,WACA,KACA,YACA,YACA,QACA,OACA,QACA,OACA,OACA,UACA,OACA,MACA,MACA,YACA,QACA,SACA,MACA,YACA,WACA,QACA,OACA,QACA,UACA,aACA,SACA,OACA,UACA,UACA,cACA,cACA,SACA,UACA,UACA,aACA,WACA,MACA,WACA,MACA,WACA,OACA,OACA,UACA,aACA,QACA,WACA,QACA,OACA,QACA,OACA,UACA,QACA,MACA,SACA,OACA,QACA,UACA,WACA,QACA,YACA,OACA,SACA,SACA,QACA,QACA,QACA,OA7GwB,EAgHbyE,EAAMzE,EAAO,CACxB,gBACA,aACA,WACA,qBACA,SACA,gBACA,gBACA,UACA,gBACA,iBACA,QACA,OACA,KACA,QACA,OACA,gBACA,YACA,YACA,QACA,sBACA,8BACA,gBACA,kBACA,KACA,KACA,IACA,KACA,KACA,kBACA,YACA,UACA,UACA,MACA,WACA,YACA,MACA,OACA,eACA,YACA,SACA,cACA,cACA,gBACA,cACA,YACA,mBACA,eACA,aACA,eACA,cACA,KACA,KACA,KACA,KACA,aACA,WACA,gBACA,oBACA,SACA,OACA,KACA,kBACA,KACA,MACA,IACA,KACA,KACA,KACA,KACA,UACA,YACA,aACA,WACA,OACA,eACA,iBACA,eACA,mBACA,iBACA,QACA,aACA,aACA,eACA,eACA,cACA,cACA,mBACA,YACA,MACA,OACA,QACA,SACA,OACA,MACA,OACA,aACA,SACA,WACA,UACA,QACA,SACA,cACA,SACA,WACA,cACA,OACA,aACA,sBACA,mBACA,eACA,SACA,gBACA,sBACA,iBACA,IACA,KACA,KACA,SACA,OACA,OACA,cACA,YACA,UACA,SACA,SACA,QACA,OACA,kBACA,mBACA,mBACA,eACA,cACA,eACA,cACA,aACA,eACA,mBACA,oBACA,iBACA,kBACA,oBACA,iBACA,SACA,eACA,QACA,eACA,iBACA,WACA,UACA,UACA,YACA,mBACA,cACA,kBACA,iBACA,aACA,OACA,KACA,KACA,UACA,SACA,UACA,aACA,UACA,aACA,gBACA,gBACA,QACA,eACA,OACA,eACA,mBACA,mBACA,IACA,KACA,KACA,QACA,IACA,KACA,KACA,IACA,aAtLuB,EAyLZ0E,EAAS1E,EAAO,CAC3B,SACA,cACA,QACA,WACA,QACA,eACA,cACA,aACA,aACA,QACA,MACA,UACA,eACA,WACA,QACA,QACA,SACA,OACA,KACA,UACA,SACA,gBACA,SACA,SACA,iBACA,YACA,WACA,cACA,UACA,UACA,gBACA,WACA,WACA,OACA,WACA,WACA,aACA,UACA,SACA,SACA,cACA,gBACA,uBACA,YACA,YACA,aACA,WACA,iBACA,iBACA,YACA,UACA,QACA,QArD0B,EAwDf2E,EAAM3E,EAAO,CACxB,aACA,SACA,cACA,YACA,cALuB,EChWZ4E,EAAgB3E,EAAK,6BACrB4E,EAAW5E,EAAK,yBAChB6E,EAAc7E,EAAK,iBACnB8E,EAAY9E,EAAK,8BACjB+E,EAAY/E,EAAK,kBACjBgF,EAAiBhF,EAC5B,6FAEWiF,EAAoBjF,EAAK,yBACzBkF,EAAkBlF,EAC7B,+DAEWmF,EAAenF,EAAK,W,IHqDZoC,E,E,O,M,C,C,U,K,c,E,S,E,Y,E,U,E,U,E,e,E,kB,E,gB,E,a,C,GIjCrB,IAAMkD,EAA4B,SAAUC,CAAV,CAAwBC,CAAxB,EAE9B,GAAA,AAAwB,UAAxB,OAAOD,GACP,AAAqC,YAArC,OAAOA,EAAaE,YAApB,CAEA,OAAO,KAMLC,IAAAA,EAAS,KACPC,EAAY,wBACdH,GAAqBA,EAAkBI,YAAlB,CAA+BD,IACtDD,CAAAA,EAASF,EAAkBK,YAAlB,CAA+BF,EADtCH,EAIEM,IAAAA,EAAa,YAAeJ,CAAAA,EAAS,IAAMA,EAAS,EAAA,EAEtD,GAAA,CACF,OAAOH,EAAaE,YAAb,CAA0BK,EAAY,CAC3CC,WAAAA,AAAWxB,GACFA,EAETyB,gBAAAA,AAAgBC,GACPA,CALkC,EAQ9C,CAAC,MAAOC,EAAG,CAOV,OAHApC,QAAQC,IAAR,CACE,uBAAyB+B,EAAa,0BAEjC,IACR,CACF,E,OA4hDcK,AA1hDf,SAASA,IAAgBG,IA2DnBF,EA3DmBE,EAASkhB,UAAAA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAlDzB,AAAkB,aAAlB,OAAOlhB,OAAyB,KAAOA,OAmDxCC,EAAaC,AAAAA,GAASL,EAAgBK,GAc5C,GARAD,EAAUE,OAAV,CAAoBghB,QAMpBlhB,EAAUG,OAAV,CAAoB,EAApB,CAEI,CAACJ,GAAU,CAACA,EAAOK,QAAnB,EAA+BL,AAA6B,IAA7BA,EAAOK,QAAP,CAAgBC,QAAhB,CAKjC,OAFAL,EAAUM,WAAV,CAAwB,CAAA,EAEjBN,EAGL,GAAA,CAAA,SAAEI,CAAAA,CAAF,CAAeL,EAEbQ,EAAmBH,EACnBI,EAAgBD,EAAiBC,aAAvC,CACM,CAAA,iBACJC,CADI,CAAA,oBAEJC,CAFI,CAAA,KAGJC,CAHI,CAAA,QAIJC,CAJI,CAAA,WAKJC,CALI,CAAA,aAMJC,EAAef,EAAOe,YAAP,EAAuBf,EAAOgB,eANzC,CAAA,gBAOJC,CAPI,CAAA,UAQJC,CARI,CAAA,aASJjC,CAAAA,CATI,CAUFe,EAEEmB,EAAmBN,EAAQtG,SAAjC,CAEM6G,EAAYhE,EAAa+D,EAAkB,aAC3CE,EAAiBjE,EAAa+D,EAAkB,eAChDG,EAAgBlE,EAAa+D,EAAkB,cAC/CI,EAAgBnE,EAAa+D,EAAkB,cAQrD,GAAI,AAA+B,YAA/B,OAAOR,EAAoC,CAC7C,IAAMa,EAAWnB,EAASoB,aAAT,CAAuB,WACpCD,CAAAA,EAASE,OAAT,EAAoBF,EAASE,OAAT,CAAiBC,aAAzC,EACEtB,CAAAA,EAAWmB,EAASE,OAAT,CAAiBC,aAA5B,AAA4BA,CAE/B,CAGGC,IAAAA,EAAY,GAEV,CAAA,eACJC,EADI,CAAA,mBAEJC,EAFI,CAAA,uBAGJC,EAHI,CAAA,qBAIJC,EAAAA,CAJI,CAKF3B,EACE,CAAA,WAAE4B,EAAAA,CAAF,CAAiBzB,EAEnB0B,GAAQ,CAAA,CAKZjC,CAAAA,EAAUM,WAAV,CACE,AAAmB,YAAnB,OAAOpH,GACP,AAAyB,YAAzB,OAAOoI,GACPM,IACAA,AAAsClF,KAAAA,IAAtCkF,GAAeM,kBAAf,CAEI,GAAA,CAAA,cACJ9D,EADI,CAAA,SAEJC,EAFI,CAAA,YAGJC,EAHI,CAAA,UAIJC,EAJI,CAAA,UAKJC,EALI,CAAA,kBAMJE,EANI,CAAA,gBAOJC,EAAAA,CAPI,CAQFE,EAEA,CAAEJ,eAAAA,EAAAA,CAAF,CAAqBI,EAQrBuD,GAAe,KACbC,GAAuB/F,EAAS,CAAA,EAAI,IACrC6kB,KACAA,KACAA,KACAA,KACAA,EALgC,EASjC7e,GAAe,KACbC,GAAuBjG,EAAS,CAAA,EAAI,IACrC8kB,KACAA,KACAA,KACAA,EAJgC,EAajC5e,GAA0BjJ,OAAOE,IAAP,CAC5BC,EAAO,KAAM,CACX+I,aAAc,CACZC,SAAU,CAAA,EACVC,aAAc,CAAA,EACdC,WAAY,CAAA,EACZ1F,MAAO,IAJK,EAMd2F,mBAAoB,CAClBH,SAAU,CAAA,EACVC,aAAc,CAAA,EACdC,WAAY,CAAA,EACZ1F,MAAO,IAJW,EAMpB4F,+BAAgC,CAC9BJ,SAAU,CAAA,EACVC,aAAc,CAAA,EACdC,WAAY,CAAA,EACZ1F,MAAO,CAAA,CAJuB,CAbrB,IAuBX6F,GAAc,KAGdC,GAAc,KAGdC,GAAkB,CAAA,EAGlBC,GAAkB,CAAA,EAGlBC,GAA0B,CAAA,EAI1BC,GAA2B,CAAA,EAK3BC,GAAqB,CAAA,EAGrBC,GAAiB,CAAA,EAGjBC,GAAa,CAAA,EAIbC,GAAa,CAAA,EAMbC,GAAa,CAAA,EAIbC,GAAsB,CAAA,EAItBC,GAAsB,CAAA,EAKtBC,GAAe,CAAA,EAefC,GAAuB,CAAA,EAIvBC,GAAe,CAAA,EAIfC,GAAW,CAAA,EAGXC,GAAe,CAAA,EAGfC,GAAkB,KAChBC,GAA0B5H,EAAS,CAAA,EAAI,CAC3C,iBACA,QACA,WACA,OACA,gBACA,OACA,SACA,OACA,KACA,KACA,KACA,KACA,QACA,UACA,WACA,WACA,YACA,SACA,QACA,MACA,WACA,QACA,QACA,QACA,MAzBsC,EA6BpC6H,GAAgB,KACdC,GAAwB9H,EAAS,CAAA,EAAI,CACzC,QACA,QACA,MACA,SACA,QACA,QANoC,EAUlC+H,GAAsB,KACpBC,GAA8BhI,EAAS,CAAA,EAAI,CAC/C,MACA,QACA,MACA,KACA,QACA,OACA,UACA,cACA,OACA,UACA,QACA,QACA,QACA,QAd0C,EAiBtCiI,GAAmB,qCACnBC,GAAgB,6BAChBC,GAAiB,+BAEnBC,GAAYD,GACZE,GAAiB,CAAA,EAGjBC,GAAqB,KACnBC,GAA6BvI,EACjC,CAAA,EACA,CAACiI,GAAkBC,GAAeC,GAFO,CAGzC1J,GAIE+J,GAAoB,KAClBC,GAA+B,CAAC,wBAAyB,YAA/D,CAEItI,GAAoB,KAGpBuI,GAAS,KAKPC,GAAc7E,EAASoB,aAAT,CAAuB,QAErC0D,GAAoB,SAAUC,CAAV,EACxB,OAAOA,aAAqBzJ,QAAUyJ,aAAqBC,QAC5D,EAQKC,GAAe,WAAUC,IAAAA,EAAU,UAAA,MAAA,CAAA,GAAA,AAAA,KAAA,IAAA,SAAA,CAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAJ,CAAA,EACnC,GAAIN,CAAAA,IAAUA,KAAWM,GA6LrBA,GAxLCA,GAAO,AAAe,UAAf,OAAOA,GACjBA,CAAAA,EAAM,CAAA,CAAA,EAIRA,EAAMxI,EAAMwI,GASZ7I,GACEqI,AAAsB,0BARxBA,CAAAA,GAGOA,GADLC,AAAgE,KAAhEA,GAA6BzJ,OAA7B,CAAqCgK,EAAIR,iBAAzC,EApC8B,YAsCLQ,EAAIR,iBAJ/B,AAI+BA,EAKzB/J,EACAH,EAGNwH,GACE,iBAAkBkD,EACdhJ,EAAS,CAAA,EAAIgJ,EAAIlD,YAAT,CAAuB3F,IAC/B4F,GACNC,GACE,iBAAkBgD,EACdhJ,EAAS,CAAA,EAAIgJ,EAAIhD,YAAT,CAAuB7F,IAC/B8F,GACNqC,GACE,uBAAwBU,EACpBhJ,EAAS,CAAA,EAAIgJ,EAAIV,kBAAT,CAA6B7J,GACrC8J,GACNR,GACE,sBAAuBiB,EACnBhJ,EACEQ,EAAMwH,IACNgB,EAAIC,iBAFE,CAGN9I,IAEF6H,GACNH,GACE,sBAAuBmB,EACnBhJ,EACEQ,EAAMsH,IACNkB,EAAIE,iBAFE,CAGN/I,IAEF2H,GACNH,GACE,oBAAqBqB,EACjBhJ,EAAS,CAAA,EAAIgJ,EAAIrB,eAAT,CAA0BxH,IAClCyH,GACNnB,GACE,gBAAiBuC,EACbhJ,EAAS,CAAA,EAAIgJ,EAAIvC,WAAT,CAAsBtG,IAC9B,CAAA,EACNuG,GACE,gBAAiBsC,EACbhJ,EAAS,CAAA,EAAIgJ,EAAItC,WAAT,CAAsBvG,IAC9B,CAAA,EACNuH,GAAe,iBAAkBsB,GAAMA,EAAItB,YAA5B,CACff,GAAkBqC,AAAwB,CAAA,IAAxBA,EAAIrC,eAAJ,CAClBC,GAAkBoC,AAAwB,CAAA,IAAxBA,EAAIpC,eAAJ,CAClBC,GAA0BmC,EAAInC,uBAAJ,EAA+B,CAAA,EACzDC,GAA2BkC,AAAiC,CAAA,IAAjCA,EAAIlC,wBAAJ,CAC3BC,GAAqBiC,EAAIjC,kBAAJ,EAA0B,CAAA,EAC/CC,GAAiBgC,EAAIhC,cAAJ,EAAsB,CAAA,EACvCG,GAAa6B,EAAI7B,UAAJ,EAAkB,CAAA,EAC/BC,GAAsB4B,EAAI5B,mBAAJ,EAA2B,CAAA,EACjDC,GAAsB2B,EAAI3B,mBAAJ,EAA2B,CAAA,EACjDH,GAAa8B,EAAI9B,UAAJ,EAAkB,CAAA,EAC/BI,GAAe0B,AAAqB,CAAA,IAArBA,EAAI1B,YAAJ,CACfC,GAAuByB,EAAIzB,oBAAJ,EAA4B,CAAA,EACnDC,GAAewB,AAAqB,CAAA,IAArBA,EAAIxB,YAAJ,CACfC,GAAWuB,EAAIvB,QAAJ,EAAgB,CAAA,EAC3BtF,GAAiB6G,EAAIG,kBAAJ,EAA0B5G,EAC3C6F,GAAYY,EAAIZ,SAAJ,EAAiBD,GAC7BjC,GAA0B8C,EAAI9C,uBAAJ,EAA+B,CAAA,EAEvD8C,EAAI9C,uBAAJ,EACA0C,GAAkBI,EAAI9C,uBAAJ,CAA4BC,YAA7B,GAEjBD,CAAAA,GAAwBC,YAAxB,CACE6C,EAAI9C,uBAAJ,CAA4BC,YAD9B,AAC8BA,EAI9B6C,EAAI9C,uBAAJ,EACA0C,GAAkBI,EAAI9C,uBAAJ,CAA4BK,kBAA7B,GAEjBL,CAAAA,GAAwBK,kBAAxB,CACEyC,EAAI9C,uBAAJ,CAA4BK,kBAD9B,AAC8BA,EAI9ByC,EAAI9C,uBAAJ,EACA,AACE,WADF,OAAO8C,EAAI9C,uBAAJ,CAA4BM,8BAAnC,EAGAN,CAAAA,GAAwBM,8BAAxB,CACEwC,EAAI9C,uBAAJ,CAA4BM,8BAD9B,AAC8BA,EAG5BO,IACFH,CAAAA,GAAkB,CAAA,CADpB,EAIIQ,IACFD,CAAAA,GAAa,CAAA,CADf,EAKIO,KACF5B,GAAe9F,EAAS,CAAA,EAAI,IAAI6kB,EAAT,EACvB7e,GAAe,EAAf,CAC0B,CAAA,IAAtB0B,GAAahG,IAAb,GACF1B,EAAS8F,GAAc+e,GACvB7kB,EAASgG,GAAc8e,IAGA,CAAA,IAArBpd,GAAa/F,GAAb,GACF3B,EAAS8F,GAAc+e,GACvB7kB,EAASgG,GAAc8e,GACvB9kB,EAASgG,GAAc8e,IAGO,CAAA,IAA5Bpd,GAAarG,UAAb,GACFrB,EAAS8F,GAAc+e,GACvB7kB,EAASgG,GAAc8e,GACvB9kB,EAASgG,GAAc8e,IAGG,CAAA,IAAxBpd,GAAa9F,MAAb,GACF5B,EAAS8F,GAAc+e,GACvB7kB,EAASgG,GAAc8e,GACvB9kB,EAASgG,GAAc8e,KAKvB9b,EAAII,QAAR,GACMtD,KAAiBC,IACnBD,CAAAA,GAAetF,EAAMsF,GADnBA,EAIJ9F,EAAS8F,GAAckD,EAAII,QAAnB,CAA6BjJ,KAGnC6I,EAAIK,QAAR,GACMrD,KAAiBC,IACnBD,CAAAA,GAAexF,EAAMwF,GADnBA,EAIJhG,EAASgG,GAAcgD,EAAIK,QAAnB,CAA6BlJ,KAGnC6I,EAAIC,iBAAR,EACEjJ,EAAS+H,GAAqBiB,EAAIC,iBAA1B,CAA6C9I,IAGnD6I,EAAIrB,eAAR,GACMA,KAAoBC,IACtBD,CAAAA,GAAkBnH,EAAMmH,GADtBA,EAIJ3H,EAAS2H,GAAiBqB,EAAIrB,eAAtB,CAAuCxH,KAI7CqH,IACF1B,CAAAA,EAAY,CAAC,QAAb,CAAwB,CAAA,CAF1B,EAMIkB,IACFhH,EAAS8F,GAAc,CAAC,OAAQ,OAAQ,OAAhC,EAINA,GAAawD,KAAjB,GACEtJ,EAAS8F,GAAc,CAAC,QAAhB,EACDW,OAAAA,GAAY8C,KAAnB,EAGEP,EAAIQ,oBAAR,CAA8B,CACxB,GAAA,AAA+C,YAA/C,OAAOR,EAAIQ,oBAAJ,CAAyBtG,UAAhC,CACI5D,MAAAA,EACJ,+EAIA,GAAA,AAAoD,YAApD,OAAO0J,EAAIQ,oBAAJ,CAAyBrG,eAAhC,CACI7D,MAAAA,EACJ,oFAQJ+F,EAAY9B,AAHZA,CAAAA,EAAqByF,EAAIQ,oBAAzB,AAAyBA,EAGMtG,UAAnB,CAA8B,GAC3C,MAE4B9C,KAAAA,IAAvBmD,GACFA,CAAAA,EAAqBd,EACnBC,EACAwB,EAHAX,EAQuB,OAAvBA,GAA+B,AAAqB,UAArB,OAAO8B,GACxCA,CAAAA,EAAY9B,EAAmBL,UAAnB,CAA8B,GADxCK,EAOFrG,GACFA,EAAO8L,GAGTN,GAASM,EACV,EAEKS,GAAiCzJ,EAAS,CAAA,EAAI,CAClD,KACA,KACA,KACA,KACA,QAL6C,EAQzC0J,GAA0B1J,EAAS,CAAA,EAAI,CAC3C,gBACA,OACA,QACA,iBAJsC,EAWlC2J,GAA+B3J,EAAS,CAAA,EAAI,CAChD,QACA,QACA,OACA,IACA,SAL2C,EAWvC4J,GAAe5J,EAAS,CAAA,EAAI6kB,GAClC7kB,EAAS4J,GAAcib,GACvB7kB,EAAS4J,GAAcib,GAEjBhb,IAAAA,GAAkB7J,EAAS,CAAA,EAAI6kB,GACrC7kB,EAAS6J,GAAiBgb,GAQ1B,IAAM/a,GAAuB,SAAUxJ,CAAV,EAC3B,IAAIyJ,EAAS/E,EAAc1E,GAItByJ,GAAWA,EAAOC,OAAvB,EACED,CAAAA,EAAS,CACPE,aAAc7B,GACd4B,QAAS,UAFF,CAAA,EAMX,IAAMA,EAAU1L,EAAkBgC,EAAQ0J,OAAT,EAC3BE,EAAgB5L,EAAkByL,EAAOC,OAAR,QAEvC,EAAK1B,EAAkB,CAAChI,EAAQ2J,YAAT,CAAvB,GAII3J,EAAQ2J,YAAR,GAAyB/B,GAI3B,AAAI6B,EAAOE,YAAP,GAAwB9B,GACnB6B,AAAY,QAAZA,EAMLD,EAAOE,YAAP,GAAwBhC,GAExB+B,AAAY,QAAZA,GACCE,CAAAA,AAAkB,mBAAlBA,GACCT,EAA8B,CAACS,EAFjC,AAEiCA,EAM9BC,CAAAA,CAAQP,EAAY,CAACI,EAAd,CAGZ1J,EAAQ2J,YAAR,GAAyBhC,GAI3B,AAAI8B,EAAOE,YAAP,GAAwB9B,GACnB6B,AAAY,SAAZA,EAKLD,EAAOE,YAAP,GAAwB/B,GACnB8B,AAAY,SAAZA,GAAsBN,EAAuB,CAACQ,EAArD,CAKKC,CAAAA,CAAQN,EAAe,CAACG,EAAjB,CAGZ1J,EAAQ2J,YAAR,GAAyB9B,GAKzB4B,AAAAA,CAAAA,EAAOE,YAAP,GAAwB/B,MACvBwB,EAAuB,CAACQ,EAF3B,AAE2BA,GAMzBH,CAAAA,EAAOE,YAAP,GAAwBhC,MACvBwB,EAA8B,CAACS,EAFlC,AAEkCA,GAQhC,CAACL,EAAe,CAACG,EAAjB,EACCL,CAAAA,EAA4B,CAACK,EAA7B,EAAyC,CAACJ,EAAY,CAACI,EADxD,AACwDA,EAM1DxB,AAAsB,0BAAtBA,MACAF,EAAkB,CAAChI,EAAQ2J,YAAT,CAFpB,CAYD,EAOKG,GAAe,SAAUC,CAAV,EACnBjM,EAAUsF,EAAUG,OAAX,CAAoB,CAAEvD,QAAS+J,CAAX,GACzB,GAAA,CAEFA,EAAKC,UAAL,CAAgBC,WAAhB,CAA4BF,EAC7B,CAAC,MAAOhH,EAAG,CACVgH,EAAKG,MAAL,EACD,CACF,EAQKC,GAAmB,SAAUC,CAAV,CAAgBL,CAAhB,EACnB,GAAA,CACFjM,EAAUsF,EAAUG,OAAX,CAAoB,CAC3B8G,UAAWN,EAAKO,gBAAL,CAAsBF,GACjCG,KAAMR,CAFqB,EAI9B,CAAC,MAAOhH,EAAG,CACVjF,EAAUsF,EAAUG,OAAX,CAAoB,CAC3B8G,UAAW,KACXE,KAAMR,CAFqB,EAI9B,CAKGK,GAHJL,EAAKS,eAAL,CAAqBJ,GAGjBA,AAAS,OAATA,GAAiB,CAAC1E,EAAY,CAAC0E,EAAnC,EACMvD,GAAAA,IAAcC,GACZ,GAAA,CACFgD,GAAaC,EACd,CAAC,MAAOhH,EAAG,CAAA,MAER,GAAA,CACFgH,EAAKU,YAAL,CAAkBL,EAAM,GACzB,CAAC,MAAOrH,EAAG,CAAA,EAGjB,EAQK2H,GAAgB,SAAUC,CAAV,EAEhBC,IAAAA,EAAM,KACNC,EAAoB,KAExB,GAAIjE,GACF+D,EAAQ,oBAAsBA,MACzB,CAEL,IAAMG,EAAUzM,EAAYsM,EAAO,eACnCE,EAAoBC,GAAWA,CAAO,CAAC,EAAvC,AACD,CAGuB,0BAAtB5C,IACAJ,KAAcD,IAGd8C,CAAAA,EACE,iEACAA,EACA,gBAHFA,EAMII,IAAAA,EAAe9H,EACjBA,EAAmBL,UAAnB,CAA8B+H,GAC9BA,EAKA7C,GAAAA,KAAcD,GACZ,GAAA,CACF+C,EAAM,IAAIvG,IAAY2G,eAAhB,CAAgCD,EAAc7C,GACrD,CAAC,MAAOnF,EAAG,CAAA,CAId,GAAI,CAAC6H,GAAO,CAACA,EAAIK,eAAjB,CAAkC,CAChCL,EAAM5F,GAAekG,cAAf,CAA8BpD,GAAW,WAAY,MACvD,GAAA,CACF8C,EAAIK,eAAJ,CAAoBE,SAApB,CAAgCpD,GAC5BhD,EACAgG,CACL,CAAC,MAAOhI,EAAG,CAEX,CACF,CAEKqI,IAAAA,EAAOR,EAAIQ,IAAJ,EAAYR,EAAIK,eAA7B,OAUInD,CARA6C,GAASE,GACXO,EAAKC,YAAL,CACE7H,EAAS8H,cAAT,CAAwBT,GACxBO,EAAKG,UAAL,CAAgB,EAAhB,EAAsB,MAKtBzD,KAAcD,IACT1C,GAAqBqG,IAArB,CACLZ,EACAlE,GAAiB,OAAS,OAFrB,CAGL,EAHF,CAMKA,GAAiBkE,EAAIK,eAAP,CAAyBG,CAC/C,EAQKK,GAAsB,SAAUpI,CAAV,EACnB4B,OAAAA,GAAmBuG,IAAnB,CACLnI,EAAKyB,aAAL,EAAsBzB,EACtBA,EAEAY,EAAWyH,YAAX,CAA0BzH,EAAW0H,YAArC,CAAoD1H,EAAW2H,SAJ1D,CAKL,KAEH,EA6BKC,GAAU,SAAU1L,CAAV,EACd,MAAO,AAAgB,YAAhB,OAAO4D,GAAuB5D,aAAkB4D,CACxD,EAUK+H,GAAe,SAAUC,CAAV,CAAsBC,CAAtB,CAAmCC,CAAnC,EACd5G,EAAK,CAAC0G,EAAX,EAIAxO,EAAa8H,EAAK,CAAC0G,EAAP,CAAqBG,AAAAA,IAC/BA,EAAKV,IAAL,CAAUpI,EAAW4I,EAAaC,EAAM7D,GACzC,EACF,EAYK+D,GAAoB,SAAUH,CAAV,EACpBnH,IAAAA,EAAU,KAMd,GAHAiH,GAAa,yBAA0BE,EAAa,MAvDlDI,AA0DeJ,aA1DA5H,GACd,CAAA,AAAwB,UAAxB,OAAOgI,AAyDOJ,EAzDHK,QAAX,EACC,AAA2B,UAA3B,OAAOD,AAwDMJ,EAxDFM,WAAX,EACA,AAA2B,YAA3B,OAAOF,AAuDMJ,EAvDF/B,WAAX,EACA,CAAEmC,CAAAA,AAsDWJ,EAtDPO,UAAJ,YAA0BrI,CAAAA,GAC5B,AAA+B,YAA/B,OAAOkI,AAqDMJ,EArDFxB,eAAX,EACA,AAA4B,YAA5B,OAAO4B,AAoDMJ,EApDFvB,YAAX,EACA,AAA4B,UAA5B,OAAO2B,AAmDMJ,EAnDFrC,YAAX,EACA,AAA4B,YAA5B,OAAOyC,AAkDMJ,EAlDFX,YAAX,EACA,AAA6B,YAA7B,OAAOe,AAiDMJ,EAjDFQ,aAAX,AAA6B,EAmD/B,OADA1C,GAAakC,GACN,CAAA,EAIT,IAAMtC,EAAU7J,GAAkBmM,EAAYK,QAAb,EASjC,GANAP,GAAa,sBAAuBE,EAAa,CAC/CtC,QAAAA,EACA+C,YAAajH,EAFkC,GAO/CwG,EAAYQ,aAAZ,IACA,CAACX,GAAQG,EAAYU,iBAAb,GACR7N,EAAW,UAAWmN,EAAYb,SAAxB,GACVtM,EAAW,UAAWmN,EAAYM,WAAxB,EAGV,OADAxC,GAAakC,GACN,CAAA,EAIL,GAAA,CAACxG,EAAY,CAACkE,EAAd,EAA0BvD,EAAW,CAACuD,EAA1C,CAAoD,CAE9C,GAAA,CAACvD,EAAW,CAACuD,EAAb,EAAyBiD,GAAsBjD,KAE/C9D,GAAwBC,YAAxB,YAAgD/G,QAChDD,EAAW+G,GAAwBC,YAAzB,CAAuC6D,IAMjD9D,GAAwBC,YAAxB,YAAgD2C,UAChD5C,GAAwBC,YAAxB,CAAqC6D,IALrC,MAAO,CAAA,EAYX,GAAIxC,IAAgB,CAACG,EAAe,CAACqC,EAArC,CAA+C,CACvCM,IAAAA,EAAatF,EAAcsH,IAAgBA,EAAYhC,UAA7D,CACMuB,EAAa9G,EAAcuH,IAAgBA,EAAYT,UAA7D,CAEIA,GAAAA,GAAcvB,EAAY,CAC5B,IAAM4C,EAAarB,EAAWlM,MAA9B,CAEA,IAAK,IAAIwN,EAAID,EAAa,EAAGC,GAAK,EAAG,EAAEA,EACrC7C,EAAWqB,YAAX,CACE9G,EAAUgH,CAAU,CAACsB,EAAZ,CAAgB,CAAA,GACzBrI,EAAewH,GAGpB,CACF,CAGD,OADAlC,GAAakC,GACN,CAAA,CACR,QAGGA,AAAAA,aAAuBhI,GAAW,CAACwF,GAAqBwC,IAOzDtC,AAAAA,CAAAA,AAAY,aAAZA,GACCA,AAAY,YAAZA,GACAA,AAAY,aAAZA,CAAY,GACd7K,EAAW,8BAA+BmN,EAAYb,SAA5C,GATVrB,GAAakC,GACN,CAAA,IAeLvF,IAAsBuF,AAAyB,IAAzBA,EAAYvI,QAAZ,GAExBoB,EAAUmH,EAAYM,WAAtB,CAEA/O,EAAa,CAACiE,GAAeC,GAAUC,GAA3B,CAA0CoL,AAAAA,IACpDjI,EAAUtG,EAAcsG,EAASiI,EAAM,IACxC,GAEGd,EAAYM,WAAZ,GAA4BzH,IAC9B/G,EAAUsF,EAAUG,OAAX,CAAoB,CAAEvD,QAASgM,EAAYzH,SAAZ,EAAX,GAC7ByH,EAAYM,WAAZ,CAA0BzH,IAK9BiH,GAAa,wBAAyBE,EAAa,MAE5C,CAAA,EACR,EAWKe,GAAoB,SAAUC,CAAV,CAAiBC,CAAjB,CAAyB3M,CAAzB,EAExB,GACE0G,IACCiG,CAAAA,AAAW,OAAXA,GAAmBA,AAAW,SAAXA,CAAW,GAC9B3M,CAAAA,KAASkD,GAAYlD,KAAS+H,EAAAA,EAE/B,MAAO,CAAA,EAOT,GACE/B,IACA,CAACF,EAAW,CAAC6G,EADb,EAEApO,EAAW8C,GAAWsL,SAGjB,GAAI5G,IAAmBxH,EAAW+C,GAAWqL,SAG7C,GAAI,CAACvH,EAAY,CAACuH,EAAd,EAAyB7G,EAAW,CAAC6G,EAAzC,CAEH,CAAA,IAGCN,CAAAA,GAAsBK,IACnBpH,CAAAA,GAAwBC,YAAxB,YAAgD/G,QAChDD,EAAW+G,GAAwBC,YAAzB,CAAuCmH,IAChDpH,GAAwBC,YAAxB,YAAgD2C,UAC/C5C,GAAwBC,YAAxB,CAAqCmH,EAAAA,GACvCpH,CAAAA,GAAwBK,kBAAxB,YAAsDnH,QACtDD,EAAW+G,GAAwBK,kBAAzB,CAA6CgH,IACtDrH,GAAwBK,kBAAxB,YAAsDuC,UACrD5C,GAAwBK,kBAAxB,CAA2CgH,EAAAA,GAGhDA,AAAW,OAAXA,GACCrH,GAAwBM,8BADzB,EAEGN,CAAAA,GAAwBC,YAAxB,YAAgD/G,QAChDD,EAAW+G,GAAwBC,YAAzB,CAAuCvF,IAChDsF,GAAwBC,YAAxB,YAAgD2C,UAC/C5C,GAAwBC,YAAxB,CAAqCvF,EAAAA,CAArC,EAKN,MAAO,CAAA,CAAP,MAGG,GAAImH,EAAmB,CAACwF,EAAxB,OAIA,GACLpO,EAAWgD,GAAgBtD,EAAc+B,EAAOyB,GAAiB,WAK5D,GACJkL,AAAAA,CAAAA,AAAW,QAAXA,GAAoBA,AAAW,eAAXA,GAA2BA,AAAW,SAAXA,CAAW,GAC3DD,AAAU,WAAVA,GACAvO,AAAkC,IAAlCA,EAAc6B,EAAO,UACrBiH,EAAa,CAACyF,EAJT,OAUA,GACLzG,IACA,CAAC1H,EAAWiD,GAAmBvD,EAAc+B,EAAOyB,GAAiB,WAIhE,GAAIzB,EACT,MAAO,CAAA,EAMT,MAAO,CAAA,CACR,EAUKqM,GAAwB,SAAUjD,CAAV,EAC5B,OAAOA,EAAQhL,OAAR,CAAgB,KAAO,CAC/B,EAYKwO,GAAsB,SAAUlB,CAAV,EAE1BF,GAAa,2BAA4BE,EAAa,MAEhD,GAAA,CAAA,WAAEO,CAAAA,CAAF,CAAiBP,EAGnB,GAAA,CAACO,EACH,OAGF,IAAMY,EAAY,CAChBC,SAAU,GACVC,UAAW,GACXC,SAAU,CAAA,EACVC,kBAAmB7H,EAJH,EAMd3F,EAAIwM,EAAWlN,MAAnB,CAGOU,KAAAA,KAAK,CAEJ,GAAA,CAAA,KAAEqK,CAAF,CAAA,aAAQT,CAAR,CAAsBrJ,MAAO+M,CAAAA,CAA7B,CADOd,CAAU,CAACxM,EAAxB,CAEMkN,EAASpN,GAAkBuK,GAE7B9J,EAAQ8J,AAAS,UAATA,EAAmBiD,EAAY1O,EAAW0O,GAUlDF,GAPJA,EAAUC,QAAV,CAAqBH,EACrBE,EAAUE,SAAV,CAAsB/M,EACtB6M,EAAUG,QAAV,CAAqB,CAAA,EACrBH,EAAUK,aAAV,CAA0B1N,KAAAA,EAC1BgM,GAAa,wBAAyBE,EAAamB,GACnD7M,EAAQ6M,EAAUE,SAAlB,CAEIF,EAAUK,aAAd,GAKArD,GAAiBC,EAAM4B,GAGnB,CAACmB,EAAUG,QAAf,EAPE,SAYE,GAAA,CAAC9G,IAA4B3H,EAAW,OAAQyB,GAAQ,CAC1D6J,GAAiBC,EAAM4B,GACvB,QACD,CAGGvF,IACFlJ,EAAa,CAACiE,GAAeC,GAAUC,GAA3B,CAA0CoL,AAAAA,IACpDxM,EAAQ/B,EAAc+B,EAAOwM,EAAM,IACpC,GAIH,IAAME,EAAQnN,GAAkBmM,EAAYK,QAAb,EAC3B,GAACU,GAAkBC,EAAOC,EAAQ3M,IAgBtC,GATI2G,IAAyBgG,CAAAA,AAAW,OAAXA,GAAmBA,AAAW,SAAXA,CAAW,IAEzD9C,GAAiBC,EAAM4B,GAGvB1L,EAAQmN,AAh+BsB,gBAg+BQnN,GAKtC2C,GACA,AAAwB,UAAxB,OAAOb,GACP,AAAyC,YAAzC,OAAOA,EAAasL,gBAApB,EAEA,GAAI/D,QAGF,OAAQvH,EAAasL,gBAAb,CAA8BV,EAAOC,IAC3C,IAAK,cACH3M,EAAQ2C,EAAmBL,UAAnB,CAA8BtC,GACtC,KAGF,KAAK,mBACHA,EAAQ2C,EAAmBJ,eAAnB,CAAmCvC,EAP/C,EAmBA,GAAA,CACEqJ,EACFqC,EAAY2B,cAAZ,CAA2BhE,EAAcS,EAAM9J,GAG/C0L,EAAYvB,YAAZ,CAAyBL,EAAM9J,GAGjC1C,EAASwF,EAAUG,OAAX,CACT,CAAC,MAAOR,EAAG,CAAA,EACb,CAGD+I,GAAa,0BAA2BE,EAAa,KACtD,EAOK4B,GAAqB,SAArBA,EAA+BC,CAAV,EACrBC,IAAAA,EAAa,KACXC,EAAiBtC,GAAoBoC,GAK3C,IAFA/B,GAAa,0BAA2B+B,EAAU,MAE1CC,EAAaC,EAAeC,QAAf,IAEnBlC,GAAa,yBAA0BgC,EAAY,MAG/C3B,GAAkB2B,KAKlBA,EAAWjJ,OAAX,YAA8BhB,GAChC+J,EAAmBE,EAAWjJ,OAAZ,EAIpBqI,GAAoBY,IAItBhC,GAAa,yBAA0B+B,EAAU,KAClD,EAmRD,OAzQAzK,EAAU6K,QAAV,CAAqB,SAAUtD,CAAV,EAAiBjC,IAAAA,EAAU,UAAA,MAAA,CAAA,GAAA,AAAA,KAAA,IAAA,SAAA,CAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAJ,CAAA,EACtC0C,EAAO,KACP8C,EAAe,KACflC,EAAc,KACdmC,EAAa,KAUb,GANJpG,CAAAA,GAAiB,CAAC4C,CADtB,GAGMA,CAAAA,EAAQ,OADV,EAKI,AAAiB,UAAjB,OAAOA,GAAsB,CAACkB,GAAQlB,IACxC,GAAI,AAA0B,YAA1B,OAAOA,EAAMvM,QAAb,CAEF,CAAA,GAAI,AAAiB,UAAjB,MADJuM,CAAAA,EAAQA,EAAMvM,QAAN,EAARuM,EAEQ3L,MAAAA,EAAgB,kCADxB,MAIMA,MAAAA,EAAgB,8BAK1B,GAAI,CAACoE,EAAUM,WAAf,CACE,OAAOiH,EAgBT,GAZKhE,IACH8B,GAAaC,GAIftF,EAAUG,OAAV,CAAoB,EAApB,CAGqB,UAAjB,OAAOoH,GACTxD,CAAAA,GAAW,CAAA,CAFb,EAKIA,GAEEwD,CAAAA,GAAAA,EAAM0B,QAAV,CAAoB,CAClB,IAAM3C,EAAU7J,GAAkB8K,EAAM0B,QAAP,EAC7B,GAAA,CAAC7G,EAAY,CAACkE,EAAd,EAA0BvD,EAAW,CAACuD,EAA1C,CACQ1K,MAAAA,EACJ,0DAGL,CAAA,MACI,GAAI2L,aAAiB5G,EAKtBmK,AAA0B,IAA1BA,AADJA,CAAAA,EAAe9C,AADfA,CAAAA,EAAOV,GAAc,UAD3B,EAE0B5F,aAAL,CAAmBM,UAAnB,CAA8BuF,EAAO,CAAA,EAApDuD,EACiBzK,QAAb,EAA+ByK,AAA0B,SAA1BA,EAAa7B,QAAb,CAEjCjB,EAAO8C,EACEA,AAA0B,SAA1BA,EAAa7B,QAAb,CACTjB,EAAO8C,EAGP9C,EAAKgD,WAAL,CAAiBF,OAEd,CAGH,GAAA,CAACrH,IACD,CAACJ,IACD,CAACC,IAEDiE,AAAuB,KAAvBA,EAAMjM,OAAN,CAAc,KAEPuE,OAAAA,GAAsB8D,GACzB9D,EAAmBL,UAAnB,CAA8B+H,GAC9BA,EAOF,GAAA,CAHJS,CAAAA,EAAOV,GAAcC,EADrB,EAKS9D,OAAAA,GAAa,KAAOE,GAAsBhC,EAAY,EAEhE,CAGGqG,GAAQxE,IACVkD,GAAasB,EAAKiD,UAAN,EAIRC,IAAAA,EAAe7C,GAAoBtE,GAAWwD,EAAQS,GAG5D,KAAQY,EAAcsC,EAAaN,QAAb,IAEhB7B,GAAkBH,KAKlBA,EAAYnH,OAAZ,YAA+BhB,GACjC+J,GAAmB5B,EAAYnH,OAAb,EAIpBqI,GAAoBlB,IAItB,GAAI7E,GACF,OAAOwD,EAIT,GAAI9D,GAAY,CACd,GAAIC,GAGKsE,IAFP+C,EAAajJ,GAAuBsG,IAAvB,CAA4BJ,EAAKtG,aAAjC,EAENsG,EAAKiD,UAAZ,EAEEF,EAAWC,WAAX,CAAuBhD,EAAKiD,UAA5B,OAGFF,EAAa/C,EAcf,MAXI1F,CAAAA,GAAa6I,UAAb,EAA2B7I,GAAa8I,cAA5C,AAA4CA,GAQ1CL,CAAAA,EAAa/I,GAAWoG,IAAX,CAAgB7H,EAAkBwK,EAAY,CAAA,EADnE,EAIaA,CACR,CAEGM,IAAAA,EAAiB/H,GAAiB0E,EAAKsD,SAAR,CAAoBtD,EAAKD,SAA5D,CAsBOlI,OAlBLyD,IACAlB,EAAY,CAAC,WADb,EAEA4F,EAAKtG,aAFL,EAGAsG,EAAKtG,aAAL,CAAmB6J,OAHnB,EAIAvD,EAAKtG,aAAL,CAAmB6J,OAAnB,CAA2BvE,IAJ3B,EAKAvL,EAAWoD,EAA0BmJ,EAAKtG,aAAL,CAAmB6J,OAAnB,CAA2BvE,IAAtD,GAEVqE,CAAAA,EACE,aAAerD,EAAKtG,aAAL,CAAmB6J,OAAnB,CAA2BvE,IAA1C,CAAiD,MAAQqE,CAV7D,EAcIhI,IACFlJ,EAAa,CAACiE,GAAeC,GAAUC,GAA3B,CAA0CoL,AAAAA,IACpD2B,EAAiBlQ,EAAckQ,EAAgB3B,EAAM,IACtD,GAGI7J,GAAsB8D,GACzB9D,EAAmBL,UAAnB,CAA8B6L,GAC9BA,CACL,EAQDrL,EAAUwL,SAAV,CAAsB,WAAUlG,IAAAA,EAAU,UAAA,MAAA,CAAA,GAAA,AAAA,KAAA,IAAA,SAAA,CAAA,EAAA,CAAA,SAAA,CAAA,EAAA,CAAJ,CAAA,EACpCD,GAAaC,GACb/B,GAAa,CAAA,CACd,EAODvD,EAAUyL,WAAV,CAAwB,WACtBzG,GAAS,KACTzB,GAAa,CAAA,CACd,EAYDvD,EAAU0L,gBAAV,CAA6B,SAAUC,CAAV,CAAeC,CAAf,CAAqB1O,CAArB,EAQ3B,OANK8H,IACHK,GAAa,CAAA,GAKRsE,GAFOlN,GAAkBkP,GACjBlP,GAAkBmP,GACO1O,EACzC,EASD8C,EAAU6L,OAAV,CAAoB,SAAUlD,CAAV,CAAsBmD,CAAtB,EACU,YAAxB,OAAOA,IAIX7J,EAAK,CAAC0G,EAAN,CAAoB1G,EAAK,CAAC0G,EAAN,EAAqB,EAAzC,CACAjO,EAAUuH,EAAK,CAAC0G,EAAP,CAAoBmD,GAC9B,EAUD9L,EAAU+L,UAAV,CAAuB,SAAUpD,CAAV,EACrB,GAAI1G,EAAK,CAAC0G,EAAV,CACE,OAAOnO,EAASyH,EAAK,CAAC0G,EAAP,CAElB,EAQD3I,EAAUgM,WAAV,CAAwB,SAAUrD,CAAV,EAClB1G,EAAK,CAAC0G,EAAV,EACE1G,CAAAA,EAAK,CAAC0G,EAAN,CAAoB,EAApB,AAAoB,CAEvB,EAMD3I,EAAUiM,cAAV,CAA2B,WACzBhK,GAAQ,CAAA,CACT,EAEMjC,CACR,G,I,I,E,C,G,A,S,C,EE/lDM,SAAS,IACZ,MAAO,CACH,MAAO,CAAA,EACP,OAAQ,CAAA,EACR,WAAY,KACZ,IAAK,CAAA,EACL,MAAO,KACP,SAAU,CAAA,EACV,SAAU,KACV,OAAQ,CAAA,EACR,UAAW,KACX,WAAY,IACpB,CACA,CAEO,SAAS,EAAe,CAAW,EACtCuhB,EAAAA,QAAS,CAAG,CAChB,CAHWA,EAAAA,QAAS,CAAG,ICdvB,IAAM,EAAa,UACb,EAAgB,AAAI,OAAO,EAAW,MAAM,CAAE,KAC9C,EAAqB,oDACrB,EAAwB,AAAI,OAAO,EAAmB,MAAM,CAAE,KAC9D,EAAqB,CACvB,IAAK,QACL,IAAK,OACL,IAAK,OACL,IAAK,SACL,IAAK,OACT,EACM,EAAuB,AAAC,GAAO,CAAkB,CAAC,EAAG,CACpD,SAASnM,EAAO,CAAI,CAAE,CAAM,EAC/B,GAAI,EACA,CAAA,GAAI,EAAW,IAAI,CAAC,GAChB,OAAO,EAAK,OAAO,CAAC,EAAe,EADvC,MAKA,GAAI,EAAmB,IAAI,CAAC,GACxB,OAAO,EAAK,OAAO,CAAC,EAAuB,GAGnD,OAAO,CACX,CACA,IAAM,EAAe,6CAef,EAAQ,eACP,SAAS,EAAK,CAAK,CAAE,CAAG,EAC3B,IAAI,EAAS,AAAiB,UAAjB,OAAO,EAAqB,EAAQ,EAAM,MAAM,CAC7D,EAAM,GAAO,GACb,IAAM,EAAM,CACR,QAAS,CAAC,EAAM,KACZ,IAAI,EAAY,AAAe,UAAf,OAAO,EAAmB,EAAM,EAAI,MAAM,CAG1D,OAFA,EAAY,EAAU,OAAO,CAAC,EAAO,MACrC,EAAS,EAAO,OAAO,CAAC,EAAM,GACvB,CACnB,EACQ,SAAU,IACC,IAAI,OAAO,EAAQ,EAEtC,EACI,OAAO,CACX,CACO,SAAS,EAAS,CAAI,EACzB,GAAI,CACA,EAAO,UAAU,GAAM,OAAO,CAAC,OAAQ,IAC/C,CACI,MAAO,EAAG,CACN,OAAO,IACf,CACI,OAAO,CACX,CACO,IAAM,EAAW,CAAE,KAAM,IAAM,IAAI,EACnC,SAAS,EAAW,CAAQ,CAAE,CAAK,EAGtC,IAcI,EAAQ,AAdA,EAAS,OAAO,CAAC,MAAO,CAAC,EAAO,EAAQ,KAChD,IAAI,EAAU,CAAA,EACV,EAAO,EACX,KAAO,EAAE,GAAQ,GAAK,AAAc,OAAd,CAAG,CAAC,EAAK,EAC3B,EAAU,CAAC,SACf,AAAI,EAGO,IAIA,IAEnB,GAAoB,KAAK,CAAC,OAClB,EAAI,EAQR,GANK,CAAK,CAAC,EAAE,CAAC,IAAI,IACd,EAAM,KAAK,GAEX,EAAM,MAAM,CAAG,GAAK,CAAC,CAAK,CAAC,EAAM,MAAM,CAAG,EAAE,CAAC,IAAI,IACjD,EAAM,GAAG,GAET,GACA,GAAI,EAAM,MAAM,CAAG,EACf,EAAM,MAAM,CAAC,QAGb,KAAO,EAAM,MAAM,CAAG,GAClB,EAAM,IAAI,CAAC,IAGvB,KAAO,EAAI,EAAM,MAAM,CAAE,IAErB,CAAK,CAAC,EAAE,CAAG,CAAK,CAAC,EAAE,CAAC,IAAI,GAAG,OAAO,CAAC,QAAS,KAEhD,OAAO,CACX,CASO,SAAS,EAAM,CAAG,CAAE,CAAC,CAAE,CAAM,EAChC,IAAM,EAAI,EAAI,MAAM,CACpB,GAAI,AAAM,IAAN,EACA,MAAO,GAGX,IAAI,EAAU,EAEd,KAAO,EAAU,GAAG,CAChB,IAAM,EAAW,EAAI,MAAM,CAAC,EAAI,EAAU,GAC1C,GAAI,IAAa,GAAM,GAGlB,GAAI,IAAa,GAAK,EACvB,SAGA,WANA,GAQZ,CACI,OAAO,EAAI,KAAK,CAAC,EAAG,EAAI,EAC5B,CC1IA,SAAS,EAAW,CAAG,CAAE,CAAI,CAAE,CAAG,CAAE,CAAK,EACrC,IAAM,EAAO,EAAK,IAAI,CAChB,EAAQ,EAAK,KAAK,CAAGA,EAAO,EAAK,KAAK,EAAI,KAC1C,EAAO,CAAG,CAAC,EAAE,CAAC,OAAO,CAAC,cAAe,MAC3C,GAAI,AAAqB,MAArB,CAAG,CAAC,EAAE,CAAC,MAAM,CAAC,GAAY,CAC1B,EAAM,KAAK,CAAC,MAAM,CAAG,CAAA,EACrB,IAAM,EAAQ,CACV,KAAM,OACN,IAAA,EACA,KAAA,EACA,MAAA,EACA,KAAA,EACA,OAAQ,EAAM,YAAY,CAAC,EACvC,EAEQ,OADA,EAAM,KAAK,CAAC,MAAM,CAAG,CAAA,EACd,CACf,CACI,MAAO,CACH,KAAM,QACN,IAAA,EACA,KAAA,EACA,MAAA,EACA,KAAMA,EAAO,EACrB,CACA,CAyBO,MAAM,EACT,OAAQ,AACR,CAAA,KAAM,AACN,CAAA,KAAM,AACN,aAAY,CAAO,CAAE,CACjB,IAAI,CAAC,OAAO,CAAG,GAAWmM,EAAAA,QAAS,AAC3C,CACI,MAAM,CAAG,CAAE,CACP,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAC1C,GAAI,GAAO,CAAG,CAAC,EAAE,CAAC,MAAM,CAAG,EACvB,MAAO,CACH,KAAM,QACN,IAAK,CAAG,CAAC,EAAE,AAC3B,CAEA,CACI,KAAK,CAAG,CAAE,CACN,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GACvC,GAAI,EAAK,CACL,IAAM,EAAO,CAAG,CAAC,EAAE,CAAC,OAAO,CAAC,YAAa,IACzC,MAAO,CACH,KAAM,OACN,IAAK,CAAG,CAAC,EAAE,CACX,eAAgB,WAChB,KAAM,AAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAEtB,EADA,EAAM,EAAM,KAElC,CACA,CACA,CACI,OAAO,CAAG,CAAE,CACR,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,GACzC,GAAI,EAAK,CACL,IAAM,EAAM,CAAG,CAAC,EAAE,CACZ,EAAO,AA1DzB,SAAgC,CAAG,CAAE,CAAI,EACrC,IAAM,EAAoB,EAAI,KAAK,CAAC,iBACpC,GAAI,AAAsB,OAAtB,EACA,OAAO,EAEX,IAAM,EAAe,CAAiB,CAAC,EAAE,CACzC,OAAO,EACF,KAAK,CAAC,MACN,GAAG,CAAC,AAAA,IACL,IAAM,EAAoB,EAAK,KAAK,CAAC,QACrC,GAAI,AAAsB,OAAtB,EACA,OAAO,EAEX,GAAM,CAAC,EAAa,CAAG,SACvB,AAAI,EAAa,MAAM,EAAI,EAAa,MAAM,CACnC,EAAK,KAAK,CAAC,EAAa,MAAM,EAElC,CACf,GACS,IAAI,CAAC,KACd,EAsCgD,EAAK,CAAG,CAAC,EAAE,EAAI,IACnD,MAAO,CACH,KAAM,OACN,IAAA,EACA,KAAM,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAE,MAAQ,CAAG,CAAC,EAAE,CACrF,KAAA,CAChB,CACA,CACA,CACI,QAAQ,CAAG,CAAE,CACT,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAC1C,GAAI,EAAK,CACL,IAAI,EAAO,CAAG,CAAC,EAAE,CAAC,IAAI,GAEtB,GAAI,KAAK,IAAI,CAAC,GAAO,CACjB,IAAM,EAAU,EAAM,EAAM,IACxB,CAAA,IAAI,CAAC,OAAO,CAAC,QAAQ,CACrB,EAAO,EAAQ,IAAI,GAEd,CAAA,CAAC,GAAW,KAAK,IAAI,CAAC,EAAA,GAE3B,CAAA,EAAO,EAAQ,IAAI,EAAnB,CAEpB,CACY,MAAO,CACH,KAAM,UACN,IAAK,CAAG,CAAC,EAAE,CACX,MAAO,CAAG,CAAC,EAAE,CAAC,MAAM,CACpB,KAAA,EACA,OAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAC1C,CACA,CACA,CACI,GAAG,CAAG,CAAE,CACJ,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,GACrC,GAAI,EACA,MAAO,CACH,KAAM,KACN,IAAK,CAAG,CAAC,EAAE,AAC3B,CAEA,CACI,WAAW,CAAG,CAAE,CACZ,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,GAC7C,GAAI,EAAK,CACL,IAAM,EAAO,EAAM,CAAG,CAAC,EAAE,CAAC,OAAO,CAAC,eAAgB,IAAK,MACjD,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,AAChC,CAAA,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAG,CAAA,EACvB,IAAM,EAAS,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,GAEtC,OADA,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAG,EAChB,CACH,KAAM,aACN,IAAK,CAAG,CAAC,EAAE,CACX,OAAA,EACA,KAAA,CAChB,CACA,CACA,CACI,KAAK,CAAG,CAAE,CACN,IAAI,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GACrC,GAAI,EAAK,CACL,IAAI,EAAO,CAAG,CAAC,EAAE,CAAC,IAAI,GAChB,EAAY,EAAK,MAAM,CAAG,EAC1B,EAAO,CACT,KAAM,OACN,IAAK,GACL,QAAS,EACT,MAAO,EAAY,CAAC,EAAK,KAAK,CAAC,EAAG,IAAM,GACxC,MAAO,CAAA,EACP,MAAO,EAAE,AACzB,EACY,EAAO,EAAY,CAAC,UAAU,EAAE,EAAK,KAAK,CAAC,IAAI,CAAC,CAAG,CAAC,EAAE,EAAE,EAAK,CAAC,CAC1D,IAAI,CAAC,OAAO,CAAC,QAAQ,EACrB,CAAA,EAAO,EAAY,EAAO,OAD9B,EAIA,IAAM,EAAY,AAAI,OAAO,CAAC,QAAQ,EAAE,EAAK,4BAA6B,CAAC,EACvE,EAAM,GACN,EAAe,GACf,EAAoB,CAAA,EAExB,KAAO,GAAK,CACR,IAkGI,EAlGA,EAAW,CAAA,EACf,GAAI,CAAE,CAAA,EAAM,EAAU,IAAI,CAAC,EAAA,GAGvB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,GAFzB,MAKJ,EAAM,CAAG,CAAC,EAAE,CACZ,EAAM,EAAI,SAAS,CAAC,EAAI,MAAM,EAC9B,IAAI,EAAO,CAAG,CAAC,EAAE,CAAC,KAAK,CAAC,KAAM,EAAE,CAAC,EAAE,CAAC,OAAO,CAAC,OAAQ,AAAC,GAAM,IAAI,MAAM,CAAC,EAAI,EAAE,MAAM,GAC9E,EAAW,EAAI,KAAK,CAAC,KAAM,EAAE,CAAC,EAAE,CAChC,EAAS,CACT,CAAA,IAAI,CAAC,OAAO,CAAC,QAAQ,EACrB,EAAS,EACT,EAAe,EAAK,SAAS,KAI7B,EAAS,AADT,CAAA,EAAS,CAAG,CAAC,EAAE,CAAC,MAAM,CAAC,OAAA,EACL,EAAI,EAAI,EAC1B,EAAe,EAAK,KAAK,CAAC,GAC1B,GAAU,CAAG,CAAC,EAAE,CAAC,MAAM,EAE3B,IAAI,EAAY,CAAA,EAMhB,GALI,CAAC,GAAQ,OAAO,IAAI,CAAC,KACrB,GAAO,EAAW,KAClB,EAAM,EAAI,SAAS,CAAC,EAAS,MAAM,CAAG,GACtC,EAAW,CAAA,GAEX,CAAC,EAAU,CACX,IAAM,EAAkB,AAAI,OAAO,CAAC,KAAK,EAAE,KAAK,GAAG,CAAC,EAAG,EAAS,GAAG,kDAAmD,CAAC,EACjH,EAAU,AAAI,OAAO,CAAC,KAAK,EAAE,KAAK,GAAG,CAAC,EAAG,EAAS,GAAG,kDAAkD,CAAC,EACxG,EAAmB,AAAI,OAAO,CAAC,KAAK,EAAE,KAAK,GAAG,CAAC,EAAG,EAAS,GAAG,eAAe,CAAC,EAC9E,EAAoB,AAAI,OAAO,CAAC,KAAK,EAAE,KAAK,GAAG,CAAC,EAAG,EAAS,GAAG,EAAE,CAAC,EAExE,KAAO,GAAK,CACR,IAAM,EAAU,EAAI,KAAK,CAAC,KAAM,EAAE,CAAC,EAAE,CAOrC,GANA,EAAW,EAEP,IAAI,CAAC,OAAO,CAAC,QAAQ,EACrB,CAAA,EAAW,EAAS,OAAO,CAAC,0BAA2B,KAD3D,EAII,EAAiB,IAAI,CAAC,IAItB,EAAkB,IAAI,CAAC,IAIvB,EAAgB,IAAI,CAAC,IAIrB,EAAQ,IAAI,CAAC,GAXb,MAcJ,GAAI,EAAS,MAAM,CAAC,SAAW,GAAU,CAAC,EAAS,IAAI,GACnD,GAAgB,KAAO,EAAS,KAAK,CAAC,OAErC,CAED,GAAI,GAIA,EAAK,MAAM,CAAC,SAAW,GAGvB,EAAiB,IAAI,CAAC,IAGtB,EAAkB,IAAI,CAAC,IAGvB,EAAQ,IAAI,CAAC,GAZb,MAeJ,GAAgB,KAAO,CACnD,CAC6B,GAAc,EAAS,IAAI,IAC5B,CAAA,EAAY,CAAA,CADhB,EAGA,GAAO,EAAU,KACjB,EAAM,EAAI,SAAS,CAAC,EAAQ,MAAM,CAAG,GACrC,EAAO,EAAS,KAAK,CAAC,EAC9C,CACA,CACoB,CAAC,EAAK,KAAK,GAEP,EACA,EAAK,KAAK,CAAG,CAAA,EAER,YAAY,IAAI,CAAC,IACtB,CAAA,EAAoB,CAAA,CADnB,GAIT,IAAI,EAAS,IAGT,CAAA,IAAI,CAAC,OAAO,CAAC,GAAG,EAChB,CAAA,EAAS,cAAc,IAAI,CAAC,EAA5B,IAEI,EAAY,AAAc,SAAd,CAAM,CAAC,EAAE,CACrB,EAAe,EAAa,OAAO,CAAC,eAAgB,KAG5D,EAAK,KAAK,CAAC,IAAI,CAAC,CACZ,KAAM,YACN,IAAA,EACA,KAAM,CAAC,CAAC,EACR,QAAS,EACT,MAAO,CAAA,EACP,KAAM,EACN,OAAQ,EAAE,AAC9B,GACgB,EAAK,GAAG,EAAI,CAC5B,CAEY,EAAK,KAAK,CAAC,EAAK,KAAK,CAAC,MAAM,CAAG,EAAE,CAAC,GAAG,CAAG,EAAI,OAAO,GAClD,EAAK,KAAK,CAAC,EAAK,KAAK,CAAC,MAAM,CAAG,EAAE,CAAE,IAAI,CAAG,EAAa,OAAO,GAC/D,EAAK,GAAG,CAAG,EAAK,GAAG,CAAC,OAAO,GAE3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,KAAK,CAAC,MAAM,CAAE,IAGnC,GAFA,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAG,CAAA,EACvB,EAAK,KAAK,CAAC,EAAE,CAAC,MAAM,CAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,EAAK,KAAK,CAAC,EAAE,CAAC,IAAI,CAAE,EAAE,EAChE,CAAC,EAAK,KAAK,CAAE,CAEb,IAAM,EAAU,EAAK,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,AAAA,GAAK,AAAW,UAAX,EAAE,IAAI,EACjD,EAAwB,EAAQ,MAAM,CAAG,GAAK,EAAQ,IAAI,CAAC,AAAA,GAAK,SAAS,IAAI,CAAC,EAAE,GAAG,EACzF,CAAA,EAAK,KAAK,CAAG,CACjC,CAGY,GAAI,EAAK,KAAK,CACV,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,KAAK,CAAC,MAAM,CAAE,IACnC,EAAK,KAAK,CAAC,EAAE,CAAC,KAAK,CAAG,CAAA,EAG9B,OAAO,CACnB,CACA,CACI,KAAK,CAAG,CAAE,CACN,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GACvC,GAAI,EAQA,MAPc,CACV,KAAM,OACN,MAAO,CAAA,EACP,IAAK,CAAG,CAAC,EAAE,CACX,IAAK,AAAW,QAAX,CAAG,CAAC,EAAE,EAAc,AAAW,WAAX,CAAG,CAAC,EAAE,EAAiB,AAAW,UAAX,CAAG,CAAC,EAAE,CACtD,KAAM,CAAG,CAAC,EAAE,AAC5B,CAGA,CACI,IAAI,CAAG,CAAE,CACL,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,GACtC,GAAI,EAAK,CACL,IAAM,EAAM,CAAG,CAAC,EAAE,CAAC,WAAW,GAAG,OAAO,CAAC,OAAQ,KAC3C,EAAO,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAC,OAAO,CAAC,WAAY,MAAM,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAE,MAAQ,GACnG,EAAQ,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAC,SAAS,CAAC,EAAG,CAAG,CAAC,EAAE,CAAC,MAAM,CAAG,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAE,MAAQ,CAAG,CAAC,EAAE,CACtH,MAAO,CACH,KAAM,MACN,IAAA,EACA,IAAK,CAAG,CAAC,EAAE,CACX,KAAA,EACA,MAAA,CAChB,CACA,CACA,CACI,MAAM,CAAG,CAAE,CACP,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GACxC,GAAI,CAAC,GAGD,CAAC,OAAO,IAAI,CAAC,CAAG,CAAC,EAAE,EAFnB,OAMJ,IAAM,EAAU,EAAW,CAAG,CAAC,EAAE,EAC3B,EAAS,CAAG,CAAC,EAAE,CAAC,OAAO,CAAC,aAAc,IAAI,KAAK,CAAC,KAChD,EAAO,CAAG,CAAC,EAAE,EAAI,CAAG,CAAC,EAAE,CAAC,IAAI,GAAK,CAAG,CAAC,EAAE,CAAC,OAAO,CAAC,YAAa,IAAI,KAAK,CAAC,MAAQ,EAAE,CACjF,EAAO,CACT,KAAM,QACN,IAAK,CAAG,CAAC,EAAE,CACX,OAAQ,EAAE,CACV,MAAO,EAAE,CACT,KAAM,EAAE,AACpB,EACQ,GAAI,EAAQ,MAAM,GAAK,EAAO,MAAM,EAIpC,IAAK,IAAM,KAAS,EACZ,YAAY,IAAI,CAAC,GACjB,EAAK,KAAK,CAAC,IAAI,CAAC,SAEX,aAAa,IAAI,CAAC,GACvB,EAAK,KAAK,CAAC,IAAI,CAAC,UAEX,YAAY,IAAI,CAAC,GACtB,EAAK,KAAK,CAAC,IAAI,CAAC,QAGhB,EAAK,KAAK,CAAC,IAAI,CAAC,MAGxB,IAAK,IAAM,KAAU,EACjB,EAAK,MAAM,CAAC,IAAI,CAAC,CACb,KAAM,EACN,OAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAC1C,GAEQ,IAAK,IAAM,KAAO,EACd,EAAK,IAAI,CAAC,IAAI,CAAC,EAAW,EAAK,EAAK,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,AAAA,GAC5C,CAAA,CACH,KAAM,EACN,OAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAC9C,CAAA,IAGQ,OAAO,EACf,CACI,SAAS,CAAG,CAAE,CACV,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,GAC3C,GAAI,EACA,MAAO,CACH,KAAM,UACN,IAAK,CAAG,CAAC,EAAE,CACX,MAAO,AAAqB,MAArB,CAAG,CAAC,EAAE,CAAC,MAAM,CAAC,GAAa,EAAI,EACtC,KAAM,CAAG,CAAC,EAAE,CACZ,OAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAG,CAAC,EAAE,CAChD,CAEA,CACI,UAAU,CAAG,CAAE,CACX,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,GAC5C,GAAI,EAAK,CACL,IAAM,EAAO,AAAqC,OAArC,CAAG,CAAC,EAAE,CAAC,MAAM,CAAC,CAAG,CAAC,EAAE,CAAC,MAAM,CAAG,GACrC,CAAG,CAAC,EAAE,CAAC,KAAK,CAAC,EAAG,IAChB,CAAG,CAAC,EAAE,CACZ,MAAO,CACH,KAAM,YACN,IAAK,CAAG,CAAC,EAAE,CACX,KAAA,EACA,OAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAC1C,CACA,CACA,CACI,KAAK,CAAG,CAAE,CACN,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GACvC,GAAI,EACA,MAAO,CACH,KAAM,OACN,IAAK,CAAG,CAAC,EAAE,CACX,KAAM,CAAG,CAAC,EAAE,CACZ,OAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAG,CAAC,EAAE,CAChD,CAEA,CACI,OAAO,CAAG,CAAE,CACR,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAC1C,GAAI,EACA,MAAO,CACH,KAAM,SACN,IAAK,CAAG,CAAC,EAAE,CACX,KAAMnM,EAAO,CAAG,CAAC,EAAE,CACnC,CAEA,CACI,IAAI,CAAG,CAAE,CACL,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GACvC,GAAI,EAaA,MAZI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,EAAI,QAAQ,IAAI,CAAC,CAAG,CAAC,EAAE,EAC/C,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAG,CAAA,EAErB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,EAAI,UAAU,IAAI,CAAC,CAAG,CAAC,EAAE,GACrD,CAAA,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAG,CAAA,CADzB,EAGD,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,EAAI,iCAAiC,IAAI,CAAC,CAAG,CAAC,EAAE,EAC5E,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,CAAG,CAAA,EAEzB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,EAAI,mCAAmC,IAAI,CAAC,CAAG,CAAC,EAAE,GAClF,CAAA,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,CAAG,CAAA,CAD7B,EAGE,CACH,KAAM,OACN,IAAK,CAAG,CAAC,EAAE,CACX,OAAQ,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAC/B,WAAY,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,CACvC,MAAO,CAAA,EACP,KAAM,CAAG,CAAC,EAAE,AAC5B,CAEA,CACI,KAAK,CAAG,CAAE,CACN,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GACxC,GAAI,EAAK,CACL,IAAM,EAAa,CAAG,CAAC,EAAE,CAAC,IAAI,GAC9B,GAAI,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAI,KAAK,IAAI,CAAC,GAAa,CAEjD,GAAI,CAAE,KAAK,IAAI,CAAC,GACZ,OAGJ,IAAM,EAAa,EAAM,EAAW,KAAK,CAAC,EAAG,IAAK,MAClD,GAAI,AAAC,CAAA,EAAW,MAAM,CAAG,EAAW,MAAM,AAAN,EAAU,GAAM,EAChD,MAEpB,KACiB,CAED,IAAM,EAAiB,ADlVhC,SAA4B,CAAG,CAAE,CAAC,EACrC,GAAI,AAAsB,KAAtB,EAAI,OAAO,CAAC,CAAC,CAAC,EAAE,EAChB,OAAO,GAEX,IAAI,EAAQ,EACZ,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,IAC5B,GAAI,AAAW,OAAX,CAAG,CAAC,EAAE,CACN,SAEC,GAAI,CAAG,CAAC,EAAE,GAAK,CAAC,CAAC,EAAE,CACpB,SAEC,GAAI,CAAG,CAAC,EAAE,GAAK,CAAC,CAAC,EAAE,EAEhB,EAAA,EAAQ,EACR,OAAO,EAInB,OAAO,EACX,EC8T0D,CAAG,CAAC,EAAE,CAAE,MAClD,GAAI,EAAiB,GAAI,CAErB,IAAM,EAAU,AADF,CAAA,AAAwB,IAAxB,CAAG,CAAC,EAAE,CAAC,OAAO,CAAC,KAAa,EAAI,CAAA,EACtB,CAAG,CAAC,EAAE,CAAC,MAAM,CAAG,CACxC,CAAA,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAC,SAAS,CAAC,EAAG,GAC7B,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAC,SAAS,CAAC,EAAG,GAAS,IAAI,GAC1C,CAAG,CAAC,EAAE,CAAG,EAC7B,CACA,CACY,IAAI,EAAO,CAAG,CAAC,EAAE,CACb,EAAQ,GACZ,GAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAE,CAEvB,IAAM,EAAO,gCAAgC,IAAI,CAAC,GAC9C,IACA,EAAO,CAAI,CAAC,EAAE,CACd,EAAQ,CAAI,CAAC,EAAE,CAEnC,MAEgB,EAAQ,CAAG,CAAC,EAAE,CAAG,CAAG,CAAC,EAAE,CAAC,KAAK,CAAC,EAAG,IAAM,GAY3C,OAVA,EAAO,EAAK,IAAI,GACZ,KAAK,IAAI,CAAC,KAGN,EAFA,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAI,CAAE,KAAK,IAAI,CAAC,GAE9B,EAAK,KAAK,CAAC,GAGX,EAAK,KAAK,CAAC,EAAG,KAGtB,EAAW,EAAK,CACnB,KAAM,EAAO,EAAK,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAE,MAAQ,EACpE,MAAO,EAAQ,EAAM,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAE,MAAQ,CACvF,EAAe,CAAG,CAAC,EAAE,CAAE,IAAI,CAAC,KAAK,CACjC,CACA,CACI,QAAQ,CAAG,CAAE,CAAK,CAAE,CAChB,IAAI,EACJ,GAAI,AAAC,CAAA,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EAAA,GAClC,CAAA,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAA,EAAO,CAE/C,IAAM,EAAO,CAAK,CAAC,AADA,AAAC,CAAA,CAAG,CAAC,EAAE,EAAI,CAAG,CAAC,EAAE,AAAF,EAAI,OAAO,CAAC,OAAQ,KACxB,WAAW,GAAG,CAC5C,GAAI,CAAC,EAAM,CACP,IAAM,EAAO,CAAG,CAAC,EAAE,CAAC,MAAM,CAAC,GAC3B,MAAO,CACH,KAAM,OACN,IAAK,EACL,KAAA,CACpB,CACA,CACY,OAAO,EAAW,EAAK,EAAM,CAAG,CAAC,EAAE,CAAE,IAAI,CAAC,KAAK,CAC3D,CACA,CACI,SAAS,CAAG,CAAE,CAAS,CAAE,EAAW,EAAE,CAAE,CACpC,IAAI,EAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,GAClD,KAAI,CAAC,GAGD,CAAK,CAAC,EAAE,EAAI,EAAS,KAAK,CAAC,mBAG3B,CAAA,CADa,CAAA,CAAK,CAAC,EAAE,EAAI,CAAK,CAAC,EAAE,AAAF,GAClB,CAAC,GAAY,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,EAAA,EAAW,CAExE,IAAM,EAAU,IAAI,CAAK,CAAC,EAAE,CAAC,CAAC,MAAM,CAAG,EACnC,EAAQ,EAAS,EAAa,EAAS,EAAgB,EACrD,EAAS,AAAgB,MAAhB,CAAK,CAAC,EAAE,CAAC,EAAE,CAAW,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,iBAAiB,CAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,iBAAiB,CAI9G,IAHA,EAAO,SAAS,CAAG,EAEnB,EAAY,EAAU,KAAK,CAAC,GAAK,EAAI,MAAM,CAAG,GACtC,AAAmC,MAAnC,CAAA,EAAQ,EAAO,IAAI,CAAC,EAAA,GAAqB,CAE7C,GAAI,CADJ,CAAA,EAAS,CAAK,CAAC,EAAE,EAAI,CAAK,CAAC,EAAE,EAAI,CAAK,CAAC,EAAE,EAAI,CAAK,CAAC,EAAE,EAAI,CAAK,CAAC,EAAE,EAAI,CAAK,CAAC,EAAE,AAAF,EAEvE,SAEJ,GADA,EAAU,IAAI,EAAO,CAAC,MAAM,CACxB,CAAK,CAAC,EAAE,EAAI,CAAK,CAAC,EAAE,CAAE,CACtB,GAAc,EACd,QACpB,CACqB,GAAI,CAAA,CAAK,CAAC,EAAE,EAAI,CAAK,CAAC,EAAE,AAAF,GACnB,EAAU,GAAK,CAAG,CAAA,AAAA,CAAA,EAAU,CAAA,EAAW,CAAA,EAAI,CAC3C,GAAiB,EACjB,QACxB,CAGgB,GAAI,AADJ,CAAA,GAAc,CAAd,EACiB,EACb,SAEJ,EAAU,KAAK,GAAG,CAAC,EAAS,EAAU,EAAa,GAEnD,IAAM,EAAiB,IAAI,CAAK,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,MAAM,CACxC,EAAM,EAAI,KAAK,CAAC,EAAG,EAAU,EAAM,KAAK,CAAG,EAAiB,GAElE,GAAI,KAAK,GAAG,CAAC,EAAS,GAAW,EAAG,CAChC,IAAM,EAAO,EAAI,KAAK,CAAC,EAAG,IAC1B,MAAO,CACH,KAAM,KACN,IAAA,EACA,KAAA,EACA,OAAQ,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,EACxD,CACA,CAEgB,IAAM,EAAO,EAAI,KAAK,CAAC,EAAG,IAC1B,MAAO,CACH,KAAM,SACN,IAAA,EACA,KAAA,EACA,OAAQ,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,EACpD,CACA,CACA,CACA,CACI,SAAS,CAAG,CAAE,CACV,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GACxC,GAAI,EAAK,CACL,IAAI,EAAO,CAAG,CAAC,EAAE,CAAC,OAAO,CAAC,MAAO,KAC3B,EAAmB,OAAO,IAAI,CAAC,GAC/B,EAA0B,KAAK,IAAI,CAAC,IAAS,KAAK,IAAI,CAAC,GAK7D,OAJI,GAAoB,GACpB,CAAA,EAAO,EAAK,SAAS,CAAC,EAAG,EAAK,MAAM,CAAG,EAD3C,EAGA,EAAOA,EAAO,EAAM,CAAA,GACb,CACH,KAAM,WACN,IAAK,CAAG,CAAC,EAAE,CACX,KAAA,CAChB,CACA,CACA,CACI,GAAG,CAAG,CAAE,CACJ,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,GACtC,GAAI,EACA,MAAO,CACH,KAAM,KACN,IAAK,CAAG,CAAC,EAAE,AAC3B,CAEA,CACI,IAAI,CAAG,CAAE,CACL,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GACvC,GAAI,EACA,MAAO,CACH,KAAM,MACN,IAAK,CAAG,CAAC,EAAE,CACX,KAAM,CAAG,CAAC,EAAE,CACZ,OAAQ,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAG,CAAC,EAAE,CACtD,CAEA,CACI,SAAS,CAAG,CAAE,CACV,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,GAC5C,GAAI,EAAK,CACL,IAAI,EAAM,EASV,OANI,EAFA,AAAW,MAAX,CAAG,CAAC,EAAE,CAEC,UADP,CAAA,EAAOA,EAAO,CAAG,CAAC,EAAE,CAAA,EAIpB,EAAOA,EAAO,CAAG,CAAC,EAAE,EAGjB,CACH,KAAM,OACN,IAAK,CAAG,CAAC,EAAE,CACX,KAAA,EACA,KAAA,EACA,OAAQ,CACJ,CACI,KAAM,OACN,IAAK,EACL,KAAA,CACxB,EACiB,AACjB,CACA,CACA,CACI,IAAI,CAAG,CAAE,CACL,IAAI,EACJ,GAAI,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GAAM,CACvC,IAAI,EAAM,EACV,GAAI,AAAW,MAAX,CAAG,CAAC,EAAE,CAEN,EAAO,UADP,CAAA,EAAOA,EAAO,CAAG,CAAC,EAAE,CAAA,MAGnB,CAED,IAAI,EACJ,GACI,EAAc,CAAG,CAAC,EAAE,CACpB,CAAG,CAAC,EAAE,CAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAG,CAAC,EAAE,GAAC,CAAG,EAAE,EAAI,SACtD,IAAgB,CAAG,CAAC,EAAE,CAAE,AACjC,EAAOA,EAAO,CAAG,CAAC,EAAE,EAEhB,EADA,AAAW,SAAX,CAAG,CAAC,EAAE,CACC,UAAY,CAAG,CAAC,EAAE,CAGlB,CAAG,CAAC,EAAE,AAEjC,CACY,MAAO,CACH,KAAM,OACN,IAAK,CAAG,CAAC,EAAE,CACX,KAAA,EACA,KAAA,EACA,OAAQ,CACJ,CACI,KAAM,OACN,IAAK,EACL,KAAA,CACxB,EACiB,AACjB,CACA,CACA,CACI,WAAW,CAAG,CAAE,CACZ,IAAM,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GACxC,GAAI,EAAK,CACL,IAAI,EAOJ,OALI,EADA,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,CACpB,CAAG,CAAC,EAAE,CAGNA,EAAO,CAAG,CAAC,EAAE,EAEjB,CACH,KAAM,OACN,IAAK,CAAG,CAAC,EAAE,CACX,KAAA,CAChB,CACA,CACA,CACA,CClsBA,IAAM,EAAK,qEAEL,EAAS,wBACT,EAAW,EAAK,oEACjB,OAAO,CAAC,QAAS,GACjB,QAAQ,GACP,EAAa,uFAEb,EAAc,8BACd,EAAM,EAAK,mGACZ,OAAO,CAAC,QAAS,GACjB,OAAO,CAAC,QAAS,gEACjB,QAAQ,GACP,EAAO,EAAK,wCACb,OAAO,CAAC,QAAS,GACjB,QAAQ,GACP,EAAO,gWAMP,EAAW,+BACX,EAAO,EAAK,mdASP,KACN,OAAO,CAAC,UAAW,GACnB,OAAO,CAAC,MAAO,GACf,OAAO,CAAC,YAAa,4EACrB,QAAQ,GACP,EAAY,EAAK,GAClB,OAAO,CAAC,KAAM,GACd,OAAO,CAAC,UAAW,yBACnB,OAAO,CAAC,YAAa,IACrB,OAAO,CAAC,SAAU,IAClB,OAAO,CAAC,aAAc,WACtB,OAAO,CAAC,SAAU,kDAClB,OAAO,CAAC,OAAQ,0BAChB,OAAO,CAAC,OAAQ,+DAChB,OAAO,CAAC,MAAO,GACf,QAAQ,GAOP,EAAc,CAChB,WAPe,EAAK,2CACnB,OAAO,CAAC,YAAa,GACrB,QAAQ,GAMT,KA1Dc,uCA2Dd,IAAA,EACA,OA3DW,8GA4DX,QA1DY,uCA2DZ,GAAA,EACA,KAAA,EACA,SAAA,EACA,KAAA,EACA,QAnEY,mBAoEZ,UAAA,EACA,MAAO,EACP,KA5Dc,SA6DlB,EAIM,EAAW,EAAK,+JAGjB,OAAO,CAAC,KAAM,GACd,OAAO,CAAC,UAAW,yBACnB,OAAO,CAAC,aAAc,WACtB,OAAO,CAAC,OAAQ,cAChB,OAAO,CAAC,SAAU,kDAClB,OAAO,CAAC,OAAQ,0BAChB,OAAO,CAAC,OAAQ,+DAChB,OAAO,CAAC,MAAO,GACf,QAAQ,GACP,EAAW,CACb,GAAG,CAAW,CACd,MAAO,EACP,UAAW,EAAK,GACX,OAAO,CAAC,KAAM,GACd,OAAO,CAAC,UAAW,yBACnB,OAAO,CAAC,YAAa,IACrB,OAAO,CAAC,QAAS,GACjB,OAAO,CAAC,aAAc,WACtB,OAAO,CAAC,SAAU,kDAClB,OAAO,CAAC,OAAQ,0BAChB,OAAO,CAAC,OAAQ,+DAChB,OAAO,CAAC,MAAO,GACf,QAAQ,EACjB,EAIM,EAAgB,CAClB,GAAG,CAAW,CACd,KAAM,EAAK,8IAGN,OAAO,CAAC,UAAW,GACnB,OAAO,CAAC,OAAQ,qKAIhB,QAAQ,GACb,IAAK,oEACL,QAAS,yBACT,OAAQ,EACR,SAAU,mCACV,UAAW,EAAK,GACX,OAAO,CAAC,KAAM,GACd,OAAO,CAAC,UAAW,mBACnB,OAAO,CAAC,WAAY,GACpB,OAAO,CAAC,SAAU,IAClB,OAAO,CAAC,aAAc,WACtB,OAAO,CAAC,UAAW,IACnB,OAAO,CAAC,QAAS,IACjB,OAAO,CAAC,QAAS,IACjB,OAAO,CAAC,OAAQ,IAChB,QAAQ,EACjB,EAIM,EAAS,8CAET,EAAK,wBAGL,EAAe,kBACf,EAAc,EAAK,6BAA8B,KAClD,OAAO,CAAC,eAAgB,GAAc,QAAQ,GAG7C,EAAiB,EAAK,oEAAqE,KAC5F,OAAO,CAAC,SAAU,GAClB,QAAQ,GACP,EAAoB,EAAK,wQAOY,MACtC,OAAO,CAAC,SAAU,GAClB,QAAQ,GAEP,EAAoB,EAAK,uNAMY,MACtC,OAAO,CAAC,SAAU,GAClB,QAAQ,GACP,EAAiB,EAAK,cAAe,MACtC,OAAO,CAAC,SAAU,GAClB,QAAQ,GACP,EAAW,EAAK,uCACjB,OAAO,CAAC,SAAU,gCAClB,OAAO,CAAC,QAAS,gJACjB,QAAQ,GACP,EAAiB,EAAK,GAAU,OAAO,CAAC,YAAa,OAAO,QAAQ,GACpE,EAAM,EAAK,4JAMZ,OAAO,CAAC,UAAW,GACnB,OAAO,CAAC,YAAa,+EACrB,QAAQ,GACP,EAAe,sDACf,EAAO,EAAK,iDACb,OAAO,CAAC,QAAS,GACjB,OAAO,CAAC,OAAQ,wCAChB,OAAO,CAAC,QAAS,+DACjB,QAAQ,GACP,EAAU,EAAK,2BAChB,OAAO,CAAC,QAAS,GACjB,OAAO,CAAC,MAAO,GACf,QAAQ,GACP,EAAS,EAAK,yBACf,OAAO,CAAC,MAAO,GACf,QAAQ,GACP,EAAgB,EAAK,wBAAyB,KAC/C,OAAO,CAAC,UAAW,GACnB,OAAO,CAAC,SAAU,GAClB,QAAQ,GAIP,EAAe,CACjB,WAAY,EACZ,eAAA,EACA,SAAA,EACA,UAjEc,gDAkEd,GAAA,EACA,KA3Ee,sCA4Ef,IAAK,EACL,eAAA,EACA,kBAAA,EACA,kBAAA,EACA,OAAA,EACA,KAAA,EACA,OAAA,EACA,YAAA,EACA,QAAA,EACA,cAAA,EACA,IAAA,EACA,KArFe,8EAsFf,IAAK,CACT,EAIM,EAAiB,CACnB,GAAG,CAAY,CACf,KAAM,EAAK,2BACN,OAAO,CAAC,QAAS,GACjB,QAAQ,GACb,QAAS,EAAK,iCACT,OAAO,CAAC,QAAS,GACjB,QAAQ,EACjB,EAIM,EAAY,CACd,GAAG,CAAY,CACf,OAAQ,EAAK,GAAQ,OAAO,CAAC,KAAM,QAAQ,QAAQ,GACnD,IAAK,EAAK,mEAAoE,KACzE,OAAO,CAAC,QAAS,6EACjB,QAAQ,GACb,WAAY,6EACZ,IAAK,+CACL,KAAM,4NACV,EAIM,EAAe,CACjB,GAAG,CAAS,CACZ,GAAI,EAAK,GAAI,OAAO,CAAC,OAAQ,KAAK,QAAQ,GAC1C,KAAM,EAAK,EAAU,IAAI,EACpB,OAAO,CAAC,OAAQ,iBAChB,OAAO,CAAC,UAAW,KACnB,QAAQ,EACjB,EAIa,GAAQ,CACjB,OAAQ,EACR,IAAK,EACL,SAAU,CACd,EACa,GAAS,CAClB,OAAQ,EACR,IAAK,EACL,OAAQ,EACR,SAAU,CACd,CCjRO,OAAM,GACT,MAAO,AACP,CAAA,OAAQ,AACR,CAAA,KAAM,AACN,CAAA,SAAU,AACV,CAAA,WAAY,AACZ,aAAY,CAAO,CAAE,CAEjB,IAAI,CAAC,MAAM,CAAG,EAAE,CAChB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAG,OAAO,MAAM,CAAC,MAClC,IAAI,CAAC,OAAO,CAAG,GAAWmM,EAAAA,QAAS,CACnC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAI,IAAI,EACvD,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CACvC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CACrC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAG,IAAI,CAC3B,IAAI,CAAC,WAAW,CAAG,EAAE,CACrB,IAAI,CAAC,KAAK,CAAG,CACT,OAAQ,CAAA,EACR,WAAY,CAAA,EACZ,IAAK,CAAA,CACjB,EACQ,IAAM,EAAQ,CACV,MAAO,GAAM,MAAM,CACnB,OAAQ,GAAO,MAAM,AACjC,CACY,CAAA,IAAI,CAAC,OAAO,CAAC,QAAQ,EACrB,EAAM,KAAK,CAAG,GAAM,QAAQ,CAC5B,EAAM,MAAM,CAAG,GAAO,QAAQ,EAEzB,IAAI,CAAC,OAAO,CAAC,GAAG,GACrB,EAAM,KAAK,CAAG,GAAM,GAAG,CACnB,IAAI,CAAC,OAAO,CAAC,MAAM,CACnB,EAAM,MAAM,CAAG,GAAO,MAAM,CAG5B,EAAM,MAAM,CAAG,GAAO,GAAG,EAGjC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAG,CAC/B,CAII,WAAW,OAAQ,CACf,MAAO,CACH,MAAA,GACA,OAAA,EACZ,CACA,CAII,OAAO,IAAI,CAAG,CAAE,CAAO,CAAE,CAErB,OAAO,AADO,IAAI,GAAO,GACZ,GAAG,CAAC,EACzB,CAII,OAAO,UAAU,CAAG,CAAE,CAAO,CAAE,CAE3B,OAAO,AADO,IAAI,GAAO,GACZ,YAAY,CAAC,EAClC,CAII,IAAI,CAAG,CAAE,KAID,EACJ,IAJA,EAAM,EACD,OAAO,CAAC,WAAY,MACzB,IAAI,CAAC,WAAW,CAAC,EAAK,IAAI,CAAC,MAAM,EAE1B,EAAO,IAAI,CAAC,WAAW,CAAC,KAAK,IAChC,IAAI,CAAC,YAAY,CAAC,EAAK,GAAG,CAAE,EAAK,MAAM,EAE3C,OAAO,IAAI,CAAC,MAAM,AAC1B,CACI,YAAY,CAAG,CAAE,EAAS,EAAE,CAAE,KAStB,EACA,EACA,EACA,EACJ,IAXI,EADA,IAAI,CAAC,OAAO,CAAC,QAAQ,CACf,EAAI,OAAO,CAAC,MAAO,QAAQ,OAAO,CAAC,SAAU,IAG7C,EAAI,OAAO,CAAC,eAAgB,CAAC,EAAG,EAAS,IACpC,EAAU,OAAO,MAAM,CAAC,EAAK,MAAM,GAO3C,GACH,IAAI,CAAA,IAAI,CAAC,OAAO,CAAC,UAAU,EACpB,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,EAC7B,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,AAAC,GACnC,EAAI,CAAA,EAAQ,EAAa,IAAI,CAAC,CAAE,MAAO,IAAI,AAAA,EAAI,EAAK,EAAA,IAChD,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EACpC,EAAO,IAAI,CAAC,GACL,CAAA,GAG/B,GAIY,GAAI,EAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAM,CACnC,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EAChC,AAAqB,IAArB,EAAM,GAAG,CAAC,MAAM,EAAU,EAAO,MAAM,CAAG,EAG1C,CAAM,CAAC,EAAO,MAAM,CAAG,EAAE,CAAC,GAAG,EAAI,KAGjC,EAAO,IAAI,CAAC,GAEhB,QAChB,CAEY,GAAI,EAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAM,CAClC,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EAGhC,AAFJ,CAAA,EAAY,CAAM,CAAC,EAAO,MAAM,CAAG,EAAE,AAAF,GAEjB,CAAA,AAAmB,cAAnB,EAAU,IAAI,EAAoB,AAAmB,SAAnB,EAAU,IAAI,AAAK,GACnE,EAAU,GAAG,EAAI,KAAO,EAAM,GAAG,CACjC,EAAU,IAAI,EAAI,KAAO,EAAM,IAAI,CACnC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAG,EAAE,CAAC,GAAG,CAAG,EAAU,IAAI,EAGlE,EAAO,IAAI,CAAC,GAEhB,QAChB,CAEY,GAAI,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAA,GAM9B,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAA,GAM/B,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,EAAA,GAM1B,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,EAAA,GAMlC,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAA,GAM5B,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAA,EA9BQ,CACpC,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EACpC,EAAO,IAAI,CAAC,GACZ,QAChB,CAgCY,GAAI,EAAQ,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAM,CACjC,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EAEhC,AADJ,CAAA,EAAY,CAAM,CAAC,EAAO,MAAM,CAAG,EAAE,AAAF,GACjB,CAAA,AAAmB,cAAnB,EAAU,IAAI,EAAoB,AAAmB,SAAnB,EAAU,IAAI,AAAK,GACnE,EAAU,GAAG,EAAI,KAAO,EAAM,GAAG,CACjC,EAAU,IAAI,EAAI,KAAO,EAAM,GAAG,CAClC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAG,EAAE,CAAC,GAAG,CAAG,EAAU,IAAI,EAE5D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAM,GAAG,CAAC,EAClC,CAAA,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAM,GAAG,CAAC,CAAG,CAC3B,KAAM,EAAM,IAAI,CAChB,MAAO,EAAM,KAAK,AAC1C,CAAA,EAEgB,QAChB,CAEY,GAAI,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAA,GAM7B,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAA,EANG,CACnC,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EACpC,EAAO,IAAI,CAAC,GACZ,QAChB,CAUY,GADA,EAAS,EACL,IAAI,CAAC,OAAO,CAAC,UAAU,EAAI,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAE,CAC/D,IAEI,EAFA,EAAa,IACX,EAAU,EAAI,KAAK,CAAC,GAE1B,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,OAAO,CAAC,AAAC,IAEf,UAArB,MADJ,CAAA,EAAY,EAAc,IAAI,CAAC,CAAE,MAAO,IAAI,AAAA,EAAI,EAAJ,GACP,GAAa,GAC9C,CAAA,EAAa,KAAK,GAAG,CAAC,EAAY,EADtC,CAGpB,GACoB,EAAa,KAAY,GAAc,GACvC,CAAA,EAAS,EAAI,SAAS,CAAC,EAAG,EAAa,EAD3C,CAGhB,CACY,GAAI,IAAI,CAAC,KAAK,CAAC,GAAG,EAAK,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,EAAA,EAAU,CAC9D,EAAY,CAAM,CAAC,EAAO,MAAM,CAAG,EAAE,CACjC,GAAwB,AAAmB,cAAnB,EAAU,IAAI,EACtC,EAAU,GAAG,EAAI,KAAO,EAAM,GAAG,CACjC,EAAU,IAAI,EAAI,KAAO,EAAM,IAAI,CACnC,IAAI,CAAC,WAAW,CAAC,GAAG,GACpB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAG,EAAE,CAAC,GAAG,CAAG,EAAU,IAAI,EAGlE,EAAO,IAAI,CAAC,GAEhB,EAAwB,EAAO,MAAM,GAAK,EAAI,MAAM,CACpD,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EACpC,QAChB,CAEY,GAAI,EAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAM,CAClC,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EAEhC,AADJ,CAAA,EAAY,CAAM,CAAC,EAAO,MAAM,CAAG,EAAE,AAAF,GAClB,AAAmB,SAAnB,EAAU,IAAI,EAC3B,EAAU,GAAG,EAAI,KAAO,EAAM,GAAG,CACjC,EAAU,IAAI,EAAI,KAAO,EAAM,IAAI,CACnC,IAAI,CAAC,WAAW,CAAC,GAAG,GACpB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAG,EAAE,CAAC,GAAG,CAAG,EAAU,IAAI,EAGlE,EAAO,IAAI,CAAC,GAEhB,QAChB,CACY,GAAI,EAAK,CACL,IAAM,EAAS,0BAA4B,EAAI,UAAU,CAAC,GAC1D,GAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAE,CACrB,QAAQ,KAAK,CAAC,GACd,KACpB,CAEoB,MAAM,AAAI,MAAM,EAEpC,EAGQ,OADA,IAAI,CAAC,KAAK,CAAC,GAAG,CAAG,CAAA,EACV,CACf,CACI,OAAO,CAAG,CAAE,EAAS,EAAE,CAAE,CAErB,OADA,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAE,IAAA,EAAK,OAAA,CAAM,GAC5B,CACf,CAII,aAAa,CAAG,CAAE,EAAS,EAAE,CAAE,KACvB,EAAO,EAAW,EAGlB,EACA,EAAc,EAFlB,IAAI,EAAY,EAIhB,GAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAE,CACnB,IAAM,EAAQ,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,EAC3C,GAAI,EAAM,MAAM,CAAG,EACf,KAAQ,AAAsE,MAAtE,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,EAAA,GACvD,EAAM,QAAQ,CAAC,CAAK,CAAC,EAAE,CAAC,KAAK,CAAC,CAAK,CAAC,EAAE,CAAC,WAAW,CAAC,KAAO,EAAG,MAC7D,CAAA,EAAY,EAAU,KAAK,CAAC,EAAG,EAAM,KAAK,EAAI,IAAM,IAAI,MAAM,CAAC,CAAK,CAAC,EAAE,CAAC,MAAM,CAAG,GAAK,IAAM,EAAU,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC,SAAS,CAAA,CAIvL,CAEQ,KAAO,AAAmE,MAAlE,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,EAAA,GACvD,EAAY,EAAU,KAAK,CAAC,EAAG,EAAM,KAAK,EAAI,IAAM,IAAI,MAAM,CAAC,CAAK,CAAC,EAAE,CAAC,MAAM,CAAG,GAAK,IAAM,EAAU,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,SAAS,EAG/J,KAAQ,AAAuE,MAAvE,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,EAAA,GAC5D,EAAY,EAAU,KAAK,CAAC,EAAG,EAAM,KAAK,EAAI,KAAO,EAAU,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAC,SAAS,EAE7H,KAAO,GAMH,GALK,GACD,CAAA,EAAW,EADf,EAGA,EAAe,CAAA,GAEX,CAAA,IAAI,CAAC,OAAO,CAAC,UAAU,EACpB,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,EAC9B,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,AAAC,GACpC,EAAI,CAAA,EAAQ,EAAa,IAAI,CAAC,CAAE,MAAO,IAAI,AAAA,EAAI,EAAK,EAAA,IAChD,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EACpC,EAAO,IAAI,CAAC,GACL,CAAA,GAG/B,GAIY,GAAI,EAAQ,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAM,CACpC,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EACpC,EAAO,IAAI,CAAC,GACZ,QAChB,CAEY,GAAI,EAAQ,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAM,CACjC,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EAEhC,AADJ,CAAA,EAAY,CAAM,CAAC,EAAO,MAAM,CAAG,EAAE,AAAF,GAClB,AAAe,SAAf,EAAM,IAAI,EAAe,AAAmB,SAAnB,EAAU,IAAI,EACpD,EAAU,GAAG,EAAI,EAAM,GAAG,CAC1B,EAAU,IAAI,EAAI,EAAM,IAAI,EAG5B,EAAO,IAAI,CAAC,GAEhB,QAChB,CAEY,GAAI,EAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAM,CAClC,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EACpC,EAAO,IAAI,CAAC,GACZ,QAChB,CAEY,GAAI,EAAQ,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAK,IAAI,CAAC,MAAM,CAAC,KAAK,EAAG,CACxD,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EAEhC,AADJ,CAAA,EAAY,CAAM,CAAC,EAAO,MAAM,CAAG,EAAE,AAAF,GAClB,AAAe,SAAf,EAAM,IAAI,EAAe,AAAmB,SAAnB,EAAU,IAAI,EACpD,EAAU,GAAG,EAAI,EAAM,GAAG,CAC1B,EAAU,IAAI,EAAI,EAAM,IAAI,EAG5B,EAAO,IAAI,CAAC,GAEhB,QAChB,CAEY,GAAI,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAK,EAAW,EAAA,GAMhD,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAA,GAMhC,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,EAAA,GAM1B,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAA,GAM3B,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAA,GAMhC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAK,CAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAA,EA9BS,CAC3D,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EACpC,EAAO,IAAI,CAAC,GACZ,QAChB,CAkCY,GADA,EAAS,EACL,IAAI,CAAC,OAAO,CAAC,UAAU,EAAI,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,WAAW,CAAE,CAChE,IAEI,EAFA,EAAa,IACX,EAAU,EAAI,KAAK,CAAC,GAE1B,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,WAAW,CAAC,OAAO,CAAC,AAAC,IAEhB,UAArB,MADJ,CAAA,EAAY,EAAc,IAAI,CAAC,CAAE,MAAO,IAAI,AAAA,EAAI,EAAJ,GACP,GAAa,GAC9C,CAAA,EAAa,KAAK,GAAG,CAAC,EAAY,EADtC,CAGpB,GACoB,EAAa,KAAY,GAAc,GACvC,CAAA,EAAS,EAAI,SAAS,CAAC,EAAG,EAAa,EAD3C,CAGhB,CACY,GAAI,EAAQ,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,GAAS,CAC3C,EAAM,EAAI,SAAS,CAAC,EAAM,GAAG,CAAC,MAAM,EACR,MAAxB,EAAM,GAAG,CAAC,KAAK,CAAC,KAChB,CAAA,EAAW,EAAM,GAAG,CAAC,KAAK,CAAC,GAD/B,EAGA,EAAe,CAAA,EAEX,AADJ,CAAA,EAAY,CAAM,CAAC,EAAO,MAAM,CAAG,EAAE,AAAF,GAClB,AAAmB,SAAnB,EAAU,IAAI,EAC3B,EAAU,GAAG,EAAI,EAAM,GAAG,CAC1B,EAAU,IAAI,EAAI,EAAM,IAAI,EAG5B,EAAO,IAAI,CAAC,GAEhB,QAChB,CACY,GAAI,EAAK,CACL,IAAM,EAAS,0BAA4B,EAAI,UAAU,CAAC,GAC1D,GAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAE,CACrB,QAAQ,KAAK,CAAC,GACd,KACpB,CAEoB,MAAM,AAAI,MAAM,EAEpC,EAEQ,OAAO,CACf,CACA,CC3aO,MAAM,GACT,OAAQ,AACR,aAAY,CAAO,CAAE,CACjB,IAAI,CAAC,OAAO,CAAG,GAAWA,EAAAA,QAAS,AAC3C,CACI,KAAK,CAAI,CAAE,CAAU,CAAE,CAAO,CAAE,CAC5B,IAAM,EAAQ,AAAA,CAAA,GAAc,EAAA,EAAI,KAAK,CAAC,SAAO,CAAG,EAAE,OAElD,CADA,EAAO,EAAK,OAAO,CAAC,MAAO,IAAM,KAC5B,GAKE,8BACDnM,EAAO,GACP,KACC,CAAA,EAAU,EAAOA,EAAO,EAAM,CAAA,EAAA,EAC/B,kBARK,cACA,CAAA,EAAU,EAAOA,EAAO,EAAM,CAAA,EAAA,EAC/B,iBAOlB,CACI,WAAW,CAAK,CAAE,CACd,MAAO,CAAC;AAAc,EAAE,EAAM;AAAe,CAAC,AACtD,CACI,KAAK,CAAI,CAAE,CAAK,CAAE,CACd,OAAO,CACf,CACI,QAAQ,CAAI,CAAE,CAAK,CAAE,CAAG,CAAE,CAEtB,MAAO,CAAC,EAAE,EAAE,EAAM,CAAC,EAAE,EAAK,GAAG,EAAE,EAAM;AAAG,CAAC,AACjD,CACI,IAAK,CACD,MAAO,QACf,CACI,KAAK,CAAI,CAAE,CAAO,CAAE,CAAK,CAAE,CACvB,IAAM,EAAO,EAAU,KAAO,KAE9B,MAAO,IAAM,EADI,CAAA,GAAY,AAAU,IAAV,EAAgB,WAAa,EAAQ,IAAO,EAAzE,EAC+B,MAAQ,EAAO,KAAO,EAAO,KACpE,CACI,SAAS,CAAI,CAAE,CAAI,CAAE,CAAO,CAAE,CAC1B,MAAO,CAAC,IAAI,EAAE,EAAK;AAAO,CAAC,AACnC,CACI,SAAS,CAAO,CAAE,CACd,MAAO,UACA,CAAA,EAAU,cAAgB,EAAA,EAC3B,8BACd,CACI,UAAU,CAAI,CAAE,CACZ,MAAO,CAAC,GAAG,EAAE,EAAK;AAAM,CAAC,AACjC,CACI,MAAM,CAAM,CAAE,CAAI,CAAE,CAGhB,OAFI,GACA,CAAA,EAAO,CAAC,OAAO,EAAE,EAAK,QAAQ,CAAC,AAAD,EAC3B,qBAED,EACA,aACA,EACA,YACd,CACI,SAAS,CAAO,CAAE,CACd,MAAO,CAAC;AAAM,EAAE,EAAQ;AAAO,CAAC,AACxC,CACI,UAAU,CAAO,CAAE,CAAK,CAAE,CACtB,IAAM,EAAO,EAAM,MAAM,CAAG,KAAO,KAInC,MAAO,AAHK,CAAA,EAAM,KAAK,CACjB,CAAC,CAAC,EAAE,EAAK,QAAQ,EAAE,EAAM,KAAK,CAAC,EAAE,CAAC,CAClC,CAAC,CAAC,EAAE,EAAK,CAAC,CAAC,AAAD,EACH,EAAU,CAAC,EAAE,EAAE,EAAK;AAAG,CAAC,AAC7C,CAII,OAAO,CAAI,CAAE,CACT,MAAO,CAAC,QAAQ,EAAE,EAAK,SAAS,CAAC,AACzC,CACI,GAAG,CAAI,CAAE,CACL,MAAO,CAAC,IAAI,EAAE,EAAK,KAAK,CAAC,AACjC,CACI,SAAS,CAAI,CAAE,CACX,MAAO,CAAC,MAAM,EAAE,EAAK,OAAO,CAAC,AACrC,CACI,IAAK,CACD,MAAO,MACf,CACI,IAAI,CAAI,CAAE,CACN,MAAO,CAAC,KAAK,EAAE,EAAK,MAAM,CAAC,AACnC,CACI,KAAK,CAAI,CAAE,CAAK,CAAE,CAAI,CAAE,CACpB,IAAM,EAAY,EAAS,GAC3B,GAAI,AAAc,OAAd,EACA,OAAO,EAGX,IAAI,EAAM,YADV,CAAA,EAAO,CAAP,EAC+B,IAK/B,OAJI,GACA,CAAA,GAAO,WAAa,EAAQ,GADhC,EAGA,GAAO,IAAM,EAAO,MAE5B,CACI,MAAM,CAAI,CAAE,CAAK,CAAE,CAAI,CAAE,CACrB,IAAM,EAAY,EAAS,GAC3B,GAAI,AAAc,OAAd,EACA,OAAO,EAEX,EAAO,EACP,IAAI,EAAM,CAAC,UAAU,EAAE,EAAK,OAAO,EAAE,EAAK,CAAC,CAAC,CAK5C,OAJI,GACA,CAAA,GAAO,CAAC,QAAQ,EAAE,EAAM,CAAC,CAAC,AAAD,EAE7B,GAAO,GAEf,CACI,KAAK,CAAI,CAAE,CACP,OAAO,CACf,CACA,CCpHO,MAAM,GAET,OAAO,CAAI,CAAE,CACT,OAAO,CACf,CACI,GAAG,CAAI,CAAE,CACL,OAAO,CACf,CACI,SAAS,CAAI,CAAE,CACX,OAAO,CACf,CACI,IAAI,CAAI,CAAE,CACN,OAAO,CACf,CACI,KAAK,CAAI,CAAE,CACP,OAAO,CACf,CACI,KAAK,CAAI,CAAE,CACP,OAAO,CACf,CACI,KAAK,CAAI,CAAE,CAAK,CAAE,CAAI,CAAE,CACpB,MAAO,GAAK,CACpB,CACI,MAAM,CAAI,CAAE,CAAK,CAAE,CAAI,CAAE,CACrB,MAAO,GAAK,CACpB,CACI,IAAK,CACD,MAAO,EACf,CACA,CC1BO,MAAM,GACT,OAAQ,AACR,CAAA,QAAS,AACT,CAAA,YAAa,AACb,aAAY,CAAO,CAAE,CACjB,IAAI,CAAC,OAAO,CAAG,GAAWmM,EAAAA,QAAS,CACnC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAI,IAAI,GACrD,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CACrC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CACpC,IAAI,CAAC,YAAY,CAAG,IAAI,EAChC,CAII,OAAO,MAAM,CAAM,CAAE,CAAO,CAAE,CAE1B,OAAO,AADQ,IAAI,GAAQ,GACb,KAAK,CAAC,EAC5B,CAII,OAAO,YAAY,CAAM,CAAE,CAAO,CAAE,CAEhC,OAAO,AADQ,IAAI,GAAQ,GACb,WAAW,CAAC,EAClC,CAII,MAAM,CAAM,CAAE,EAAM,CAAA,CAAI,CAAE,CACtB,IAAI,EAAM,GACV,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,IAAK,CACpC,IAAM,EAAQ,CAAM,CAAC,EAAE,CAEvB,GAAI,IAAI,CAAC,OAAO,CAAC,UAAU,EAAI,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,SAAS,EAAI,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,SAAS,CAAC,EAAM,IAAI,CAAC,CAAE,CAE/G,IAAM,EAAM,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,SAAS,CAAC,AADzB,EACsC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAE,OAAQ,IAAI,AAAA,EAD/D,GAErB,GAAI,AAAQ,CAAA,IAAR,GAAiB,CAAC,CAAC,QAAS,KAAM,UAAW,OAAQ,QAAS,aAAc,OAAQ,OAAQ,YAAa,OAAO,CAAC,QAAQ,CAAC,AAFzG,EAEsH,IAAI,EAAG,CAC9I,GAAO,GAAO,GACd,QACpB,CACA,CACY,OAAQ,EAAM,IAAI,EACd,IAAK,QACD,QAEJ,KAAK,KACD,GAAO,IAAI,CAAC,QAAQ,CAAC,EAAE,GACvB,QAEJ,KAAK,UAED,GAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,AADzB,EACsC,MAAM,EAAG,AAD/C,EAC4D,KAAK,CN3B/F,AM2B0G,IAAI,CAAC,WAAW,CAAC,AAD7F,EAC0G,MAAM,CAAE,IAAI,CAAC,YAAY,EN3B5J,OAAO,CAAC,EAAc,CAAC,EAAG,IAElC,AAAI,AAAM,UADV,CAAA,EAAI,EAAE,WAAW,EAAjB,EAEW,IACP,AAAgB,MAAhB,EAAE,MAAM,CAAC,GACF,AAAgB,MAAhB,EAAE,MAAM,CAAC,GACV,OAAO,YAAY,CAAC,SAAS,EAAE,SAAS,CAAC,GAAI,KAC7C,OAAO,YAAY,CAAC,CAAC,EAAE,SAAS,CAAC,IAEpC,KMmBK,QAEJ,KAAK,OAED,GAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,AADR,EACkB,IAAI,CAAE,AADxB,EACkC,IAAI,CAAE,CAAC,CAAC,AAD1C,EACoD,OAAO,EAC7E,QAEJ,KAAK,QAAS,CAEV,IAAI,EAAS,GAET,EAAO,GACX,IAAK,IAAI,EAAI,EAAG,EAAI,AAJD,EAIY,MAAM,CAAC,MAAM,CAAE,IAC1C,GAAQ,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,AALlC,EAK6C,MAAM,CAAC,EAAE,CAAC,MAAM,EAAG,CAAE,OAAQ,CAAA,EAAM,MAAO,AALvF,EAKkG,KAAK,CAAC,EAAE,AAAA,GAE7H,GAAU,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GACjC,IAAI,EAAO,GACX,IAAK,IAAI,EAAI,EAAG,EAAI,AATD,EASY,IAAI,CAAC,MAAM,CAAE,IAAK,CAC7C,IAAM,EAAM,AAVG,EAUQ,IAAI,CAAC,EAAE,CAC9B,EAAO,GACP,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,IAC5B,GAAQ,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAG,CAAC,EAAE,CAAC,MAAM,EAAG,CAAE,OAAQ,CAAA,EAAO,MAAO,AAb9E,EAayF,KAAK,CAAC,EAAE,AAAA,GAEhH,GAAQ,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EACvD,CACoB,GAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAQ,GACnC,QACpB,CACgB,IAAK,aAAc,CAEf,IAAM,EAAO,IAAI,CAAC,KAAK,CAAC,AADA,EACgB,MAAM,EAC9C,GAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,GAChC,QACpB,CACgB,IAAK,OAAQ,CAET,IAAM,EAAU,AADE,EACQ,OAAO,CAC3B,EAAQ,AAFI,EAEM,KAAK,CACvB,EAAQ,AAHI,EAGM,KAAK,CACzB,EAAO,GACX,IAAK,IAAI,EAAI,EAAG,EAAI,AALF,EAKY,KAAK,CAAC,MAAM,CAAE,IAAK,CAC7C,IAAM,EAAO,AANC,EAMS,KAAK,CAAC,EAAE,CACzB,EAAU,EAAK,OAAO,CACtB,EAAO,EAAK,IAAI,CAClB,EAAW,GACf,GAAI,EAAK,IAAI,CAAE,CACX,IAAM,EAAW,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,GACtC,EACI,EAAK,MAAM,CAAC,MAAM,CAAG,GAAK,AAAwB,cAAxB,EAAK,MAAM,CAAC,EAAE,CAAC,IAAI,EAC7C,EAAK,MAAM,CAAC,EAAE,CAAC,IAAI,CAAG,EAAW,IAAM,EAAK,MAAM,CAAC,EAAE,CAAC,IAAI,CACtD,EAAK,MAAM,CAAC,EAAE,CAAC,MAAM,EAAI,EAAK,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAG,GAAK,AAAkC,SAAlC,EAAK,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,EAC1F,CAAA,EAAK,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAG,EAAW,IAAM,EAAK,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,AAAJ,GAI9E,EAAK,MAAM,CAAC,OAAO,CAAC,CAChB,KAAM,OACN,KAAM,EAAW,GACzD,GAIgC,GAAY,EAAW,GAEvD,CACwB,GAAY,IAAI,CAAC,KAAK,CAAC,EAAK,MAAM,CAAE,GACpC,GAAQ,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAU,EAAM,CAAC,CAAC,EACzE,CACoB,GAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAM,EAAS,GACzC,QACpB,CACgB,IAAK,OAED,GAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,AADR,EACkB,IAAI,CAAE,AADxB,EACkC,KAAK,EACzD,QAEJ,KAAK,YAED,GAAO,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,AADzB,EACwC,MAAM,GACrE,QAEJ,KAAK,OAAQ,CACT,IAAI,EAAY,EACZ,EAAO,EAAU,MAAM,CAAG,IAAI,CAAC,WAAW,CAAC,EAAU,MAAM,EAAI,EAAU,IAAI,CACjF,KAAO,EAAI,EAAI,EAAO,MAAM,EAAI,AAAuB,SAAvB,CAAM,CAAC,EAAI,EAAE,CAAC,IAAI,EAE9C,GAAQ,KAAQ,CAAA,AADhB,CAAA,EAAY,CAAM,CAAC,EAAE,EAAE,AAAF,EACK,MAAM,CAAG,IAAI,CAAC,WAAW,CAAC,EAAU,MAAM,EAAI,EAAU,IAAI,AAAJ,EAEtF,GAAO,EAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,GAAQ,EAC7C,QACpB,CACgB,QAAS,CACL,IAAM,EAAS,eAAiB,EAAM,IAAI,CAAG,wBAC7C,GAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAEnB,OADA,QAAQ,KAAK,CAAC,GACP,EAGP,OAAM,AAAI,MAAM,EAExC,CACA,CACA,CACQ,OAAO,CACf,CAII,YAAY,CAAM,CAAE,CAAQ,CAAE,CAC1B,EAAW,GAAY,IAAI,CAAC,QAAQ,CACpC,IAAI,EAAM,GACV,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,IAAK,CACpC,IAAM,EAAQ,CAAM,CAAC,EAAE,CAEvB,GAAI,IAAI,CAAC,OAAO,CAAC,UAAU,EAAI,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,SAAS,EAAI,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,SAAS,CAAC,EAAM,IAAI,CAAC,CAAE,CAC/G,IAAM,EAAM,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,SAAS,CAAC,EAAM,IAAI,CAAC,CAAC,IAAI,CAAC,CAAE,OAAQ,IAAI,AAAA,EAAI,GACjF,GAAI,AAAQ,CAAA,IAAR,GAAiB,CAAC,CAAC,SAAU,OAAQ,OAAQ,QAAS,SAAU,KAAM,WAAY,KAAM,MAAO,OAAO,CAAC,QAAQ,CAAC,EAAM,IAAI,EAAG,CAC7H,GAAO,GAAO,GACd,QACpB,CACA,CACY,OAAQ,EAAM,IAAI,EACd,IAAK,SA4CL,IAAK,OA1CD,GAAO,EAAS,IAAI,CAAC,AADD,EACa,IAAI,EACrC,KAEJ,KAAK,OAED,GAAO,EAAS,IAAI,CAAC,AADJ,EACa,IAAI,EAClC,KAEJ,KAAK,OAED,GAAO,EAAS,IAAI,CAAC,AADH,EACa,IAAI,CAAE,AADnB,EAC6B,KAAK,CAAE,IAAI,CAAC,WAAW,CAAC,AADrD,EAC+D,MAAM,CAAE,IACzF,KAEJ,KAAK,QAED,GAAO,EAAS,KAAK,CAAC,AADH,EACc,IAAI,CAAE,AADpB,EAC+B,KAAK,CAAE,AADtC,EACiD,IAAI,EACxE,KAEJ,KAAK,SAED,GAAO,EAAS,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,AADpB,EACgC,MAAM,CAAE,IAC5D,KAEJ,KAAK,KAED,GAAO,EAAS,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,AADpB,EAC4B,MAAM,CAAE,IACpD,KAEJ,KAAK,WAED,GAAO,EAAS,QAAQ,CAAC,AADH,EACiB,IAAI,EAC3C,KAEJ,KAAK,KACD,GAAO,EAAS,EAAE,GAClB,KAEJ,KAAK,MAED,GAAO,EAAS,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,AADpB,EAC6B,MAAM,CAAE,IACtD,KAOJ,SAAS,CACL,IAAM,EAAS,eAAiB,EAAM,IAAI,CAAG,wBAC7C,GAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAEnB,OADA,QAAQ,KAAK,CAAC,GACP,EAGP,OAAM,AAAI,MAAM,EAExC,CACA,CACA,CACQ,OAAO,CACf,CACA,CCnPO,MAAM,GACT,OAAQ,AACR,aAAY,CAAO,CAAE,CACjB,IAAI,CAAC,OAAO,CAAG,GAAWA,EAAAA,QAAS,AAC3C,CACI,OAAO,iBAAmB,IAAI,IAAI,CAC9B,aACA,cACH,CAAE,AAIH,CAAA,WAAW,CAAQ,CAAE,CACjB,OAAO,CACf,CAII,YAAY,CAAI,CAAE,CACd,OAAO,CACf,CACA,CCdO,MAAM,GACT,SAAW,GAAe,AAC1B,CAAA,QAAU,IAAI,CAAC,UAAU,AAAC,AAC1B,CAAA,MAAQ,IAAI,CAAC,CAAA,CAAc,CAAC,GAAO,GAAG,CAAE,GAAQ,KAAK,CAAE,AACvD,CAAA,YAAc,IAAI,CAAC,CAAA,CAAc,CAAC,GAAO,SAAS,CAAE,GAAQ,WAAW,CAAE,AACzE,CAAA,OAAS,EAAQ,AACjB,CAAA,SAAW,EAAU,AACrB,CAAA,aAAe,EAAc,AAC7B,CAAA,MAAQ,EAAO,AACf,CAAA,UAAY,CAAW,AACvB,CAAA,MAAQ,EAAO,AACf,aAAY,GAAG,CAAI,CAAE,CACjB,IAAI,CAAC,GAAG,IAAI,EACpB,CAII,WAAW,CAAM,CAAE,CAAQ,CAAE,CACzB,IAAI,EAAS,EAAE,CACf,IAAK,IAAM,KAAS,EAEhB,OADA,EAAS,EAAO,MAAM,CAAC,EAAS,IAAI,CAAC,IAAI,CAAE,IACnC,EAAM,IAAI,EACd,IAAK,QAED,IAAK,IAAM,KAAQ,AADA,EACW,MAAM,CAChC,EAAS,EAAO,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAK,MAAM,CAAE,IAExD,IAAK,IAAM,KAAO,AAJC,EAIU,IAAI,CAC7B,IAAK,IAAM,KAAQ,EACf,EAAS,EAAO,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAK,MAAM,CAAE,IAG5D,KAEJ,KAAK,OAED,EAAS,EAAO,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,AADrB,EAC+B,KAAK,CAAE,IACxD,KAEJ,SAAS,CACL,IAAM,EAAe,CACjB,CAAA,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,aAAW,CAAG,EAAa,IAAI,CAAC,CAC1D,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,WAAW,CAAC,EAAa,IAAI,CAAC,CAAC,OAAO,CAAC,AAAC,IAC7D,EAAS,EAAO,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAY,CAAC,EAAY,CAAE,GAC9F,GAE6B,EAAa,MAAM,EACxB,CAAA,EAAS,EAAO,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAa,MAAM,CAAE,GAD3D,CAGzB,CACA,CAEQ,OAAO,CACf,CACI,IAAI,GAAG,CAAI,CAAE,CACT,IAAM,EAAa,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAI,CAAE,UAAW,CAAA,EAAI,YAAa,CAAA,CAAE,EA0J/E,OAzJA,EAAK,OAAO,CAAC,AAAC,IAEV,IAAM,EAAO,CAAE,GAAG,CAAI,AAAA,EA8DtB,GA5DA,EAAK,KAAK,CAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAI,EAAK,KAAK,EAAI,CAAA,EAE9C,EAAK,UAAU,GACf,EAAK,UAAU,CAAC,OAAO,CAAC,AAAC,IACrB,GAAI,CAAC,EAAI,IAAI,CACT,MAAM,AAAI,MAAM,2BAEpB,GAAI,aAAc,EAAK,CACnB,IAAM,EAAe,EAAW,SAAS,CAAC,EAAI,IAAI,CAAC,CAC/C,EAEA,EAAW,SAAS,CAAC,EAAI,IAAI,CAAC,CAAG,SAAU,GAAG,CAAI,EAC9C,IAAI,EAAM,EAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,GAInC,MAHY,CAAA,IAAR,GACA,CAAA,EAAM,EAAa,KAAK,CAAC,IAAI,CAAE,EADnC,EAGO,CACvC,EAG4B,EAAW,SAAS,CAAC,EAAI,IAAI,CAAC,CAAG,EAAI,QAAQ,AAEzE,CACoB,GAAI,cAAe,EAAK,CACpB,GAAI,CAAC,EAAI,KAAK,EAAK,AAAc,UAAd,EAAI,KAAK,EAAgB,AAAc,WAAd,EAAI,KAAK,CACjD,MAAM,AAAI,MAAM,+CAEpB,IAAM,EAAW,CAAU,CAAC,EAAI,KAAK,CAAC,CAClC,EACA,EAAS,OAAO,CAAC,EAAI,SAAS,EAG9B,CAAU,CAAC,EAAI,KAAK,CAAC,CAAG,CAAC,EAAI,SAAS,CAAC,CAEvC,EAAI,KAAK,GACL,AAAc,UAAd,EAAI,KAAK,CACL,EAAW,UAAU,CACrB,EAAW,UAAU,CAAC,IAAI,CAAC,EAAI,KAAK,EAGpC,EAAW,UAAU,CAAG,CAAC,EAAI,KAAK,CAAC,CAGpB,WAAd,EAAI,KAAK,GACV,EAAW,WAAW,CACtB,EAAW,WAAW,CAAC,IAAI,CAAC,EAAI,KAAK,EAGrC,EAAW,WAAW,CAAG,CAAC,EAAI,KAAK,CAAC,EAIxE,CACwB,gBAAiB,GAAO,EAAI,WAAW,EACvC,CAAA,EAAW,WAAW,CAAC,EAAI,IAAI,CAAC,CAAG,EAAI,WAAW,AAAX,CAE/D,GACgB,EAAK,UAAU,CAAG,GAGlB,EAAK,QAAQ,CAAE,CACf,IAAM,EAAW,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAI,IAAI,GAAU,IAAI,CAAC,QAAQ,EACtE,IAAK,IAAM,KAAQ,EAAK,QAAQ,CAAE,CAC9B,GAAI,CAAE,CAAA,KAAQ,CAAA,GAAa,AAAS,YAAT,EACvB,MAAM,AAAI,MAAM,CAAC,UAAU,EAAE,EAAK,gBAAgB,CAAC,EAGvD,IAAM,EAAe,EAAK,QAAQ,CADb,EAC2B,CAC1C,EAAe,CAAQ,CAFR,EAEsB,AAE3C,CAAA,CAAQ,CAJa,EAIC,CAAG,CAAC,GAAG,KACzB,IAAI,EAAM,EAAa,KAAK,CAAC,EAAU,GAIvC,MAHY,CAAA,IAAR,GACA,CAAA,EAAM,EAAa,KAAK,CAAC,EAAU,EADvC,EAGO,GAAO,EACtC,CACA,CACgB,EAAK,QAAQ,CAAG,CAChC,CACY,GAAI,EAAK,SAAS,CAAE,CAChB,IAAM,EAAY,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAI,IAAI,EAAW,IAAI,CAAC,QAAQ,EACzE,IAAK,IAAM,KAAQ,EAAK,SAAS,CAAE,CAC/B,GAAI,CAAE,CAAA,KAAQ,CAAA,GAAc,CAAC,UAAW,QAAS,QAAQ,CAAC,QAAQ,CAAC,GAC/D,MAAM,AAAI,MAAM,CAAC,WAAW,EAAE,EAAK,gBAAgB,CAAC,EAGxD,IAAM,EAAgB,EAAK,SAAS,CADd,EAC6B,CAC7C,EAAgB,CAAS,CAFT,EAEwB,AAG9C,CAAA,CAAS,CALa,EAKE,CAAG,CAAC,GAAG,KAC3B,IAAI,EAAM,EAAc,KAAK,CAAC,EAAW,GAIzC,MAHY,CAAA,IAAR,GACA,CAAA,EAAM,EAAc,KAAK,CAAC,EAAW,EADzC,EAGO,CAC/B,CACA,CACgB,EAAK,SAAS,CAAG,CACjC,CAEY,GAAI,EAAK,KAAK,CAAE,CACZ,IAAM,EAAQ,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAI,IAAI,GACzC,IAAK,IAAM,KAAQ,EAAK,KAAK,CAAE,CAC3B,GAAI,CAAE,CAAA,KAAQ,CAAA,GAAU,AAAS,YAAT,EACpB,MAAM,AAAI,MAAM,CAAC,MAAM,EAAE,EAAK,gBAAgB,CAAC,EAGnD,IAAM,EAAY,EAAK,KAAK,CADV,EACqB,CACjC,EAAW,CAAK,CAFJ,EAEe,CAC7B,GAAO,gBAAgB,CAAC,GAAG,CAAC,GAC5B,CAAK,CAJS,EAIE,CAAG,AAAC,IAChB,GAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CACnB,OAAO,QAAQ,OAAO,CAAC,EAAU,IAAI,CAAC,EAAO,IAAM,IAAI,CAAC,AAAA,GAC7C,EAAS,IAAI,CAAC,EAAO,IAGpC,IAAM,EAAM,EAAU,IAAI,CAAC,EAAO,GAClC,OAAO,EAAS,IAAI,CAAC,EAAO,EACxD,EAGwB,CAAK,CAfS,EAeE,CAAG,CAAC,GAAG,KACnB,IAAI,EAAM,EAAU,KAAK,CAAC,EAAO,GAIjC,MAHY,CAAA,IAAR,GACA,CAAA,EAAM,EAAS,KAAK,CAAC,EAAO,EADhC,EAGO,CACnC,CAEA,CACgB,EAAK,KAAK,CAAG,CAC7B,CAEY,GAAI,EAAK,UAAU,CAAE,CACjB,IAAM,EAAa,IAAI,CAAC,QAAQ,CAAC,UAAU,CACrC,EAAiB,EAAK,UAAU,AACtC,CAAA,EAAK,UAAU,CAAG,SAAU,CAAK,EAC7B,IAAI,EAAS,EAAE,CAKf,OAJA,EAAO,IAAI,CAAC,EAAe,IAAI,CAAC,IAAI,CAAE,IAClC,GACA,CAAA,EAAS,EAAO,MAAM,CAAC,EAAW,IAAI,CAAC,IAAI,CAAE,GADjD,EAGO,CAC3B,CACA,CACY,IAAI,CAAC,QAAQ,CAAG,CAAE,GAAG,IAAI,CAAC,QAAQ,CAAE,GAAG,CAAI,AAAA,CACvD,GACe,IAAI,AACnB,CACI,WAAW,CAAG,CAAE,CAEZ,OADA,IAAI,CAAC,QAAQ,CAAG,CAAE,GAAG,IAAI,CAAC,QAAQ,CAAE,GAAG,CAAG,AAAA,EACnC,IAAI,AACnB,CACI,MAAM,CAAG,CAAE,CAAO,CAAE,CAChB,OAAO,GAAO,GAAG,CAAC,EAAK,GAAW,IAAI,CAAC,QAAQ,CACvD,CACI,OAAO,CAAM,CAAE,CAAO,CAAE,CACpB,OAAO,GAAQ,KAAK,CAAC,EAAQ,GAAW,IAAI,CAAC,QAAQ,CAC7D,CACI,CAAA,CAAc,CAAC,CAAK,CAAE,CAAM,EACxB,MAAO,CAAC,EAAK,KACT,IAAM,EAAU,CAAE,GAAG,CAAO,AAAA,EACtB,EAAM,CAAE,GAAG,IAAI,CAAC,QAAQ,CAAE,GAAG,CAAO,AAAA,CAEd,EAAA,IAAxB,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAa,AAAkB,CAAA,IAAlB,EAAQ,KAAK,GACxC,EAAI,MAAM,EACX,QAAQ,IAAI,CAAC,sHAEjB,EAAI,KAAK,CAAG,CAAA,GAEhB,IAAM,EAAa,IAAI,CAAC,CAAA,CAAQ,CAAC,CAAC,CAAC,EAAI,MAAM,CAAE,CAAC,CAAC,EAAI,KAAK,EAE1D,GAAI,MAAO,EACP,OAAO,EAAW,AAAI,MAAM,mDAEhC,GAAI,AAAe,UAAf,OAAO,EACP,OAAO,EAAW,AAAI,MAAM,wCACtB,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAO,sBAKhD,GAHI,EAAI,KAAK,EACT,CAAA,EAAI,KAAK,CAAC,OAAO,CAAG,CADxB,EAGI,EAAI,KAAK,CACT,OAAO,QAAQ,OAAO,CAAC,EAAI,KAAK,CAAG,EAAI,KAAK,CAAC,UAAU,CAAC,GAAO,GAC1D,IAAI,CAAC,AAAA,GAAO,EAAM,EAAK,IACvB,IAAI,CAAC,AAAA,GAAU,EAAI,UAAU,CAAG,QAAQ,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,EAAQ,EAAI,UAAU,GAAG,IAAI,CAAC,IAAM,GAAU,GAC1G,IAAI,CAAC,AAAA,GAAU,EAAO,EAAQ,IAC9B,IAAI,CAAC,AAAA,GAAQ,EAAI,KAAK,CAAG,EAAI,KAAK,CAAC,WAAW,CAAC,GAAQ,GACvD,KAAK,CAAC,GAEf,GAAI,CACI,EAAI,KAAK,EACT,CAAA,EAAM,EAAI,KAAK,CAAC,UAAU,CAAC,EAD/B,EAGA,IAAM,EAAS,EAAM,EAAK,EACtB,CAAA,EAAI,UAAU,EACd,IAAI,CAAC,UAAU,CAAC,EAAQ,EAAI,UAAU,EAE1C,IAAI,EAAO,EAAO,EAAQ,GAI1B,OAHI,EAAI,KAAK,EACT,CAAA,EAAO,EAAI,KAAK,CAAC,WAAW,CAAC,EADjC,EAGO,CACvB,CACY,MAAO,EAAG,CACN,OAAO,EAAW,EAClC,CACA,CACA,CACI,CAAA,CAAQ,CAAC,CAAM,CAAE,CAAK,EAClB,OAAO,AAAC,IAEJ,GADA,EAAE,OAAO,EAAI,8DACT,EAAQ,CACR,IAAM,EAAM,iCACNnM,EAAO,EAAE,OAAO,CAAG,GAAI,CAAA,GACvB,gBACN,AAAI,EACO,QAAQ,OAAO,CAAC,GAEpB,CACvB,CACY,GAAI,EACA,OAAO,QAAQ,MAAM,CAAC,EAE1B,OAAM,CAClB,CACA,CACA,CCjSA,IAAM,GAAiB,IAAI,GACpB,SAAS,GAAO,CAAG,CAAE,CAAG,EAC3B,OAAO,GAAe,KAAK,CAAC,EAAK,EACrC,CAMA,GAAO,OAAO,CACV,GAAO,UAAU,CAAG,SAAU,CAAO,EAIjC,OAHA,GAAe,UAAU,CAAC,GAC1B,GAAO,QAAQ,CAAG,GAAe,QAAQ,CACzC,EAAe,GAAO,QAAQ,EACvB,EACf,EAIA,GAAO,WAAW,CAAG,EACrB,GAAO,QAAQ,CAAGmM,EAAAA,QAAS,CAI3B,GAAO,GAAG,CAAG,SAAU,GAAG,CAAI,EAI1B,OAHA,GAAe,GAAG,IAAI,GACtB,GAAO,QAAQ,CAAG,GAAe,QAAQ,CACzC,EAAe,GAAO,QAAQ,EACvB,EACX,EAIA,GAAO,UAAU,CAAG,SAAU,CAAM,CAAE,CAAQ,EAC1C,OAAO,GAAe,UAAU,CAAC,EAAQ,EAC7C,EAQA,GAAO,WAAW,CAAG,GAAe,WAAW,CAI/C,GAAO,MAAM,CAAG,GAChB,GAAO,MAAM,CAAG,GAAQ,KAAK,CAC7B,GAAO,QAAQ,CAAG,GAClB,GAAO,YAAY,CAAG,GACtB,GAAO,KAAK,CAAG,GACf,GAAO,KAAK,CAAG,GAAO,GAAG,CACzB,GAAO,SAAS,CAAG,EACnB,GAAO,KAAK,CAAG,GACf,GAAO,KAAK,CAAG,GACH,IAAC,GAAU,GAAO,OAAA,CACjB,GAAa,GAAO,UAAA,CACpB,GAAM,GAAO,GAAA,CACb,GAAa,GAAO,UAAA,CACpB,GAAc,GAAO,WAAA,CAErB,GAAS,GAAQ,KAAA,CACjB,GAAQ,GAAO,GAAhB,A,C,E,K,C,G,E,K,C,G,E,M,C,G,E,M,C,G,E,Q,C,G,E,Y,C,G,E,S,C,E,E,W,C,E,E,K,C,G,E,M,C,G,E,O,C,G,E,K,CAFS,G,E,W,C,G,E,M,C,G,E,U,C,G,E,G,C,G,E,U,C,E,E,GlB9DrB,MAAM,EAAY,SAAS,aAAa,CAAC,cACnC,EAAW,SAAS,aAAa,CAAC,aAClC,EAAS,SAAS,aAAa,CAAC,WAEtC,EAAU,gBAAgB,CAAC,QAAS,AAAC,IAEnC,IAAM,EAAQ,KADF,EAAG,aAAa,CAAC,KAAK,EAE5B,EAAS,AAAA,CAAA,EAAA,EAAA,MAAK,AAAL,EAAO,KAAK,CAAC,GACtB,EAAY,AAAA,CAAA,EAAA,EAAA,QAAO,AAAP,EAAS,EAE3B,CAAA,EAAO,SAAS,CAAG,CACrB,GAEA,EAAS,gBAAgB,CAAC,QAAS,AAAC,IAClC,IAAM,EAAS,AAAA,CAAA,EAAA,EAAA,MAAK,AAAL,EAAO,KAAK,CAAC,EAAG,aAAa,CAAC,KAAK,EAC5C,EAAY,AAAA,CAAA,EAAA,EAAA,QAAO,AAAP,EAAS,EAE3B,CAAA,EAAO,SAAS,CAAG,CACrB","sources":["<anon>","src/index.js","node_modules/.pnpm/dompurify@3.0.6/node_modules/dompurify/dist/purify.js","node_modules/.pnpm/dompurify@3.0.6/node_modules/dompurify/src/utils.js","node_modules/.pnpm/dompurify@3.0.6/node_modules/dompurify/src/tags.js","node_modules/.pnpm/dompurify@3.0.6/node_modules/dompurify/src/attrs.js","node_modules/.pnpm/dompurify@3.0.6/node_modules/dompurify/src/regexp.js","node_modules/.pnpm/dompurify@3.0.6/node_modules/dompurify/src/purify.js","node_modules/.pnpm/marked@11.0.0/node_modules/marked/lib/marked.umd.js","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/defaults.ts","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/helpers.ts","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/Tokenizer.ts","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/rules.ts","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/Lexer.ts","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/Renderer.ts","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/TextRenderer.ts","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/Parser.ts","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/Hooks.ts","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/Instance.ts","node_modules/.pnpm/marked@11.0.0/node_modules/marked/src/marked.ts"],"sourcesContent":["var $f123004b8678fd03$exports = {};\n/*! @license DOMPurify 3.0.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.6/LICENSE */ (function(global, factory) {\n    $f123004b8678fd03$exports = factory();\n})($f123004b8678fd03$exports, function() {\n    \"use strict\";\n    const { entries: entries, setPrototypeOf: setPrototypeOf, isFrozen: isFrozen, getPrototypeOf: getPrototypeOf, getOwnPropertyDescriptor: getOwnPropertyDescriptor } = Object;\n    let { freeze: freeze, seal: seal, create: create } = Object; // eslint-disable-line import/no-mutable-exports\n    let { apply: apply, construct: construct } = typeof Reflect !== \"undefined\" && Reflect;\n    if (!freeze) freeze = function freeze(x) {\n        return x;\n    };\n    if (!seal) seal = function seal(x) {\n        return x;\n    };\n    if (!apply) apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n    };\n    if (!construct) construct = function construct(Func, args) {\n        return new Func(...args);\n    };\n    const arrayForEach = unapply(Array.prototype.forEach);\n    const arrayPop = unapply(Array.prototype.pop);\n    const arrayPush = unapply(Array.prototype.push);\n    const stringToLowerCase = unapply(String.prototype.toLowerCase);\n    const stringToString = unapply(String.prototype.toString);\n    const stringMatch = unapply(String.prototype.match);\n    const stringReplace = unapply(String.prototype.replace);\n    const stringIndexOf = unapply(String.prototype.indexOf);\n    const stringTrim = unapply(String.prototype.trim);\n    const regExpTest = unapply(RegExp.prototype.test);\n    const typeErrorCreate = unconstruct(TypeError);\n    /**\n   * Creates a new function that calls the given function with a specified thisArg and arguments.\n   *\n   * @param {Function} func - The function to be wrapped and called.\n   * @returns {Function} A new function that calls the given function with a specified thisArg and arguments.\n   */ function unapply(func) {\n        return function(thisArg) {\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];\n            return apply(func, thisArg, args);\n        };\n    }\n    /**\n   * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n   *\n   * @param {Function} func - The constructor function to be wrapped and called.\n   * @returns {Function} A new function that constructs an instance of the given constructor function with the provided arguments.\n   */ function unconstruct(func) {\n        return function() {\n            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];\n            return construct(func, args);\n        };\n    }\n    /**\n   * Add properties to a lookup table\n   *\n   * @param {Object} set - The set to which elements will be added.\n   * @param {Array} array - The array containing elements to be added to the set.\n   * @param {Function} transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n   * @returns {Object} The modified set with added elements.\n   */ function addToSet(set, array) {\n        let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n        if (setPrototypeOf) // Make 'in' and truthy checks like Boolean(set.constructor)\n        // independent of any properties defined on Object.prototype.\n        // Prevent prototype setters from intercepting set as a this value.\n        setPrototypeOf(set, null);\n        let l = array.length;\n        while(l--){\n            let element = array[l];\n            if (typeof element === \"string\") {\n                const lcElement = transformCaseFunc(element);\n                if (lcElement !== element) {\n                    // Config presets (e.g. tags.js, attrs.js) are immutable.\n                    if (!isFrozen(array)) array[l] = lcElement;\n                    element = lcElement;\n                }\n            }\n            set[element] = true;\n        }\n        return set;\n    }\n    /**\n   * Shallow clone an object\n   *\n   * @param {Object} object - The object to be cloned.\n   * @returns {Object} A new object that copies the original.\n   */ function clone(object) {\n        const newObject = create(null);\n        for (const [property, value] of entries(object))if (getOwnPropertyDescriptor(object, property) !== undefined) newObject[property] = value;\n        return newObject;\n    }\n    /**\n   * This method automatically checks if the prop is function or getter and behaves accordingly.\n   *\n   * @param {Object} object - The object to look up the getter function in its prototype chain.\n   * @param {String} prop - The property name for which to find the getter function.\n   * @returns {Function} The getter function found in the prototype chain or a fallback function.\n   */ function lookupGetter(object, prop) {\n        while(object !== null){\n            const desc = getOwnPropertyDescriptor(object, prop);\n            if (desc) {\n                if (desc.get) return unapply(desc.get);\n                if (typeof desc.value === \"function\") return unapply(desc.value);\n            }\n            object = getPrototypeOf(object);\n        }\n        function fallbackValue(element) {\n            console.warn(\"fallback value for\", element);\n            return null;\n        }\n        return fallbackValue;\n    }\n    const html$1 = freeze([\n        \"a\",\n        \"abbr\",\n        \"acronym\",\n        \"address\",\n        \"area\",\n        \"article\",\n        \"aside\",\n        \"audio\",\n        \"b\",\n        \"bdi\",\n        \"bdo\",\n        \"big\",\n        \"blink\",\n        \"blockquote\",\n        \"body\",\n        \"br\",\n        \"button\",\n        \"canvas\",\n        \"caption\",\n        \"center\",\n        \"cite\",\n        \"code\",\n        \"col\",\n        \"colgroup\",\n        \"content\",\n        \"data\",\n        \"datalist\",\n        \"dd\",\n        \"decorator\",\n        \"del\",\n        \"details\",\n        \"dfn\",\n        \"dialog\",\n        \"dir\",\n        \"div\",\n        \"dl\",\n        \"dt\",\n        \"element\",\n        \"em\",\n        \"fieldset\",\n        \"figcaption\",\n        \"figure\",\n        \"font\",\n        \"footer\",\n        \"form\",\n        \"h1\",\n        \"h2\",\n        \"h3\",\n        \"h4\",\n        \"h5\",\n        \"h6\",\n        \"head\",\n        \"header\",\n        \"hgroup\",\n        \"hr\",\n        \"html\",\n        \"i\",\n        \"img\",\n        \"input\",\n        \"ins\",\n        \"kbd\",\n        \"label\",\n        \"legend\",\n        \"li\",\n        \"main\",\n        \"map\",\n        \"mark\",\n        \"marquee\",\n        \"menu\",\n        \"menuitem\",\n        \"meter\",\n        \"nav\",\n        \"nobr\",\n        \"ol\",\n        \"optgroup\",\n        \"option\",\n        \"output\",\n        \"p\",\n        \"picture\",\n        \"pre\",\n        \"progress\",\n        \"q\",\n        \"rp\",\n        \"rt\",\n        \"ruby\",\n        \"s\",\n        \"samp\",\n        \"section\",\n        \"select\",\n        \"shadow\",\n        \"small\",\n        \"source\",\n        \"spacer\",\n        \"span\",\n        \"strike\",\n        \"strong\",\n        \"style\",\n        \"sub\",\n        \"summary\",\n        \"sup\",\n        \"table\",\n        \"tbody\",\n        \"td\",\n        \"template\",\n        \"textarea\",\n        \"tfoot\",\n        \"th\",\n        \"thead\",\n        \"time\",\n        \"tr\",\n        \"track\",\n        \"tt\",\n        \"u\",\n        \"ul\",\n        \"var\",\n        \"video\",\n        \"wbr\"\n    ]); // SVG\n    const svg$1 = freeze([\n        \"svg\",\n        \"a\",\n        \"altglyph\",\n        \"altglyphdef\",\n        \"altglyphitem\",\n        \"animatecolor\",\n        \"animatemotion\",\n        \"animatetransform\",\n        \"circle\",\n        \"clippath\",\n        \"defs\",\n        \"desc\",\n        \"ellipse\",\n        \"filter\",\n        \"font\",\n        \"g\",\n        \"glyph\",\n        \"glyphref\",\n        \"hkern\",\n        \"image\",\n        \"line\",\n        \"lineargradient\",\n        \"marker\",\n        \"mask\",\n        \"metadata\",\n        \"mpath\",\n        \"path\",\n        \"pattern\",\n        \"polygon\",\n        \"polyline\",\n        \"radialgradient\",\n        \"rect\",\n        \"stop\",\n        \"style\",\n        \"switch\",\n        \"symbol\",\n        \"text\",\n        \"textpath\",\n        \"title\",\n        \"tref\",\n        \"tspan\",\n        \"view\",\n        \"vkern\"\n    ]);\n    const svgFilters = freeze([\n        \"feBlend\",\n        \"feColorMatrix\",\n        \"feComponentTransfer\",\n        \"feComposite\",\n        \"feConvolveMatrix\",\n        \"feDiffuseLighting\",\n        \"feDisplacementMap\",\n        \"feDistantLight\",\n        \"feDropShadow\",\n        \"feFlood\",\n        \"feFuncA\",\n        \"feFuncB\",\n        \"feFuncG\",\n        \"feFuncR\",\n        \"feGaussianBlur\",\n        \"feImage\",\n        \"feMerge\",\n        \"feMergeNode\",\n        \"feMorphology\",\n        \"feOffset\",\n        \"fePointLight\",\n        \"feSpecularLighting\",\n        \"feSpotLight\",\n        \"feTile\",\n        \"feTurbulence\"\n    ]); // List of SVG elements that are disallowed by default.\n    // We still need to know them so that we can do namespace\n    // checks properly in case one wants to add them to\n    // allow-list.\n    const svgDisallowed = freeze([\n        \"animate\",\n        \"color-profile\",\n        \"cursor\",\n        \"discard\",\n        \"font-face\",\n        \"font-face-format\",\n        \"font-face-name\",\n        \"font-face-src\",\n        \"font-face-uri\",\n        \"foreignobject\",\n        \"hatch\",\n        \"hatchpath\",\n        \"mesh\",\n        \"meshgradient\",\n        \"meshpatch\",\n        \"meshrow\",\n        \"missing-glyph\",\n        \"script\",\n        \"set\",\n        \"solidcolor\",\n        \"unknown\",\n        \"use\"\n    ]);\n    const mathMl$1 = freeze([\n        \"math\",\n        \"menclose\",\n        \"merror\",\n        \"mfenced\",\n        \"mfrac\",\n        \"mglyph\",\n        \"mi\",\n        \"mlabeledtr\",\n        \"mmultiscripts\",\n        \"mn\",\n        \"mo\",\n        \"mover\",\n        \"mpadded\",\n        \"mphantom\",\n        \"mroot\",\n        \"mrow\",\n        \"ms\",\n        \"mspace\",\n        \"msqrt\",\n        \"mstyle\",\n        \"msub\",\n        \"msup\",\n        \"msubsup\",\n        \"mtable\",\n        \"mtd\",\n        \"mtext\",\n        \"mtr\",\n        \"munder\",\n        \"munderover\",\n        \"mprescripts\"\n    ]); // Similarly to SVG, we want to know all MathML elements,\n    // even those that we disallow by default.\n    const mathMlDisallowed = freeze([\n        \"maction\",\n        \"maligngroup\",\n        \"malignmark\",\n        \"mlongdiv\",\n        \"mscarries\",\n        \"mscarry\",\n        \"msgroup\",\n        \"mstack\",\n        \"msline\",\n        \"msrow\",\n        \"semantics\",\n        \"annotation\",\n        \"annotation-xml\",\n        \"mprescripts\",\n        \"none\"\n    ]);\n    const text = freeze([\n        \"#text\"\n    ]);\n    const html = freeze([\n        \"accept\",\n        \"action\",\n        \"align\",\n        \"alt\",\n        \"autocapitalize\",\n        \"autocomplete\",\n        \"autopictureinpicture\",\n        \"autoplay\",\n        \"background\",\n        \"bgcolor\",\n        \"border\",\n        \"capture\",\n        \"cellpadding\",\n        \"cellspacing\",\n        \"checked\",\n        \"cite\",\n        \"class\",\n        \"clear\",\n        \"color\",\n        \"cols\",\n        \"colspan\",\n        \"controls\",\n        \"controlslist\",\n        \"coords\",\n        \"crossorigin\",\n        \"datetime\",\n        \"decoding\",\n        \"default\",\n        \"dir\",\n        \"disabled\",\n        \"disablepictureinpicture\",\n        \"disableremoteplayback\",\n        \"download\",\n        \"draggable\",\n        \"enctype\",\n        \"enterkeyhint\",\n        \"face\",\n        \"for\",\n        \"headers\",\n        \"height\",\n        \"hidden\",\n        \"high\",\n        \"href\",\n        \"hreflang\",\n        \"id\",\n        \"inputmode\",\n        \"integrity\",\n        \"ismap\",\n        \"kind\",\n        \"label\",\n        \"lang\",\n        \"list\",\n        \"loading\",\n        \"loop\",\n        \"low\",\n        \"max\",\n        \"maxlength\",\n        \"media\",\n        \"method\",\n        \"min\",\n        \"minlength\",\n        \"multiple\",\n        \"muted\",\n        \"name\",\n        \"nonce\",\n        \"noshade\",\n        \"novalidate\",\n        \"nowrap\",\n        \"open\",\n        \"optimum\",\n        \"pattern\",\n        \"placeholder\",\n        \"playsinline\",\n        \"poster\",\n        \"preload\",\n        \"pubdate\",\n        \"radiogroup\",\n        \"readonly\",\n        \"rel\",\n        \"required\",\n        \"rev\",\n        \"reversed\",\n        \"role\",\n        \"rows\",\n        \"rowspan\",\n        \"spellcheck\",\n        \"scope\",\n        \"selected\",\n        \"shape\",\n        \"size\",\n        \"sizes\",\n        \"span\",\n        \"srclang\",\n        \"start\",\n        \"src\",\n        \"srcset\",\n        \"step\",\n        \"style\",\n        \"summary\",\n        \"tabindex\",\n        \"title\",\n        \"translate\",\n        \"type\",\n        \"usemap\",\n        \"valign\",\n        \"value\",\n        \"width\",\n        \"xmlns\",\n        \"slot\"\n    ]);\n    const svg = freeze([\n        \"accent-height\",\n        \"accumulate\",\n        \"additive\",\n        \"alignment-baseline\",\n        \"ascent\",\n        \"attributename\",\n        \"attributetype\",\n        \"azimuth\",\n        \"basefrequency\",\n        \"baseline-shift\",\n        \"begin\",\n        \"bias\",\n        \"by\",\n        \"class\",\n        \"clip\",\n        \"clippathunits\",\n        \"clip-path\",\n        \"clip-rule\",\n        \"color\",\n        \"color-interpolation\",\n        \"color-interpolation-filters\",\n        \"color-profile\",\n        \"color-rendering\",\n        \"cx\",\n        \"cy\",\n        \"d\",\n        \"dx\",\n        \"dy\",\n        \"diffuseconstant\",\n        \"direction\",\n        \"display\",\n        \"divisor\",\n        \"dur\",\n        \"edgemode\",\n        \"elevation\",\n        \"end\",\n        \"fill\",\n        \"fill-opacity\",\n        \"fill-rule\",\n        \"filter\",\n        \"filterunits\",\n        \"flood-color\",\n        \"flood-opacity\",\n        \"font-family\",\n        \"font-size\",\n        \"font-size-adjust\",\n        \"font-stretch\",\n        \"font-style\",\n        \"font-variant\",\n        \"font-weight\",\n        \"fx\",\n        \"fy\",\n        \"g1\",\n        \"g2\",\n        \"glyph-name\",\n        \"glyphref\",\n        \"gradientunits\",\n        \"gradienttransform\",\n        \"height\",\n        \"href\",\n        \"id\",\n        \"image-rendering\",\n        \"in\",\n        \"in2\",\n        \"k\",\n        \"k1\",\n        \"k2\",\n        \"k3\",\n        \"k4\",\n        \"kerning\",\n        \"keypoints\",\n        \"keysplines\",\n        \"keytimes\",\n        \"lang\",\n        \"lengthadjust\",\n        \"letter-spacing\",\n        \"kernelmatrix\",\n        \"kernelunitlength\",\n        \"lighting-color\",\n        \"local\",\n        \"marker-end\",\n        \"marker-mid\",\n        \"marker-start\",\n        \"markerheight\",\n        \"markerunits\",\n        \"markerwidth\",\n        \"maskcontentunits\",\n        \"maskunits\",\n        \"max\",\n        \"mask\",\n        \"media\",\n        \"method\",\n        \"mode\",\n        \"min\",\n        \"name\",\n        \"numoctaves\",\n        \"offset\",\n        \"operator\",\n        \"opacity\",\n        \"order\",\n        \"orient\",\n        \"orientation\",\n        \"origin\",\n        \"overflow\",\n        \"paint-order\",\n        \"path\",\n        \"pathlength\",\n        \"patterncontentunits\",\n        \"patterntransform\",\n        \"patternunits\",\n        \"points\",\n        \"preservealpha\",\n        \"preserveaspectratio\",\n        \"primitiveunits\",\n        \"r\",\n        \"rx\",\n        \"ry\",\n        \"radius\",\n        \"refx\",\n        \"refy\",\n        \"repeatcount\",\n        \"repeatdur\",\n        \"restart\",\n        \"result\",\n        \"rotate\",\n        \"scale\",\n        \"seed\",\n        \"shape-rendering\",\n        \"specularconstant\",\n        \"specularexponent\",\n        \"spreadmethod\",\n        \"startoffset\",\n        \"stddeviation\",\n        \"stitchtiles\",\n        \"stop-color\",\n        \"stop-opacity\",\n        \"stroke-dasharray\",\n        \"stroke-dashoffset\",\n        \"stroke-linecap\",\n        \"stroke-linejoin\",\n        \"stroke-miterlimit\",\n        \"stroke-opacity\",\n        \"stroke\",\n        \"stroke-width\",\n        \"style\",\n        \"surfacescale\",\n        \"systemlanguage\",\n        \"tabindex\",\n        \"targetx\",\n        \"targety\",\n        \"transform\",\n        \"transform-origin\",\n        \"text-anchor\",\n        \"text-decoration\",\n        \"text-rendering\",\n        \"textlength\",\n        \"type\",\n        \"u1\",\n        \"u2\",\n        \"unicode\",\n        \"values\",\n        \"viewbox\",\n        \"visibility\",\n        \"version\",\n        \"vert-adv-y\",\n        \"vert-origin-x\",\n        \"vert-origin-y\",\n        \"width\",\n        \"word-spacing\",\n        \"wrap\",\n        \"writing-mode\",\n        \"xchannelselector\",\n        \"ychannelselector\",\n        \"x\",\n        \"x1\",\n        \"x2\",\n        \"xmlns\",\n        \"y\",\n        \"y1\",\n        \"y2\",\n        \"z\",\n        \"zoomandpan\"\n    ]);\n    const mathMl = freeze([\n        \"accent\",\n        \"accentunder\",\n        \"align\",\n        \"bevelled\",\n        \"close\",\n        \"columnsalign\",\n        \"columnlines\",\n        \"columnspan\",\n        \"denomalign\",\n        \"depth\",\n        \"dir\",\n        \"display\",\n        \"displaystyle\",\n        \"encoding\",\n        \"fence\",\n        \"frame\",\n        \"height\",\n        \"href\",\n        \"id\",\n        \"largeop\",\n        \"length\",\n        \"linethickness\",\n        \"lspace\",\n        \"lquote\",\n        \"mathbackground\",\n        \"mathcolor\",\n        \"mathsize\",\n        \"mathvariant\",\n        \"maxsize\",\n        \"minsize\",\n        \"movablelimits\",\n        \"notation\",\n        \"numalign\",\n        \"open\",\n        \"rowalign\",\n        \"rowlines\",\n        \"rowspacing\",\n        \"rowspan\",\n        \"rspace\",\n        \"rquote\",\n        \"scriptlevel\",\n        \"scriptminsize\",\n        \"scriptsizemultiplier\",\n        \"selection\",\n        \"separator\",\n        \"separators\",\n        \"stretchy\",\n        \"subscriptshift\",\n        \"supscriptshift\",\n        \"symmetric\",\n        \"voffset\",\n        \"width\",\n        \"xmlns\"\n    ]);\n    const xml = freeze([\n        \"xlink:href\",\n        \"xml:id\",\n        \"xlink:title\",\n        \"xml:space\",\n        \"xmlns:xlink\"\n    ]);\n    const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n    const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n    const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n    const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n    const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n    );\n    const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n    const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n    );\n    const DOCTYPE_NAME = seal(/^html$/i);\n    var EXPRESSIONS = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        MUSTACHE_EXPR: MUSTACHE_EXPR,\n        ERB_EXPR: ERB_EXPR,\n        TMPLIT_EXPR: TMPLIT_EXPR,\n        DATA_ATTR: DATA_ATTR,\n        ARIA_ATTR: ARIA_ATTR,\n        IS_ALLOWED_URI: IS_ALLOWED_URI,\n        IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE: ATTR_WHITESPACE,\n        DOCTYPE_NAME: DOCTYPE_NAME\n    });\n    const getGlobal = function getGlobal() {\n        return typeof window === \"undefined\" ? null : window;\n    };\n    /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported or creating the policy failed).\n   */ const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n        if (typeof trustedTypes !== \"object\" || typeof trustedTypes.createPolicy !== \"function\") return null;\n         // Allow the callers to control the unique policy name\n        // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n        // Policy creation with duplicate names throws in Trusted Types.\n        let suffix = null;\n        const ATTR_NAME = \"data-tt-policy-suffix\";\n        if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) suffix = purifyHostElement.getAttribute(ATTR_NAME);\n        const policyName = \"dompurify\" + (suffix ? \"#\" + suffix : \"\");\n        try {\n            return trustedTypes.createPolicy(policyName, {\n                createHTML (html) {\n                    return html;\n                },\n                createScriptURL (scriptUrl) {\n                    return scriptUrl;\n                }\n            });\n        } catch (_) {\n            // Policy creation failed (most likely another DOMPurify script has\n            // already run). Skip creating the policy, as this will only cause errors\n            // if TT are enforced.\n            console.warn(\"TrustedTypes policy \" + policyName + \" could not be created.\");\n            return null;\n        }\n    };\n    function createDOMPurify() {\n        let window1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n        const DOMPurify = (root)=>createDOMPurify(root);\n        /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */ DOMPurify.version = \"3.0.6\";\n        /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */ DOMPurify.removed = [];\n        if (!window1 || !window1.document || window1.document.nodeType !== 9) {\n            // Not running in a browser, provide a factory function\n            // so that you can pass your own Window\n            DOMPurify.isSupported = false;\n            return DOMPurify;\n        }\n        let { document: document } = window1;\n        const originalDocument = document;\n        const currentScript = originalDocument.currentScript;\n        const { DocumentFragment: DocumentFragment, HTMLTemplateElement: HTMLTemplateElement, Node: Node, Element: Element, NodeFilter: NodeFilter, NamedNodeMap: NamedNodeMap = window1.NamedNodeMap || window1.MozNamedAttrMap, HTMLFormElement: HTMLFormElement, DOMParser: DOMParser, trustedTypes: trustedTypes } = window1;\n        const ElementPrototype = Element.prototype;\n        const cloneNode = lookupGetter(ElementPrototype, \"cloneNode\");\n        const getNextSibling = lookupGetter(ElementPrototype, \"nextSibling\");\n        const getChildNodes = lookupGetter(ElementPrototype, \"childNodes\");\n        const getParentNode = lookupGetter(ElementPrototype, \"parentNode\"); // As per issue #47, the web-components registry is inherited by a\n        // new document created via createHTMLDocument. As per the spec\n        // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n        // a new empty registry is used when creating a template contents owner\n        // document, so we use that as our parent document to ensure nothing\n        // is inherited.\n        if (typeof HTMLTemplateElement === \"function\") {\n            const template = document.createElement(\"template\");\n            if (template.content && template.content.ownerDocument) document = template.content.ownerDocument;\n        }\n        let trustedTypesPolicy;\n        let emptyHTML = \"\";\n        const { implementation: implementation, createNodeIterator: createNodeIterator, createDocumentFragment: createDocumentFragment, getElementsByTagName: getElementsByTagName } = document;\n        const { importNode: importNode } = originalDocument;\n        let hooks = {};\n        /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */ DOMPurify.isSupported = typeof entries === \"function\" && typeof getParentNode === \"function\" && implementation && implementation.createHTMLDocument !== undefined;\n        const { MUSTACHE_EXPR: MUSTACHE_EXPR, ERB_EXPR: ERB_EXPR, TMPLIT_EXPR: TMPLIT_EXPR, DATA_ATTR: DATA_ATTR, ARIA_ATTR: ARIA_ATTR, IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA, ATTR_WHITESPACE: ATTR_WHITESPACE } = EXPRESSIONS;\n        let { IS_ALLOWED_URI: IS_ALLOWED_URI$1 } = EXPRESSIONS;\n        /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */ /* allowed element names */ let ALLOWED_TAGS = null;\n        const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n            ...html$1,\n            ...svg$1,\n            ...svgFilters,\n            ...mathMl$1,\n            ...text\n        ]);\n        /* Allowed attribute names */ let ALLOWED_ATTR = null;\n        const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n            ...html,\n            ...svg,\n            ...mathMl,\n            ...xml\n        ]);\n        /*\n     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.\n     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n     */ let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n            tagNameCheck: {\n                writable: true,\n                configurable: false,\n                enumerable: true,\n                value: null\n            },\n            attributeNameCheck: {\n                writable: true,\n                configurable: false,\n                enumerable: true,\n                value: null\n            },\n            allowCustomizedBuiltInElements: {\n                writable: true,\n                configurable: false,\n                enumerable: true,\n                value: false\n            }\n        }));\n        /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */ let FORBID_TAGS = null;\n        /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */ let FORBID_ATTR = null;\n        /* Decide if ARIA attributes are okay */ let ALLOW_ARIA_ATTR = true;\n        /* Decide if custom data attributes are okay */ let ALLOW_DATA_ATTR = true;\n        /* Decide if unknown protocols are okay */ let ALLOW_UNKNOWN_PROTOCOLS = false;\n        /* Decide if self-closing tags in attributes are allowed.\n     * Usually removed due to a mXSS issue in jQuery 3.0 */ let ALLOW_SELF_CLOSE_IN_ATTR = true;\n        /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */ let SAFE_FOR_TEMPLATES = false;\n        /* Decide if document with <html>... should be returned */ let WHOLE_DOCUMENT = false;\n        /* Track whether config is already set on this instance of DOMPurify. */ let SET_CONFIG = false;\n        /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */ let FORCE_BODY = false;\n        /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */ let RETURN_DOM = false;\n        /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */ let RETURN_DOM_FRAGMENT = false;\n        /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */ let RETURN_TRUSTED_TYPE = false;\n        /* Output should be free from DOM clobbering attacks?\n     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n     */ let SANITIZE_DOM = true;\n        /* Achieve full DOM Clobbering protection by isolating the namespace of named\n     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n     *\n     * HTML/DOM spec rules that enable DOM Clobbering:\n     *   - Named Access on Window (§7.3.3)\n     *   - DOM Tree Accessors (§3.1.5)\n     *   - Form Element Parent-Child Relations (§4.10.3)\n     *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n     *   - HTMLCollection (§4.2.10.2)\n     *\n     * Namespace isolation is implemented by prefixing `id` and `name` attributes\n     * with a constant string, i.e., `user-content-`\n     */ let SANITIZE_NAMED_PROPS = false;\n        const SANITIZE_NAMED_PROPS_PREFIX = \"user-content-\";\n        /* Keep element content when removing element? */ let KEEP_CONTENT = true;\n        /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */ let IN_PLACE = false;\n        /* Allow usage of profiles like html, svg and mathMl */ let USE_PROFILES = {};\n        /* Tags to ignore content of when KEEP_CONTENT is true */ let FORBID_CONTENTS = null;\n        const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n            \"annotation-xml\",\n            \"audio\",\n            \"colgroup\",\n            \"desc\",\n            \"foreignobject\",\n            \"head\",\n            \"iframe\",\n            \"math\",\n            \"mi\",\n            \"mn\",\n            \"mo\",\n            \"ms\",\n            \"mtext\",\n            \"noembed\",\n            \"noframes\",\n            \"noscript\",\n            \"plaintext\",\n            \"script\",\n            \"style\",\n            \"svg\",\n            \"template\",\n            \"thead\",\n            \"title\",\n            \"video\",\n            \"xmp\"\n        ]);\n        /* Tags that are safe for data: URIs */ let DATA_URI_TAGS = null;\n        const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n            \"audio\",\n            \"video\",\n            \"img\",\n            \"source\",\n            \"image\",\n            \"track\"\n        ]);\n        /* Attributes safe for values like \"javascript:\" */ let URI_SAFE_ATTRIBUTES = null;\n        const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n            \"alt\",\n            \"class\",\n            \"for\",\n            \"id\",\n            \"label\",\n            \"name\",\n            \"pattern\",\n            \"placeholder\",\n            \"role\",\n            \"summary\",\n            \"title\",\n            \"value\",\n            \"style\",\n            \"xmlns\"\n        ]);\n        const MATHML_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n        const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n        const HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n        /* Document namespace */ let NAMESPACE = HTML_NAMESPACE;\n        let IS_EMPTY_INPUT = false;\n        /* Allowed XHTML+XML namespaces */ let ALLOWED_NAMESPACES = null;\n        const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n            MATHML_NAMESPACE,\n            SVG_NAMESPACE,\n            HTML_NAMESPACE\n        ], stringToString);\n        /* Parsing of strict XHTML documents */ let PARSER_MEDIA_TYPE = null;\n        const SUPPORTED_PARSER_MEDIA_TYPES = [\n            \"application/xhtml+xml\",\n            \"text/html\"\n        ];\n        const DEFAULT_PARSER_MEDIA_TYPE = \"text/html\";\n        let transformCaseFunc = null;\n        /* Keep a reference to config to pass to hooks */ let CONFIG = null;\n        /* Ideally, do not touch anything below this line */ /* ______________________________________________ */ const formElement = document.createElement(\"form\");\n        const isRegexOrFunction = function isRegexOrFunction(testValue) {\n            return testValue instanceof RegExp || testValue instanceof Function;\n        };\n        /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */ // eslint-disable-next-line complexity\n        const _parseConfig = function _parseConfig() {\n            let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            if (CONFIG && CONFIG === cfg) return;\n            /* Shield configuration object from tampering */ if (!cfg || typeof cfg !== \"object\") cfg = {};\n            /* Shield configuration object from prototype pollution */ cfg = clone(cfg);\n            PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n            transformCaseFunc = PARSER_MEDIA_TYPE === \"application/xhtml+xml\" ? stringToString : stringToLowerCase;\n            /* Set configuration parameters */ ALLOWED_TAGS = \"ALLOWED_TAGS\" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n            ALLOWED_ATTR = \"ALLOWED_ATTR\" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n            ALLOWED_NAMESPACES = \"ALLOWED_NAMESPACES\" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n            URI_SAFE_ATTRIBUTES = \"ADD_URI_SAFE_ATTR\" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc // eslint-disable-line indent\n            ) // eslint-disable-line indent\n             : DEFAULT_URI_SAFE_ATTRIBUTES;\n            DATA_URI_TAGS = \"ADD_DATA_URI_TAGS\" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc // eslint-disable-line indent\n            ) // eslint-disable-line indent\n             : DEFAULT_DATA_URI_TAGS;\n            FORBID_CONTENTS = \"FORBID_CONTENTS\" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n            FORBID_TAGS = \"FORBID_TAGS\" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n            FORBID_ATTR = \"FORBID_ATTR\" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n            USE_PROFILES = \"USE_PROFILES\" in cfg ? cfg.USE_PROFILES : false;\n            ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n            ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n            ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n            ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n            SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n            WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n            RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n            RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n            RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n            FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n            SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n            SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n            KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n            IN_PLACE = cfg.IN_PLACE || false; // Default false\n            IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n            NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n            CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n            if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === \"boolean\") CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n            if (SAFE_FOR_TEMPLATES) ALLOW_DATA_ATTR = false;\n            if (RETURN_DOM_FRAGMENT) RETURN_DOM = true;\n            /* Parse profile info */ if (USE_PROFILES) {\n                ALLOWED_TAGS = addToSet({}, [\n                    ...text\n                ]);\n                ALLOWED_ATTR = [];\n                if (USE_PROFILES.html === true) {\n                    addToSet(ALLOWED_TAGS, html$1);\n                    addToSet(ALLOWED_ATTR, html);\n                }\n                if (USE_PROFILES.svg === true) {\n                    addToSet(ALLOWED_TAGS, svg$1);\n                    addToSet(ALLOWED_ATTR, svg);\n                    addToSet(ALLOWED_ATTR, xml);\n                }\n                if (USE_PROFILES.svgFilters === true) {\n                    addToSet(ALLOWED_TAGS, svgFilters);\n                    addToSet(ALLOWED_ATTR, svg);\n                    addToSet(ALLOWED_ATTR, xml);\n                }\n                if (USE_PROFILES.mathMl === true) {\n                    addToSet(ALLOWED_TAGS, mathMl$1);\n                    addToSet(ALLOWED_ATTR, mathMl);\n                    addToSet(ALLOWED_ATTR, xml);\n                }\n            }\n            /* Merge configuration parameters */ if (cfg.ADD_TAGS) {\n                if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) ALLOWED_TAGS = clone(ALLOWED_TAGS);\n                addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n            }\n            if (cfg.ADD_ATTR) {\n                if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) ALLOWED_ATTR = clone(ALLOWED_ATTR);\n                addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n            }\n            if (cfg.ADD_URI_SAFE_ATTR) addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n            if (cfg.FORBID_CONTENTS) {\n                if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) FORBID_CONTENTS = clone(FORBID_CONTENTS);\n                addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n            }\n            /* Add #text in case KEEP_CONTENT is set to true */ if (KEEP_CONTENT) ALLOWED_TAGS[\"#text\"] = true;\n            /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */ if (WHOLE_DOCUMENT) addToSet(ALLOWED_TAGS, [\n                \"html\",\n                \"head\",\n                \"body\"\n            ]);\n            /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */ if (ALLOWED_TAGS.table) {\n                addToSet(ALLOWED_TAGS, [\n                    \"tbody\"\n                ]);\n                delete FORBID_TAGS.tbody;\n            }\n            if (cfg.TRUSTED_TYPES_POLICY) {\n                if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== \"function\") throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n                if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== \"function\") throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n                 // Overwrite existing TrustedTypes policy.\n                trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY; // Sign local variables required by `sanitize`.\n                emptyHTML = trustedTypesPolicy.createHTML(\"\");\n            } else {\n                // Uninitialized policy, attempt to initialize the internal dompurify policy.\n                if (trustedTypesPolicy === undefined) trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n                 // If creating the internal policy succeeded sign internal variables.\n                if (trustedTypesPolicy !== null && typeof emptyHTML === \"string\") emptyHTML = trustedTypesPolicy.createHTML(\"\");\n            } // Prevent further manipulation of configuration.\n            // Not available in IE8, Safari 5, etc.\n            if (freeze) freeze(cfg);\n            CONFIG = cfg;\n        };\n        const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n            \"mi\",\n            \"mo\",\n            \"mn\",\n            \"ms\",\n            \"mtext\"\n        ]);\n        const HTML_INTEGRATION_POINTS = addToSet({}, [\n            \"foreignobject\",\n            \"desc\",\n            \"title\",\n            \"annotation-xml\"\n        ]); // Certain elements are allowed in both SVG and HTML\n        // namespace. We need to specify them explicitly\n        // so that they don't get erroneously deleted from\n        // HTML namespace.\n        const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n            \"title\",\n            \"style\",\n            \"font\",\n            \"a\",\n            \"script\"\n        ]);\n        /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */ const ALL_SVG_TAGS = addToSet({}, svg$1);\n        addToSet(ALL_SVG_TAGS, svgFilters);\n        addToSet(ALL_SVG_TAGS, svgDisallowed);\n        const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n        addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n        /**\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */ const _checkValidNamespace = function _checkValidNamespace(element) {\n            let parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode\n            // can be null. We just simulate parent in this case.\n            if (!parent || !parent.tagName) parent = {\n                namespaceURI: NAMESPACE,\n                tagName: \"template\"\n            };\n            const tagName = stringToLowerCase(element.tagName);\n            const parentTagName = stringToLowerCase(parent.tagName);\n            if (!ALLOWED_NAMESPACES[element.namespaceURI]) return false;\n            if (element.namespaceURI === SVG_NAMESPACE) {\n                // The only way to switch from HTML namespace to SVG\n                // is via <svg>. If it happens via any other tag, then\n                // it should be killed.\n                if (parent.namespaceURI === HTML_NAMESPACE) return tagName === \"svg\";\n                 // The only way to switch from MathML to SVG is via`\n                // svg if parent is either <annotation-xml> or MathML\n                // text integration points.\n                if (parent.namespaceURI === MATHML_NAMESPACE) return tagName === \"svg\" && (parentTagName === \"annotation-xml\" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n                 // We only allow elements that are defined in SVG\n                // spec. All others are disallowed in SVG namespace.\n                return Boolean(ALL_SVG_TAGS[tagName]);\n            }\n            if (element.namespaceURI === MATHML_NAMESPACE) {\n                // The only way to switch from HTML namespace to MathML\n                // is via <math>. If it happens via any other tag, then\n                // it should be killed.\n                if (parent.namespaceURI === HTML_NAMESPACE) return tagName === \"math\";\n                 // The only way to switch from SVG to MathML is via\n                // <math> and HTML integration points\n                if (parent.namespaceURI === SVG_NAMESPACE) return tagName === \"math\" && HTML_INTEGRATION_POINTS[parentTagName];\n                 // We only allow elements that are defined in MathML\n                // spec. All others are disallowed in MathML namespace.\n                return Boolean(ALL_MATHML_TAGS[tagName]);\n            }\n            if (element.namespaceURI === HTML_NAMESPACE) {\n                // The only way to switch from SVG to HTML is via\n                // HTML integration points, and from MathML to HTML\n                // is via MathML text integration points\n                if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) return false;\n                if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) return false;\n                 // We disallow tags that are specific for MathML\n                // or SVG and should never appear in HTML namespace\n                return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n            } // For XHTML and XML documents that support custom namespaces\n            if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && ALLOWED_NAMESPACES[element.namespaceURI]) return true;\n             // The code should never reach this place (this means\n            // that the element somehow got namespace that is not\n            // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n            // Return false just in case.\n            return false;\n        };\n        /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */ const _forceRemove = function _forceRemove(node) {\n            arrayPush(DOMPurify.removed, {\n                element: node\n            });\n            try {\n                // eslint-disable-next-line unicorn/prefer-dom-node-remove\n                node.parentNode.removeChild(node);\n            } catch (_) {\n                node.remove();\n            }\n        };\n        /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */ const _removeAttribute = function _removeAttribute(name, node) {\n            try {\n                arrayPush(DOMPurify.removed, {\n                    attribute: node.getAttributeNode(name),\n                    from: node\n                });\n            } catch (_) {\n                arrayPush(DOMPurify.removed, {\n                    attribute: null,\n                    from: node\n                });\n            }\n            node.removeAttribute(name); // We void attribute values for unremovable \"is\"\" attributes\n            if (name === \"is\" && !ALLOWED_ATTR[name]) {\n                if (RETURN_DOM || RETURN_DOM_FRAGMENT) try {\n                    _forceRemove(node);\n                } catch (_) {}\n                else try {\n                    node.setAttribute(name, \"\");\n                } catch (_) {}\n            }\n        };\n        /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */ const _initDocument = function _initDocument(dirty) {\n            /* Create a HTML document */ let doc = null;\n            let leadingWhitespace = null;\n            if (FORCE_BODY) dirty = \"<remove></remove>\" + dirty;\n            else {\n                /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */ const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n                leadingWhitespace = matches && matches[0];\n            }\n            if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && NAMESPACE === HTML_NAMESPACE) // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n            dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + \"</body></html>\";\n            const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n            /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */ if (NAMESPACE === HTML_NAMESPACE) try {\n                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n            } catch (_) {}\n            /* Use createHTMLDocument in case DOMParser is not available */ if (!doc || !doc.documentElement) {\n                doc = implementation.createDocument(NAMESPACE, \"template\", null);\n                try {\n                    doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n                } catch (_) {}\n            }\n            const body = doc.body || doc.documentElement;\n            if (dirty && leadingWhitespace) body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n            /* Work on whole document or just its body */ if (NAMESPACE === HTML_NAMESPACE) return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? \"html\" : \"body\")[0];\n            return WHOLE_DOCUMENT ? doc.documentElement : body;\n        };\n        /**\n     * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n     *\n     * @param  {Node} root The root element or node to start traversing on.\n     * @return {NodeIterator} The created NodeIterator\n     */ const _createNodeIterator = function _createNodeIterator(root) {\n            return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null);\n        };\n        /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */ const _isClobbered = function _isClobbered(elm) {\n            return elm instanceof HTMLFormElement && (typeof elm.nodeName !== \"string\" || typeof elm.textContent !== \"string\" || typeof elm.removeChild !== \"function\" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== \"function\" || typeof elm.setAttribute !== \"function\" || typeof elm.namespaceURI !== \"string\" || typeof elm.insertBefore !== \"function\" || typeof elm.hasChildNodes !== \"function\");\n        };\n        /**\n     * Checks whether the given object is a DOM node.\n     *\n     * @param  {Node} object object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */ const _isNode = function _isNode(object) {\n            return typeof Node === \"function\" && object instanceof Node;\n        };\n        /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */ const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n            if (!hooks[entryPoint]) return;\n            arrayForEach(hooks[entryPoint], (hook)=>{\n                hook.call(DOMPurify, currentNode, data, CONFIG);\n            });\n        };\n        /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */ const _sanitizeElements = function _sanitizeElements(currentNode) {\n            let content = null;\n            /* Execute a hook if present */ _executeHook(\"beforeSanitizeElements\", currentNode, null);\n            /* Check if element is clobbered or can clobber */ if (_isClobbered(currentNode)) {\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Now let's check the element's type and name */ const tagName = transformCaseFunc(currentNode.nodeName);\n            /* Execute a hook if present */ _executeHook(\"uponSanitizeElement\", currentNode, {\n                tagName: tagName,\n                allowedTags: ALLOWED_TAGS\n            });\n            /* Detect mXSS attempts abusing namespace confusion */ if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Remove element if anything forbids its presence */ if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n                /* Check if we have a custom element to handle */ if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n                    if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;\n                    if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;\n                }\n                /* Keep content except for bad-listed elements */ if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n                    const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n                    const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n                    if (childNodes && parentNode) {\n                        const childCount = childNodes.length;\n                        for(let i = childCount - 1; i >= 0; --i)parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n                    }\n                }\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Check whether element has a valid namespace */ if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Make sure that older browsers don't get fallback-tag mXSS */ if ((tagName === \"noscript\" || tagName === \"noembed\" || tagName === \"noframes\") && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Sanitize element content to be template-safe */ if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n                /* Get the element's text content */ content = currentNode.textContent;\n                arrayForEach([\n                    MUSTACHE_EXPR,\n                    ERB_EXPR,\n                    TMPLIT_EXPR\n                ], (expr)=>{\n                    content = stringReplace(content, expr, \" \");\n                });\n                if (currentNode.textContent !== content) {\n                    arrayPush(DOMPurify.removed, {\n                        element: currentNode.cloneNode()\n                    });\n                    currentNode.textContent = content;\n                }\n            }\n            /* Execute a hook if present */ _executeHook(\"afterSanitizeElements\", currentNode, null);\n            return false;\n        };\n        /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */ // eslint-disable-next-line complexity\n        const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n            /* Make sure attribute cannot clobber */ if (SANITIZE_DOM && (lcName === \"id\" || lcName === \"name\") && (value in document || value in formElement)) return false;\n            /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */ if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;\n            else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;\n            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n                if (// b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n                // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n                _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n                // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n                lcName === \"is\" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;\n                else return false;\n            /* Check value is safe. First, is attr inert? If so, is safe */ } else if (URI_SAFE_ATTRIBUTES[lcName]) ;\n            else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n            else if ((lcName === \"src\" || lcName === \"xlink:href\" || lcName === \"href\") && lcTag !== \"script\" && stringIndexOf(value, \"data:\") === 0 && DATA_URI_TAGS[lcTag]) ;\n            else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n            else if (value) return false;\n            return true;\n        };\n        /**\n     * _isBasicCustomElement\n     * checks if at least one dash is included in tagName, and it's not the first char\n     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n     *\n     * @param {string} tagName name of the tag of the node to sanitize\n     * @returns {boolean} Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n     */ const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n            return tagName.indexOf(\"-\") > 0;\n        };\n        /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */ const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n            /* Execute a hook if present */ _executeHook(\"beforeSanitizeAttributes\", currentNode, null);\n            const { attributes: attributes } = currentNode;\n            /* Check if we have attributes; if not we might have a text node */ if (!attributes) return;\n            const hookEvent = {\n                attrName: \"\",\n                attrValue: \"\",\n                keepAttr: true,\n                allowedAttributes: ALLOWED_ATTR\n            };\n            let l = attributes.length;\n            /* Go backwards over all attributes; safely remove bad ones */ while(l--){\n                const attr = attributes[l];\n                const { name: name, namespaceURI: namespaceURI, value: attrValue } = attr;\n                const lcName = transformCaseFunc(name);\n                let value = name === \"value\" ? attrValue : stringTrim(attrValue);\n                /* Execute a hook if present */ hookEvent.attrName = lcName;\n                hookEvent.attrValue = value;\n                hookEvent.keepAttr = true;\n                hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n                _executeHook(\"uponSanitizeAttribute\", currentNode, hookEvent);\n                value = hookEvent.attrValue;\n                /* Did the hooks approve of the attribute? */ if (hookEvent.forceKeepAttr) continue;\n                /* Remove attribute */ _removeAttribute(name, currentNode);\n                /* Did the hooks approve of the attribute? */ if (!hookEvent.keepAttr) continue;\n                /* Work around a security issue in jQuery 3.0 */ if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n                    _removeAttribute(name, currentNode);\n                    continue;\n                }\n                /* Sanitize attribute content to be template-safe */ if (SAFE_FOR_TEMPLATES) arrayForEach([\n                    MUSTACHE_EXPR,\n                    ERB_EXPR,\n                    TMPLIT_EXPR\n                ], (expr)=>{\n                    value = stringReplace(value, expr, \" \");\n                });\n                /* Is `value` valid for this attribute? */ const lcTag = transformCaseFunc(currentNode.nodeName);\n                if (!_isValidAttribute(lcTag, lcName, value)) continue;\n                /* Full DOM Clobbering protection via namespace isolation,\n         * Prefix id and name attributes with `user-content-`\n         */ if (SANITIZE_NAMED_PROPS && (lcName === \"id\" || lcName === \"name\")) {\n                    // Remove the attribute with this value\n                    _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value\n                    value = SANITIZE_NAMED_PROPS_PREFIX + value;\n                }\n                /* Handle attributes that require Trusted Types */ if (trustedTypesPolicy && typeof trustedTypes === \"object\" && typeof trustedTypes.getAttributeType === \"function\") {\n                    if (namespaceURI) ;\n                    else switch(trustedTypes.getAttributeType(lcTag, lcName)){\n                        case \"TrustedHTML\":\n                            value = trustedTypesPolicy.createHTML(value);\n                            break;\n                        case \"TrustedScriptURL\":\n                            value = trustedTypesPolicy.createScriptURL(value);\n                            break;\n                    }\n                }\n                /* Handle invalid data-* attribute set by try-catching it */ try {\n                    if (namespaceURI) currentNode.setAttributeNS(namespaceURI, name, value);\n                    else /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */ currentNode.setAttribute(name, value);\n                    arrayPop(DOMPurify.removed);\n                } catch (_) {}\n            }\n            /* Execute a hook if present */ _executeHook(\"afterSanitizeAttributes\", currentNode, null);\n        };\n        /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */ const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n            let shadowNode = null;\n            const shadowIterator = _createNodeIterator(fragment);\n            /* Execute a hook if present */ _executeHook(\"beforeSanitizeShadowDOM\", fragment, null);\n            while(shadowNode = shadowIterator.nextNode()){\n                /* Execute a hook if present */ _executeHook(\"uponSanitizeShadowNode\", shadowNode, null);\n                /* Sanitize tags and elements */ if (_sanitizeElements(shadowNode)) continue;\n                /* Deep shadow DOM detected */ if (shadowNode.content instanceof DocumentFragment) _sanitizeShadowDOM(shadowNode.content);\n                /* Check attributes, sanitize if necessary */ _sanitizeAttributes(shadowNode);\n            }\n            /* Execute a hook if present */ _executeHook(\"afterSanitizeShadowDOM\", fragment, null);\n        };\n        /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} cfg object\n     */ // eslint-disable-next-line complexity\n        DOMPurify.sanitize = function(dirty) {\n            let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            let body = null;\n            let importedNode = null;\n            let currentNode = null;\n            let returnNode = null;\n            /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */ IS_EMPTY_INPUT = !dirty;\n            if (IS_EMPTY_INPUT) dirty = \"<!-->\";\n            /* Stringify, in case dirty is an object */ if (typeof dirty !== \"string\" && !_isNode(dirty)) {\n                if (typeof dirty.toString === \"function\") {\n                    dirty = dirty.toString();\n                    if (typeof dirty !== \"string\") throw typeErrorCreate(\"dirty is not a string, aborting\");\n                } else throw typeErrorCreate(\"toString is not a function\");\n            }\n            /* Return dirty HTML if DOMPurify cannot run */ if (!DOMPurify.isSupported) return dirty;\n            /* Assign config vars */ if (!SET_CONFIG) _parseConfig(cfg);\n            /* Clean up removed elements */ DOMPurify.removed = [];\n            /* Check if dirty is correctly typed for IN_PLACE */ if (typeof dirty === \"string\") IN_PLACE = false;\n            if (IN_PLACE) /* Do some early pre-sanitization to avoid unsafe root nodes */ {\n                if (dirty.nodeName) {\n                    const tagName = transformCaseFunc(dirty.nodeName);\n                    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) throw typeErrorCreate(\"root node is forbidden and cannot be sanitized in-place\");\n                }\n            } else if (dirty instanceof Node) {\n                /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */ body = _initDocument(\"<!---->\");\n                importedNode = body.ownerDocument.importNode(dirty, true);\n                if (importedNode.nodeType === 1 && importedNode.nodeName === \"BODY\") /* Node is already a body, use as is */ body = importedNode;\n                else if (importedNode.nodeName === \"HTML\") body = importedNode;\n                else // eslint-disable-next-line unicorn/prefer-dom-node-append\n                body.appendChild(importedNode);\n            } else {\n                /* Exit directly if we have nothing to do */ if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n                dirty.indexOf(\"<\") === -1) return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n                /* Initialize the document to work on */ body = _initDocument(dirty);\n                /* Check we have a DOM node from the data */ if (!body) return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : \"\";\n            }\n            /* Remove first element node (ours) if FORCE_BODY is set */ if (body && FORCE_BODY) _forceRemove(body.firstChild);\n            /* Get node iterator */ const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n            /* Now start iterating over the created document */ while(currentNode = nodeIterator.nextNode()){\n                /* Sanitize tags and elements */ if (_sanitizeElements(currentNode)) continue;\n                /* Shadow DOM detected, sanitize it */ if (currentNode.content instanceof DocumentFragment) _sanitizeShadowDOM(currentNode.content);\n                /* Check attributes, sanitize if necessary */ _sanitizeAttributes(currentNode);\n            }\n            /* If we sanitized `dirty` in-place, return it. */ if (IN_PLACE) return dirty;\n            /* Return sanitized string or DOM */ if (RETURN_DOM) {\n                if (RETURN_DOM_FRAGMENT) {\n                    returnNode = createDocumentFragment.call(body.ownerDocument);\n                    while(body.firstChild)// eslint-disable-next-line unicorn/prefer-dom-node-append\n                    returnNode.appendChild(body.firstChild);\n                } else returnNode = body;\n                if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */ returnNode = importNode.call(originalDocument, returnNode, true);\n                return returnNode;\n            }\n            let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n            /* Serialize doctype if allowed */ if (WHOLE_DOCUMENT && ALLOWED_TAGS[\"!doctype\"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) serializedHTML = \"<!DOCTYPE \" + body.ownerDocument.doctype.name + \">\\n\" + serializedHTML;\n            /* Sanitize final string template-safe */ if (SAFE_FOR_TEMPLATES) arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                serializedHTML = stringReplace(serializedHTML, expr, \" \");\n            });\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n        };\n        /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */ DOMPurify.setConfig = function() {\n            let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            _parseConfig(cfg);\n            SET_CONFIG = true;\n        };\n        /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */ DOMPurify.clearConfig = function() {\n            CONFIG = null;\n            SET_CONFIG = false;\n        };\n        /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {String} tag Tag name of containing element.\n     * @param  {String} attr Attribute name.\n     * @param  {String} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */ DOMPurify.isValidAttribute = function(tag, attr, value) {\n            /* Initialize shared config vars if necessary. */ if (!CONFIG) _parseConfig({});\n            const lcTag = transformCaseFunc(tag);\n            const lcName = transformCaseFunc(attr);\n            return _isValidAttribute(lcTag, lcName, value);\n        };\n        /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */ DOMPurify.addHook = function(entryPoint, hookFunction) {\n            if (typeof hookFunction !== \"function\") return;\n            hooks[entryPoint] = hooks[entryPoint] || [];\n            arrayPush(hooks[entryPoint], hookFunction);\n        };\n        /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     * @return {Function} removed(popped) hook\n     */ DOMPurify.removeHook = function(entryPoint) {\n            if (hooks[entryPoint]) return arrayPop(hooks[entryPoint]);\n        };\n        /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */ DOMPurify.removeHooks = function(entryPoint) {\n            if (hooks[entryPoint]) hooks[entryPoint] = [];\n        };\n        /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     */ DOMPurify.removeAllHooks = function() {\n            hooks = {};\n        };\n        return DOMPurify;\n    }\n    var purify = createDOMPurify();\n    return purify;\n});\n\n\nvar $d24e0eeb5f66fbc4$exports = {};\n/**\n * marked v11.0.0 - a markdown parser\n * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ (function(global, factory) {\n    factory($d24e0eeb5f66fbc4$exports);\n})($d24e0eeb5f66fbc4$exports, function(exports1) {\n    \"use strict\";\n    /**\n     * Gets the original marked default options.\n     */ function _getDefaults() {\n        return {\n            async: false,\n            breaks: false,\n            extensions: null,\n            gfm: true,\n            hooks: null,\n            pedantic: false,\n            renderer: null,\n            silent: false,\n            tokenizer: null,\n            walkTokens: null\n        };\n    }\n    exports1.defaults = _getDefaults();\n    function changeDefaults(newDefaults) {\n        exports1.defaults = newDefaults;\n    }\n    /**\n     * Helpers\n     */ const escapeTest = /[&<>\"']/;\n    const escapeReplace = new RegExp(escapeTest.source, \"g\");\n    const escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\n    const escapeReplacements = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\"\n    };\n    const getEscapeReplacement = (ch)=>escapeReplacements[ch];\n    function escape$1(html, encode) {\n        if (encode) {\n            if (escapeTest.test(html)) return html.replace(escapeReplace, getEscapeReplacement);\n        } else {\n            if (escapeTestNoEncode.test(html)) return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n        return html;\n    }\n    const unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n    function unescape(html) {\n        // explicitly match decimal, hex, and named HTML entities\n        return html.replace(unescapeTest, (_, n)=>{\n            n = n.toLowerCase();\n            if (n === \"colon\") return \":\";\n            if (n.charAt(0) === \"#\") return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n            return \"\";\n        });\n    }\n    const caret = /(^|[^\\[])\\^/g;\n    function edit(regex, opt) {\n        let source = typeof regex === \"string\" ? regex : regex.source;\n        opt = opt || \"\";\n        const obj = {\n            replace: (name, val)=>{\n                let valSource = typeof val === \"string\" ? val : val.source;\n                valSource = valSource.replace(caret, \"$1\");\n                source = source.replace(name, valSource);\n                return obj;\n            },\n            getRegex: ()=>{\n                return new RegExp(source, opt);\n            }\n        };\n        return obj;\n    }\n    function cleanUrl(href) {\n        try {\n            href = encodeURI(href).replace(/%25/g, \"%\");\n        } catch (e) {\n            return null;\n        }\n        return href;\n    }\n    const noopTest = {\n        exec: ()=>null\n    };\n    function splitCells(tableRow, count) {\n        // ensure that every cell-delimiting pipe has a space\n        // before it to distinguish it from an escaped pipe\n        const row = tableRow.replace(/\\|/g, (match, offset, str)=>{\n            let escaped = false;\n            let curr = offset;\n            while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n            if (escaped) // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n            else // add space before unescaped |\n            return \" |\";\n        }), cells = row.split(/ \\|/);\n        let i = 0;\n        // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n        if (!cells[0].trim()) cells.shift();\n        if (cells.length > 0 && !cells[cells.length - 1].trim()) cells.pop();\n        if (count) {\n            if (cells.length > count) cells.splice(count);\n            else while(cells.length < count)cells.push(\"\");\n        }\n        for(; i < cells.length; i++)// leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n        return cells;\n    }\n    /**\n     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n     * /c*$/ is vulnerable to REDOS.\n     *\n     * @param str\n     * @param c\n     * @param invert Remove suffix of non-c chars instead. Default falsey.\n     */ function rtrim(str, c, invert) {\n        const l = str.length;\n        if (l === 0) return \"\";\n        // Length of suffix matching the invert condition.\n        let suffLen = 0;\n        // Step left until we fail to match the invert condition.\n        while(suffLen < l){\n            const currChar = str.charAt(l - suffLen - 1);\n            if (currChar === c && !invert) suffLen++;\n            else if (currChar !== c && invert) suffLen++;\n            else break;\n        }\n        return str.slice(0, l - suffLen);\n    }\n    function findClosingBracket(str, b) {\n        if (str.indexOf(b[1]) === -1) return -1;\n        let level = 0;\n        for(let i = 0; i < str.length; i++){\n            if (str[i] === \"\\\\\") i++;\n            else if (str[i] === b[0]) level++;\n            else if (str[i] === b[1]) {\n                level--;\n                if (level < 0) return i;\n            }\n        }\n        return -1;\n    }\n    function outputLink(cap, link, raw, lexer) {\n        const href = link.href;\n        const title = link.title ? escape$1(link.title) : null;\n        const text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n        if (cap[0].charAt(0) !== \"!\") {\n            lexer.state.inLink = true;\n            const token = {\n                type: \"link\",\n                raw: raw,\n                href: href,\n                title: title,\n                text: text,\n                tokens: lexer.inlineTokens(text)\n            };\n            lexer.state.inLink = false;\n            return token;\n        }\n        return {\n            type: \"image\",\n            raw: raw,\n            href: href,\n            title: title,\n            text: escape$1(text)\n        };\n    }\n    function indentCodeCompensation(raw, text) {\n        const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n        if (matchIndentToCode === null) return text;\n        const indentToCode = matchIndentToCode[1];\n        return text.split(\"\\n\").map((node)=>{\n            const matchIndentInNode = node.match(/^\\s+/);\n            if (matchIndentInNode === null) return node;\n            const [indentInNode] = matchIndentInNode;\n            if (indentInNode.length >= indentToCode.length) return node.slice(indentToCode.length);\n            return node;\n        }).join(\"\\n\");\n    }\n    /**\n     * Tokenizer\n     */ class _Tokenizer {\n        options;\n        rules;\n        lexer;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        space(src) {\n            const cap = this.rules.block.newline.exec(src);\n            if (cap && cap[0].length > 0) return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n        code(src) {\n            const cap = this.rules.block.code.exec(src);\n            if (cap) {\n                const text = cap[0].replace(/^ {1,4}/gm, \"\");\n                return {\n                    type: \"code\",\n                    raw: cap[0],\n                    codeBlockStyle: \"indented\",\n                    text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n                };\n            }\n        }\n        fences(src) {\n            const cap = this.rules.block.fences.exec(src);\n            if (cap) {\n                const raw = cap[0];\n                const text = indentCodeCompensation(raw, cap[3] || \"\");\n                return {\n                    type: \"code\",\n                    raw: raw,\n                    lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, \"$1\") : cap[2],\n                    text: text\n                };\n            }\n        }\n        heading(src) {\n            const cap = this.rules.block.heading.exec(src);\n            if (cap) {\n                let text = cap[2].trim();\n                // remove trailing #s\n                if (/#$/.test(text)) {\n                    const trimmed = rtrim(text, \"#\");\n                    if (this.options.pedantic) text = trimmed.trim();\n                    else if (!trimmed || / $/.test(trimmed)) // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n                return {\n                    type: \"heading\",\n                    raw: cap[0],\n                    depth: cap[1].length,\n                    text: text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        hr(src) {\n            const cap = this.rules.block.hr.exec(src);\n            if (cap) return {\n                type: \"hr\",\n                raw: cap[0]\n            };\n        }\n        blockquote(src) {\n            const cap = this.rules.block.blockquote.exec(src);\n            if (cap) {\n                const text = rtrim(cap[0].replace(/^ *>[ \\t]?/gm, \"\"), \"\\n\");\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                const tokens = this.lexer.blockTokens(text);\n                this.lexer.state.top = top;\n                return {\n                    type: \"blockquote\",\n                    raw: cap[0],\n                    tokens: tokens,\n                    text: text\n                };\n            }\n        }\n        list(src) {\n            let cap = this.rules.block.list.exec(src);\n            if (cap) {\n                let bull = cap[1].trim();\n                const isordered = bull.length > 1;\n                const list = {\n                    type: \"list\",\n                    raw: \"\",\n                    ordered: isordered,\n                    start: isordered ? +bull.slice(0, -1) : \"\",\n                    loose: false,\n                    items: []\n                };\n                bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n                if (this.options.pedantic) bull = isordered ? bull : \"[*+-]\";\n                // Get next list item\n                const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n                let raw = \"\";\n                let itemContents = \"\";\n                let endsWithBlankLine = false;\n                // Check if current bullet point can start a new List Item\n                while(src){\n                    let endEarly = false;\n                    if (!(cap = itemRegex.exec(src))) break;\n                    if (this.rules.block.hr.test(src)) break;\n                    raw = cap[0];\n                    src = src.substring(raw.length);\n                    let line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, (t)=>\" \".repeat(3 * t.length));\n                    let nextLine = src.split(\"\\n\", 1)[0];\n                    let indent = 0;\n                    if (this.options.pedantic) {\n                        indent = 2;\n                        itemContents = line.trimStart();\n                    } else {\n                        indent = cap[2].search(/[^ ]/); // Find first non-space char\n                        indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                        itemContents = line.slice(indent);\n                        indent += cap[1].length;\n                    }\n                    let blankLine = false;\n                    if (!line && /^ *$/.test(nextLine)) {\n                        raw += nextLine + \"\\n\";\n                        src = src.substring(nextLine.length + 1);\n                        endEarly = true;\n                    }\n                    if (!endEarly) {\n                        const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                        const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                        const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                        const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                        // Check if following lines should be included in List Item\n                        while(src){\n                            const rawLine = src.split(\"\\n\", 1)[0];\n                            nextLine = rawLine;\n                            // Re-align to follow commonmark nesting rules\n                            if (this.options.pedantic) nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                            // End list item if found code fences\n                            if (fencesBeginRegex.test(nextLine)) break;\n                            // End list item if found start of new heading\n                            if (headingBeginRegex.test(nextLine)) break;\n                            // End list item if found start of new bullet\n                            if (nextBulletRegex.test(nextLine)) break;\n                            // Horizontal rule found\n                            if (hrRegex.test(src)) break;\n                            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) itemContents += \"\\n\" + nextLine.slice(indent);\n                            else {\n                                // not enough indentation\n                                if (blankLine) break;\n                                // paragraph continuation unless last line was a different block level element\n                                if (line.search(/[^ ]/) >= 4) break;\n                                if (fencesBeginRegex.test(line)) break;\n                                if (headingBeginRegex.test(line)) break;\n                                if (hrRegex.test(line)) break;\n                                itemContents += \"\\n\" + nextLine;\n                            }\n                            if (!blankLine && !nextLine.trim()) blankLine = true;\n                            raw += rawLine + \"\\n\";\n                            src = src.substring(rawLine.length + 1);\n                            line = nextLine.slice(indent);\n                        }\n                    }\n                    if (!list.loose) {\n                        // If the previous item ended with a blank line, the list is loose\n                        if (endsWithBlankLine) list.loose = true;\n                        else if (/\\n *\\n *$/.test(raw)) endsWithBlankLine = true;\n                    }\n                    let istask = null;\n                    let ischecked;\n                    // Check for task list items\n                    if (this.options.gfm) {\n                        istask = /^\\[[ xX]\\] /.exec(itemContents);\n                        if (istask) {\n                            ischecked = istask[0] !== \"[ ] \";\n                            itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                        }\n                    }\n                    list.items.push({\n                        type: \"list_item\",\n                        raw: raw,\n                        task: !!istask,\n                        checked: ischecked,\n                        loose: false,\n                        text: itemContents,\n                        tokens: []\n                    });\n                    list.raw += raw;\n                }\n                // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n                list.items[list.items.length - 1].raw = raw.trimEnd();\n                list.items[list.items.length - 1].text = itemContents.trimEnd();\n                list.raw = list.raw.trimEnd();\n                // Item child tokens handled here at end because we needed to have the final item to trim it first\n                for(let i = 0; i < list.items.length; i++){\n                    this.lexer.state.top = false;\n                    list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                    if (!list.loose) {\n                        // Check if list should be loose\n                        const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                        const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>/\\n.*\\n/.test(t.raw));\n                        list.loose = hasMultipleLineBreaks;\n                    }\n                }\n                // Set all items to loose if list is loose\n                if (list.loose) for(let i = 0; i < list.items.length; i++)list.items[i].loose = true;\n                return list;\n            }\n        }\n        html(src) {\n            const cap = this.rules.block.html.exec(src);\n            if (cap) {\n                const token = {\n                    type: \"html\",\n                    block: true,\n                    raw: cap[0],\n                    pre: cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\",\n                    text: cap[0]\n                };\n                return token;\n            }\n        }\n        def(src) {\n            const cap = this.rules.block.def.exec(src);\n            if (cap) {\n                const tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n                const href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline.anyPunctuation, \"$1\") : \"\";\n                const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, \"$1\") : cap[3];\n                return {\n                    type: \"def\",\n                    tag: tag,\n                    raw: cap[0],\n                    href: href,\n                    title: title\n                };\n            }\n        }\n        table(src) {\n            const cap = this.rules.block.table.exec(src);\n            if (!cap) return;\n            if (!/[:|]/.test(cap[2])) // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n            const headers = splitCells(cap[1]);\n            const aligns = cap[2].replace(/^\\||\\| *$/g, \"\").split(\"|\");\n            const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : [];\n            const item = {\n                type: \"table\",\n                raw: cap[0],\n                header: [],\n                align: [],\n                rows: []\n            };\n            if (headers.length !== aligns.length) // header and align columns must be equal, rows can be different.\n            return;\n            for (const align of aligns){\n                if (/^ *-+: *$/.test(align)) item.align.push(\"right\");\n                else if (/^ *:-+: *$/.test(align)) item.align.push(\"center\");\n                else if (/^ *:-+ *$/.test(align)) item.align.push(\"left\");\n                else item.align.push(null);\n            }\n            for (const header of headers)item.header.push({\n                text: header,\n                tokens: this.lexer.inline(header)\n            });\n            for (const row of rows)item.rows.push(splitCells(row, item.header.length).map((cell)=>{\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell)\n                };\n            }));\n            return item;\n        }\n        lheading(src) {\n            const cap = this.rules.block.lheading.exec(src);\n            if (cap) return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n        paragraph(src) {\n            const cap = this.rules.block.paragraph.exec(src);\n            if (cap) {\n                const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n                return {\n                    type: \"paragraph\",\n                    raw: cap[0],\n                    text: text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        text(src) {\n            const cap = this.rules.block.text.exec(src);\n            if (cap) return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n        escape(src) {\n            const cap = this.rules.inline.escape.exec(src);\n            if (cap) return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape$1(cap[1])\n            };\n        }\n        tag(src) {\n            const cap = this.rules.inline.tag.exec(src);\n            if (cap) {\n                if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) this.lexer.state.inLink = true;\n                else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) this.lexer.state.inLink = false;\n                if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) this.lexer.state.inRawBlock = true;\n                else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) this.lexer.state.inRawBlock = false;\n                return {\n                    type: \"html\",\n                    raw: cap[0],\n                    inLink: this.lexer.state.inLink,\n                    inRawBlock: this.lexer.state.inRawBlock,\n                    block: false,\n                    text: cap[0]\n                };\n            }\n        }\n        link(src) {\n            const cap = this.rules.inline.link.exec(src);\n            if (cap) {\n                const trimmedUrl = cap[2].trim();\n                if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                    // commonmark requires matching angle brackets\n                    if (!/>$/.test(trimmedUrl)) return;\n                    // ending angle bracket cannot be escaped\n                    const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                    if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) return;\n                } else {\n                    // find closing parenthesis\n                    const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                    if (lastParenIndex > -1) {\n                        const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                        const linkLen = start + cap[1].length + lastParenIndex;\n                        cap[2] = cap[2].substring(0, lastParenIndex);\n                        cap[0] = cap[0].substring(0, linkLen).trim();\n                        cap[3] = \"\";\n                    }\n                }\n                let href = cap[2];\n                let title = \"\";\n                if (this.options.pedantic) {\n                    // split pedantic href and title\n                    const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                    if (link) {\n                        href = link[1];\n                        title = link[3];\n                    }\n                } else title = cap[3] ? cap[3].slice(1, -1) : \"\";\n                href = href.trim();\n                if (/^</.test(href)) {\n                    if (this.options.pedantic && !/>$/.test(trimmedUrl)) // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                    else href = href.slice(1, -1);\n                }\n                return outputLink(cap, {\n                    href: href ? href.replace(this.rules.inline.anyPunctuation, \"$1\") : href,\n                    title: title ? title.replace(this.rules.inline.anyPunctuation, \"$1\") : title\n                }, cap[0], this.lexer);\n            }\n        }\n        reflink(src, links) {\n            let cap;\n            if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n                const linkString = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n                const link = links[linkString.toLowerCase()];\n                if (!link) {\n                    const text = cap[0].charAt(0);\n                    return {\n                        type: \"text\",\n                        raw: text,\n                        text: text\n                    };\n                }\n                return outputLink(cap, link, cap[0], this.lexer);\n            }\n        }\n        emStrong(src, maskedSrc, prevChar = \"\") {\n            let match = this.rules.inline.emStrongLDelim.exec(src);\n            if (!match) return;\n            // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n            if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n            const nextChar = match[1] || match[2] || \"\";\n            if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n                // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n                const lLength = [\n                    ...match[0]\n                ].length - 1;\n                let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n                const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n                endReg.lastIndex = 0;\n                // Clip maskedSrc to same section of string as src (move to lexer?)\n                maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n                while((match = endReg.exec(maskedSrc)) != null){\n                    rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                    if (!rDelim) continue; // skip single * in __abc*abc__\n                    rLength = [\n                        ...rDelim\n                    ].length;\n                    if (match[3] || match[4]) {\n                        delimTotal += rLength;\n                        continue;\n                    } else if (match[5] || match[6]) {\n                        if (lLength % 3 && !((lLength + rLength) % 3)) {\n                            midDelimTotal += rLength;\n                            continue; // CommonMark Emphasis Rules 9-10\n                        }\n                    }\n                    delimTotal -= rLength;\n                    if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                    // Remove extra characters. *a*** -> *a*\n                    rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                    // char length can be >1 for unicode characters;\n                    const lastCharLength = [\n                        ...match[0]\n                    ][0].length;\n                    const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                    // Create `em` if smallest delimiter has odd char count. *a***\n                    if (Math.min(lLength, rLength) % 2) {\n                        const text = raw.slice(1, -1);\n                        return {\n                            type: \"em\",\n                            raw: raw,\n                            text: text,\n                            tokens: this.lexer.inlineTokens(text)\n                        };\n                    }\n                    // Create 'strong' if smallest delimiter has even char count. **a***\n                    const text = raw.slice(2, -2);\n                    return {\n                        type: \"strong\",\n                        raw: raw,\n                        text: text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n            }\n        }\n        codespan(src) {\n            const cap = this.rules.inline.code.exec(src);\n            if (cap) {\n                let text = cap[2].replace(/\\n/g, \" \");\n                const hasNonSpaceChars = /[^ ]/.test(text);\n                const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n                if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) text = text.substring(1, text.length - 1);\n                text = escape$1(text, true);\n                return {\n                    type: \"codespan\",\n                    raw: cap[0],\n                    text: text\n                };\n            }\n        }\n        br(src) {\n            const cap = this.rules.inline.br.exec(src);\n            if (cap) return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n        del(src) {\n            const cap = this.rules.inline.del.exec(src);\n            if (cap) return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n        autolink(src) {\n            const cap = this.rules.inline.autolink.exec(src);\n            if (cap) {\n                let text, href;\n                if (cap[2] === \"@\") {\n                    text = escape$1(cap[1]);\n                    href = \"mailto:\" + text;\n                } else {\n                    text = escape$1(cap[1]);\n                    href = text;\n                }\n                return {\n                    type: \"link\",\n                    raw: cap[0],\n                    text: text,\n                    href: href,\n                    tokens: [\n                        {\n                            type: \"text\",\n                            raw: text,\n                            text: text\n                        }\n                    ]\n                };\n            }\n        }\n        url(src) {\n            let cap;\n            if (cap = this.rules.inline.url.exec(src)) {\n                let text, href;\n                if (cap[2] === \"@\") {\n                    text = escape$1(cap[0]);\n                    href = \"mailto:\" + text;\n                } else {\n                    // do extended autolink path validation\n                    let prevCapZero;\n                    do {\n                        prevCapZero = cap[0];\n                        cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? \"\";\n                    }while (prevCapZero !== cap[0]);\n                    text = escape$1(cap[0]);\n                    if (cap[1] === \"www.\") href = \"http://\" + cap[0];\n                    else href = cap[0];\n                }\n                return {\n                    type: \"link\",\n                    raw: cap[0],\n                    text: text,\n                    href: href,\n                    tokens: [\n                        {\n                            type: \"text\",\n                            raw: text,\n                            text: text\n                        }\n                    ]\n                };\n            }\n        }\n        inlineText(src) {\n            const cap = this.rules.inline.text.exec(src);\n            if (cap) {\n                let text;\n                if (this.lexer.state.inRawBlock) text = cap[0];\n                else text = escape$1(cap[0]);\n                return {\n                    type: \"text\",\n                    raw: cap[0],\n                    text: text\n                };\n            }\n        }\n    }\n    /**\n     * Block-Level Grammar\n     */ const newline = /^(?: *(?:\\n|$))+/;\n    const blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\n    const fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n    const hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n    const heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n    const bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n    const lheading = edit(/^(?!bull )((?:.|\\n(?!\\s*?\\n|bull ))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/).replace(/bull/g, bullet) // lists can interrupt\n    .getRegex();\n    const _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n    const blockText = /^[^\\n]+/;\n    const _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n    const def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/).replace(\"label\", _blockLabel).replace(\"title\", /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\n    const list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\n    const _tag = \"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul\";\n    const _comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\n    const html = edit(\"^ {0,3}(?:<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)|comment[^\\\\n]*(\\\\n+|$)|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$))\", \"i\").replace(\"comment\", _comment).replace(\"tag\", _tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n    const paragraph = edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n    .replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n    .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\n    const blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\", paragraph).getRegex();\n    /**\n     * Normal Block Grammar\n     */ const blockNormal = {\n        blockquote: blockquote,\n        code: blockCode,\n        def: def,\n        fences: fences,\n        heading: heading,\n        hr: hr,\n        html: html,\n        lheading: lheading,\n        list: list,\n        newline: newline,\n        paragraph: paragraph,\n        table: noopTest,\n        text: blockText\n    };\n    /**\n     * GFM Block Grammar\n     */ const gfmTable = edit(\"^ *([^\\\\n ].*)\\\\n {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\") // Cells\n    .replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n    .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\n    const blockGfm = {\n        ...blockNormal,\n        table: gfmTable,\n        paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n        .replace(\"table\", gfmTable) // interrupt paragraphs with table\n        .replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n        .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex()\n    };\n    /**\n     * Pedantic grammar (original John Gruber's loose markdown specification)\n     */ const blockPedantic = {\n        ...blockNormal,\n        html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", _comment).replace(/tag/g, \"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: noopTest,\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", lheading).replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").replace(\"|tag\", \"\").getRegex()\n    };\n    /**\n     * Inline-Level Grammar\n     */ const escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n    const inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n    const br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n    const inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n    // list of unicode punctuation marks, plus any missing characters from CommonMark spec\n    const _punctuation = \"\\\\p{P}$+<=>`^|~\";\n    const punctuation = edit(/^((?![*_])[\\spunctuation])/, \"u\").replace(/punctuation/g, _punctuation).getRegex();\n    // sequences em should skip over [title](link), `code`, <html>\n    const blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\n    const emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, \"u\").replace(/punct/g, _punctuation).getRegex();\n    const emStrongRDelimAst = edit(\"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])\", \"gu\") // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation).getRegex();\n    // (6) Not allowed for _\n    const emStrongRDelimUnd = edit(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\\\s]|$)|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])|[\\\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])\", \"gu\") // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation).getRegex();\n    const anyPunctuation = edit(/\\\\([punct])/, \"gu\").replace(/punct/g, _punctuation).getRegex();\n    const autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\n    const _inlineComment = edit(_comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\n    const tag = edit(\"^comment|^</[a-zA-Z][\\\\w:-]*\\\\s*>|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>|^<\\\\?[\\\\s\\\\S]*?\\\\?>|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\") // CDATA section\n    .replace(\"comment\", _inlineComment).replace(\"attribute\", /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\n    const _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n    const link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/).replace(\"label\", _inlineLabel).replace(\"href\", /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/).replace(\"title\", /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\n    const reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\", _inlineLabel).replace(\"ref\", _blockLabel).getRegex();\n    const nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\", _blockLabel).getRegex();\n    const reflinkSearch = edit(\"reflink|nolink(?!\\\\()\", \"g\").replace(\"reflink\", reflink).replace(\"nolink\", nolink).getRegex();\n    /**\n     * Normal Inline Grammar\n     */ const inlineNormal = {\n        _backpedal: noopTest,\n        anyPunctuation: anyPunctuation,\n        autolink: autolink,\n        blockSkip: blockSkip,\n        br: br,\n        code: inlineCode,\n        del: noopTest,\n        emStrongLDelim: emStrongLDelim,\n        emStrongRDelimAst: emStrongRDelimAst,\n        emStrongRDelimUnd: emStrongRDelimUnd,\n        escape: escape,\n        link: link,\n        nolink: nolink,\n        punctuation: punctuation,\n        reflink: reflink,\n        reflinkSearch: reflinkSearch,\n        tag: tag,\n        text: inlineText,\n        url: noopTest\n    };\n    /**\n     * Pedantic Inline Grammar\n     */ const inlinePedantic = {\n        ...inlineNormal,\n        link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", _inlineLabel).getRegex(),\n        reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", _inlineLabel).getRegex()\n    };\n    /**\n     * GFM Inline Grammar\n     */ const inlineGfm = {\n        ...inlineNormal,\n        escape: edit(escape).replace(\"])\", \"~|])\").getRegex(),\n        url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, \"i\").replace(\"email\", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n        _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n    };\n    /**\n     * GFM + Line Breaks Inline Grammar\n     */ const inlineBreaks = {\n        ...inlineGfm,\n        br: edit(br).replace(\"{2,}\", \"*\").getRegex(),\n        text: edit(inlineGfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n    };\n    /**\n     * exports\n     */ const block = {\n        normal: blockNormal,\n        gfm: blockGfm,\n        pedantic: blockPedantic\n    };\n    const inline = {\n        normal: inlineNormal,\n        gfm: inlineGfm,\n        breaks: inlineBreaks,\n        pedantic: inlinePedantic\n    };\n    /**\n     * Block Lexer\n     */ class _Lexer {\n        tokens;\n        options;\n        state;\n        tokenizer;\n        inlineQueue;\n        constructor(options){\n            // TokenList cannot be created in one go\n            this.tokens = [];\n            this.tokens.links = Object.create(null);\n            this.options = options || exports1.defaults;\n            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n            this.tokenizer = this.options.tokenizer;\n            this.tokenizer.options = this.options;\n            this.tokenizer.lexer = this;\n            this.inlineQueue = [];\n            this.state = {\n                inLink: false,\n                inRawBlock: false,\n                top: true\n            };\n            const rules = {\n                block: block.normal,\n                inline: inline.normal\n            };\n            if (this.options.pedantic) {\n                rules.block = block.pedantic;\n                rules.inline = inline.pedantic;\n            } else if (this.options.gfm) {\n                rules.block = block.gfm;\n                if (this.options.breaks) rules.inline = inline.breaks;\n                else rules.inline = inline.gfm;\n            }\n            this.tokenizer.rules = rules;\n        }\n        /**\n         * Expose Rules\n         */ static get rules() {\n            return {\n                block: block,\n                inline: inline\n            };\n        }\n        /**\n         * Static Lex Method\n         */ static lex(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.lex(src);\n        }\n        /**\n         * Static Lex Inline Method\n         */ static lexInline(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.inlineTokens(src);\n        }\n        /**\n         * Preprocessing\n         */ lex(src) {\n            src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n            this.blockTokens(src, this.tokens);\n            let next;\n            while(next = this.inlineQueue.shift())this.inlineTokens(next.src, next.tokens);\n            return this.tokens;\n        }\n        blockTokens(src, tokens = []) {\n            if (this.options.pedantic) src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n            else src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs)=>{\n                return leading + \"    \".repeat(tabs.length);\n            });\n            let token;\n            let lastToken;\n            let cutSrc;\n            let lastParagraphClipped;\n            while(src){\n                if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer)=>{\n                    if (token = extTokenizer.call({\n                        lexer: this\n                    }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) continue;\n                // newline\n                if (token = this.tokenizer.space(src)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.length === 1 && tokens.length > 0) // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                    else tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.code(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    // An indented code block cannot interrupt a paragraph.\n                    if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.text;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // fences\n                if (token = this.tokenizer.fences(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // heading\n                if (token = this.tokenizer.heading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // hr\n                if (token = this.tokenizer.hr(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // blockquote\n                if (token = this.tokenizer.blockquote(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // list\n                if (token = this.tokenizer.list(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // html\n                if (token = this.tokenizer.html(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // def\n                if (token = this.tokenizer.def(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.raw;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else if (!this.tokens.links[token.tag]) this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                    continue;\n                }\n                // table (gfm)\n                if (token = this.tokenizer.table(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // lheading\n                if (token = this.tokenizer.lheading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // top-level paragraph\n                // prevent paragraph consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startBlock) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === \"number\" && tempStart >= 0) startIndex = Math.min(startIndex, tempStart);\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) cutSrc = src.substring(0, startIndex + 1);\n                }\n                if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastParagraphClipped && lastToken.type === \"paragraph\") {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else tokens.push(token);\n                    lastParagraphClipped = cutSrc.length !== src.length;\n                    src = src.substring(token.raw.length);\n                    continue;\n                }\n                // text\n                if (token = this.tokenizer.text(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === \"text\") {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                if (src) {\n                    const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    } else throw new Error(errMsg);\n                }\n            }\n            this.state.top = true;\n            return tokens;\n        }\n        inline(src, tokens = []) {\n            this.inlineQueue.push({\n                src: src,\n                tokens: tokens\n            });\n            return tokens;\n        }\n        /**\n         * Lexing/Compiling\n         */ inlineTokens(src, tokens = []) {\n            let token, lastToken, cutSrc;\n            // String with links masked to avoid interference with em and strong\n            let maskedSrc = src;\n            let match;\n            let keepPrevChar, prevChar;\n            // Mask out reflinks\n            if (this.tokens.links) {\n                const links = Object.keys(this.tokens.links);\n                if (links.length > 0) {\n                    while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null)if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                }\n            }\n            // Mask out other blocks\n            while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null)maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n            // Mask out escaped characters\n            while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null)maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n            while(src){\n                if (!keepPrevChar) prevChar = \"\";\n                keepPrevChar = false;\n                // extensions\n                if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer)=>{\n                    if (token = extTokenizer.call({\n                        lexer: this\n                    }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) continue;\n                // escape\n                if (token = this.tokenizer.escape(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // tag\n                if (token = this.tokenizer.tag(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // link\n                if (token = this.tokenizer.link(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // reflink, nolink\n                if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // em & strong\n                if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.codespan(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // br\n                if (token = this.tokenizer.br(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // del (gfm)\n                if (token = this.tokenizer.del(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // autolink\n                if (token = this.tokenizer.autolink(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // url (gfm)\n                if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // text\n                // prevent inlineText consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startInline) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startInline.forEach((getStartIndex)=>{\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === \"number\" && tempStart >= 0) startIndex = Math.min(startIndex, tempStart);\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) cutSrc = src.substring(0, startIndex + 1);\n                }\n                if (token = this.tokenizer.inlineText(cutSrc)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.slice(-1) !== \"_\") prevChar = token.raw.slice(-1);\n                    keepPrevChar = true;\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === \"text\") {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                if (src) {\n                    const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    } else throw new Error(errMsg);\n                }\n            }\n            return tokens;\n        }\n    }\n    /**\n     * Renderer\n     */ class _Renderer {\n        options;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        code(code, infostring, escaped) {\n            const lang = (infostring || \"\").match(/^\\S*/)?.[0];\n            code = code.replace(/\\n$/, \"\") + \"\\n\";\n            if (!lang) return \"<pre><code>\" + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n            return '<pre><code class=\"language-' + escape$1(lang) + '\">' + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n        }\n        blockquote(quote) {\n            return `<blockquote>\\n${quote}</blockquote>\\n`;\n        }\n        html(html, block) {\n            return html;\n        }\n        heading(text, level, raw) {\n            // ignore IDs\n            return `<h${level}>${text}</h${level}>\\n`;\n        }\n        hr() {\n            return \"<hr>\\n\";\n        }\n        list(body, ordered, start) {\n            const type = ordered ? \"ol\" : \"ul\";\n            const startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n            return \"<\" + type + startatt + \">\\n\" + body + \"</\" + type + \">\\n\";\n        }\n        listitem(text, task, checked) {\n            return `<li>${text}</li>\\n`;\n        }\n        checkbox(checked) {\n            return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n        }\n        paragraph(text) {\n            return `<p>${text}</p>\\n`;\n        }\n        table(header, body) {\n            if (body) body = `<tbody>${body}</tbody>`;\n            return \"<table>\\n<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n        }\n        tablerow(content) {\n            return `<tr>\\n${content}</tr>\\n`;\n        }\n        tablecell(content, flags) {\n            const type = flags.header ? \"th\" : \"td\";\n            const tag = flags.align ? `<${type} align=\"${flags.align}\">` : `<${type}>`;\n            return tag + content + `</${type}>\\n`;\n        }\n        /**\n         * span level renderer\n         */ strong(text) {\n            return `<strong>${text}</strong>`;\n        }\n        em(text) {\n            return `<em>${text}</em>`;\n        }\n        codespan(text) {\n            return `<code>${text}</code>`;\n        }\n        br() {\n            return \"<br>\";\n        }\n        del(text) {\n            return `<del>${text}</del>`;\n        }\n        link(href, title, text) {\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) return text;\n            href = cleanHref;\n            let out = '<a href=\"' + href + '\"';\n            if (title) out += ' title=\"' + title + '\"';\n            out += \">\" + text + \"</a>\";\n            return out;\n        }\n        image(href, title, text) {\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) return text;\n            href = cleanHref;\n            let out = `<img src=\"${href}\" alt=\"${text}\"`;\n            if (title) out += ` title=\"${title}\"`;\n            out += \">\";\n            return out;\n        }\n        text(text) {\n            return text;\n        }\n    }\n    /**\n     * TextRenderer\n     * returns only the textual part of the token\n     */ class _TextRenderer {\n        // no need for block level renderers\n        strong(text) {\n            return text;\n        }\n        em(text) {\n            return text;\n        }\n        codespan(text) {\n            return text;\n        }\n        del(text) {\n            return text;\n        }\n        html(text) {\n            return text;\n        }\n        text(text) {\n            return text;\n        }\n        link(href, title, text) {\n            return \"\" + text;\n        }\n        image(href, title, text) {\n            return \"\" + text;\n        }\n        br() {\n            return \"\";\n        }\n    }\n    /**\n     * Parsing & Compiling\n     */ class _Parser {\n        options;\n        renderer;\n        textRenderer;\n        constructor(options){\n            this.options = options || exports1.defaults;\n            this.options.renderer = this.options.renderer || new _Renderer();\n            this.renderer = this.options.renderer;\n            this.renderer.options = this.options;\n            this.textRenderer = new _TextRenderer();\n        }\n        /**\n         * Static Parse Method\n         */ static parse(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parse(tokens);\n        }\n        /**\n         * Static Parse Inline Method\n         */ static parseInline(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parseInline(tokens);\n        }\n        /**\n         * Parse Loop\n         */ parse(tokens, top = true) {\n            let out = \"\";\n            for(let i = 0; i < tokens.length; i++){\n                const token = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                    const genericToken = token;\n                    const ret = this.options.extensions.renderers[genericToken.type].call({\n                        parser: this\n                    }, genericToken);\n                    if (ret !== false || ![\n                        \"space\",\n                        \"hr\",\n                        \"heading\",\n                        \"code\",\n                        \"table\",\n                        \"blockquote\",\n                        \"list\",\n                        \"html\",\n                        \"paragraph\",\n                        \"text\"\n                    ].includes(genericToken.type)) {\n                        out += ret || \"\";\n                        continue;\n                    }\n                }\n                switch(token.type){\n                    case \"space\":\n                        continue;\n                    case \"hr\":\n                        out += this.renderer.hr();\n                        continue;\n                    case \"heading\":\n                        {\n                            const headingToken = token;\n                            out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));\n                            continue;\n                        }\n                    case \"code\":\n                        {\n                            const codeToken = token;\n                            out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                            continue;\n                        }\n                    case \"table\":\n                        {\n                            const tableToken = token;\n                            let header = \"\";\n                            // header\n                            let cell = \"\";\n                            for(let j = 0; j < tableToken.header.length; j++)cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), {\n                                header: true,\n                                align: tableToken.align[j]\n                            });\n                            header += this.renderer.tablerow(cell);\n                            let body = \"\";\n                            for(let j = 0; j < tableToken.rows.length; j++){\n                                const row = tableToken.rows[j];\n                                cell = \"\";\n                                for(let k = 0; k < row.length; k++)cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                                    header: false,\n                                    align: tableToken.align[k]\n                                });\n                                body += this.renderer.tablerow(cell);\n                            }\n                            out += this.renderer.table(header, body);\n                            continue;\n                        }\n                    case \"blockquote\":\n                        {\n                            const blockquoteToken = token;\n                            const body = this.parse(blockquoteToken.tokens);\n                            out += this.renderer.blockquote(body);\n                            continue;\n                        }\n                    case \"list\":\n                        {\n                            const listToken = token;\n                            const ordered = listToken.ordered;\n                            const start = listToken.start;\n                            const loose = listToken.loose;\n                            let body = \"\";\n                            for(let j = 0; j < listToken.items.length; j++){\n                                const item = listToken.items[j];\n                                const checked = item.checked;\n                                const task = item.task;\n                                let itemBody = \"\";\n                                if (item.task) {\n                                    const checkbox = this.renderer.checkbox(!!checked);\n                                    if (loose) {\n                                        if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                                            item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                                            if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                                        } else item.tokens.unshift({\n                                            type: \"text\",\n                                            text: checkbox + \" \"\n                                        });\n                                    } else itemBody += checkbox + \" \";\n                                }\n                                itemBody += this.parse(item.tokens, loose);\n                                body += this.renderer.listitem(itemBody, task, !!checked);\n                            }\n                            out += this.renderer.list(body, ordered, start);\n                            continue;\n                        }\n                    case \"html\":\n                        {\n                            const htmlToken = token;\n                            out += this.renderer.html(htmlToken.text, htmlToken.block);\n                            continue;\n                        }\n                    case \"paragraph\":\n                        {\n                            const paragraphToken = token;\n                            out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                            continue;\n                        }\n                    case \"text\":\n                        {\n                            let textToken = token;\n                            let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                            while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                                textToken = tokens[++i];\n                                body += \"\\n\" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                            }\n                            out += top ? this.renderer.paragraph(body) : body;\n                            continue;\n                        }\n                    default:\n                        {\n                            const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                            if (this.options.silent) {\n                                console.error(errMsg);\n                                return \"\";\n                            } else throw new Error(errMsg);\n                        }\n                }\n            }\n            return out;\n        }\n        /**\n         * Parse Inline Tokens\n         */ parseInline(tokens, renderer) {\n            renderer = renderer || this.renderer;\n            let out = \"\";\n            for(let i = 0; i < tokens.length; i++){\n                const token = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                    const ret = this.options.extensions.renderers[token.type].call({\n                        parser: this\n                    }, token);\n                    if (ret !== false || ![\n                        \"escape\",\n                        \"html\",\n                        \"link\",\n                        \"image\",\n                        \"strong\",\n                        \"em\",\n                        \"codespan\",\n                        \"br\",\n                        \"del\",\n                        \"text\"\n                    ].includes(token.type)) {\n                        out += ret || \"\";\n                        continue;\n                    }\n                }\n                switch(token.type){\n                    case \"escape\":\n                        {\n                            const escapeToken = token;\n                            out += renderer.text(escapeToken.text);\n                            break;\n                        }\n                    case \"html\":\n                        {\n                            const tagToken = token;\n                            out += renderer.html(tagToken.text);\n                            break;\n                        }\n                    case \"link\":\n                        {\n                            const linkToken = token;\n                            out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                            break;\n                        }\n                    case \"image\":\n                        {\n                            const imageToken = token;\n                            out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                            break;\n                        }\n                    case \"strong\":\n                        {\n                            const strongToken = token;\n                            out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                            break;\n                        }\n                    case \"em\":\n                        {\n                            const emToken = token;\n                            out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                            break;\n                        }\n                    case \"codespan\":\n                        {\n                            const codespanToken = token;\n                            out += renderer.codespan(codespanToken.text);\n                            break;\n                        }\n                    case \"br\":\n                        out += renderer.br();\n                        break;\n                    case \"del\":\n                        {\n                            const delToken = token;\n                            out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                            break;\n                        }\n                    case \"text\":\n                        {\n                            const textToken = token;\n                            out += renderer.text(textToken.text);\n                            break;\n                        }\n                    default:\n                        {\n                            const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                            if (this.options.silent) {\n                                console.error(errMsg);\n                                return \"\";\n                            } else throw new Error(errMsg);\n                        }\n                }\n            }\n            return out;\n        }\n    }\n    class _Hooks {\n        options;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        static passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\"\n        ]);\n        /**\n         * Process markdown before marked\n         */ preprocess(markdown) {\n            return markdown;\n        }\n        /**\n         * Process HTML after marked is finished\n         */ postprocess(html) {\n            return html;\n        }\n    }\n    class Marked {\n        defaults = _getDefaults();\n        options = this.setOptions;\n        parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n        parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n        Parser = _Parser;\n        Renderer = _Renderer;\n        TextRenderer = _TextRenderer;\n        Lexer = _Lexer;\n        Tokenizer = _Tokenizer;\n        Hooks = _Hooks;\n        constructor(...args){\n            this.use(...args);\n        }\n        /**\n         * Run callback for every token\n         */ walkTokens(tokens, callback) {\n            let values = [];\n            for (const token of tokens){\n                values = values.concat(callback.call(this, token));\n                switch(token.type){\n                    case \"table\":\n                        {\n                            const tableToken = token;\n                            for (const cell of tableToken.header)values = values.concat(this.walkTokens(cell.tokens, callback));\n                            for (const row of tableToken.rows)for (const cell of row)values = values.concat(this.walkTokens(cell.tokens, callback));\n                            break;\n                        }\n                    case \"list\":\n                        {\n                            const listToken = token;\n                            values = values.concat(this.walkTokens(listToken.items, callback));\n                            break;\n                        }\n                    default:\n                        {\n                            const genericToken = token;\n                            if (this.defaults.extensions?.childTokens?.[genericToken.type]) this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                values = values.concat(this.walkTokens(genericToken[childTokens], callback));\n                            });\n                            else if (genericToken.tokens) values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                }\n            }\n            return values;\n        }\n        use(...args) {\n            const extensions = this.defaults.extensions || {\n                renderers: {},\n                childTokens: {}\n            };\n            args.forEach((pack)=>{\n                // copy options to new object\n                const opts = {\n                    ...pack\n                };\n                // set async to true if it was set to true before\n                opts.async = this.defaults.async || opts.async || false;\n                // ==-- Parse \"addon\" extensions --== //\n                if (pack.extensions) {\n                    pack.extensions.forEach((ext)=>{\n                        if (!ext.name) throw new Error(\"extension name required\");\n                        if (\"renderer\" in ext) {\n                            const prevRenderer = extensions.renderers[ext.name];\n                            if (prevRenderer) // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) ret = prevRenderer.apply(this, args);\n                                return ret;\n                            };\n                            else extensions.renderers[ext.name] = ext.renderer;\n                        }\n                        if (\"tokenizer\" in ext) {\n                            if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") throw new Error(\"extension level must be 'block' or 'inline'\");\n                            const extLevel = extensions[ext.level];\n                            if (extLevel) extLevel.unshift(ext.tokenizer);\n                            else extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                            if (ext.start) {\n                                if (ext.level === \"block\") {\n                                    if (extensions.startBlock) extensions.startBlock.push(ext.start);\n                                    else extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                } else if (ext.level === \"inline\") {\n                                    if (extensions.startInline) extensions.startInline.push(ext.start);\n                                    else extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                        if (\"childTokens\" in ext && ext.childTokens) extensions.childTokens[ext.name] = ext.childTokens;\n                    });\n                    opts.extensions = extensions;\n                }\n                // ==-- Parse \"overwrite\" extensions --== //\n                if (pack.renderer) {\n                    const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                    for(const prop in pack.renderer){\n                        if (!(prop in renderer) || prop === \"options\") throw new Error(`renderer '${prop}' does not exist`);\n                        const rendererProp = prop;\n                        const rendererFunc = pack.renderer[rendererProp];\n                        const prevRenderer = renderer[rendererProp];\n                        // Replace renderer with func to run extension, but fall back if false\n                        renderer[rendererProp] = (...args)=>{\n                            let ret = rendererFunc.apply(renderer, args);\n                            if (ret === false) ret = prevRenderer.apply(renderer, args);\n                            return ret || \"\";\n                        };\n                    }\n                    opts.renderer = renderer;\n                }\n                if (pack.tokenizer) {\n                    const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                    for(const prop in pack.tokenizer){\n                        if (!(prop in tokenizer) || [\n                            \"options\",\n                            \"rules\",\n                            \"lexer\"\n                        ].includes(prop)) throw new Error(`tokenizer '${prop}' does not exist`);\n                        const tokenizerProp = prop;\n                        const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                        const prevTokenizer = tokenizer[tokenizerProp];\n                        // Replace tokenizer with func to run extension, but fall back if false\n                        // @ts-expect-error cannot type tokenizer function dynamically\n                        tokenizer[tokenizerProp] = (...args)=>{\n                            let ret = tokenizerFunc.apply(tokenizer, args);\n                            if (ret === false) ret = prevTokenizer.apply(tokenizer, args);\n                            return ret;\n                        };\n                    }\n                    opts.tokenizer = tokenizer;\n                }\n                // ==-- Parse Hooks extensions --== //\n                if (pack.hooks) {\n                    const hooks = this.defaults.hooks || new _Hooks();\n                    for(const prop in pack.hooks){\n                        if (!(prop in hooks) || prop === \"options\") throw new Error(`hook '${prop}' does not exist`);\n                        const hooksProp = prop;\n                        const hooksFunc = pack.hooks[hooksProp];\n                        const prevHook = hooks[hooksProp];\n                        if (_Hooks.passThroughHooks.has(prop)) hooks[hooksProp] = (arg)=>{\n                            if (this.defaults.async) return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                return prevHook.call(hooks, ret);\n                            });\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                        else hooks[hooksProp] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) ret = prevHook.apply(hooks, args);\n                            return ret;\n                        };\n                    }\n                    opts.hooks = hooks;\n                }\n                // ==-- Parse WalkTokens extensions --== //\n                if (pack.walkTokens) {\n                    const walkTokens = this.defaults.walkTokens;\n                    const packWalktokens = pack.walkTokens;\n                    opts.walkTokens = function(token) {\n                        let values = [];\n                        values.push(packWalktokens.call(this, token));\n                        if (walkTokens) values = values.concat(walkTokens.call(this, token));\n                        return values;\n                    };\n                }\n                this.defaults = {\n                    ...this.defaults,\n                    ...opts\n                };\n            });\n            return this;\n        }\n        setOptions(opt) {\n            this.defaults = {\n                ...this.defaults,\n                ...opt\n            };\n            return this;\n        }\n        lexer(src, options) {\n            return _Lexer.lex(src, options ?? this.defaults);\n        }\n        parser(tokens, options) {\n            return _Parser.parse(tokens, options ?? this.defaults);\n        }\n        #parseMarkdown(lexer, parser) {\n            return (src, options)=>{\n                const origOpt = {\n                    ...options\n                };\n                const opt = {\n                    ...this.defaults,\n                    ...origOpt\n                };\n                // Show warning if an extension set async to true but the parse was called with async: false\n                if (this.defaults.async === true && origOpt.async === false) {\n                    if (!opt.silent) console.warn(\"marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.\");\n                    opt.async = true;\n                }\n                const throwError = this.#onError(!!opt.silent, !!opt.async);\n                // throw error in case of non string input\n                if (typeof src === \"undefined\" || src === null) return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n                if (typeof src !== \"string\") return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n                if (opt.hooks) opt.hooks.options = opt;\n                if (opt.async) return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n                try {\n                    if (opt.hooks) src = opt.hooks.preprocess(src);\n                    const tokens = lexer(src, opt);\n                    if (opt.walkTokens) this.walkTokens(tokens, opt.walkTokens);\n                    let html = parser(tokens, opt);\n                    if (opt.hooks) html = opt.hooks.postprocess(html);\n                    return html;\n                } catch (e) {\n                    return throwError(e);\n                }\n            };\n        }\n        #onError(silent, async) {\n            return (e)=>{\n                e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n                if (silent) {\n                    const msg = \"<p>An error occurred:</p><pre>\" + escape$1(e.message + \"\", true) + \"</pre>\";\n                    if (async) return Promise.resolve(msg);\n                    return msg;\n                }\n                if (async) return Promise.reject(e);\n                throw e;\n            };\n        }\n    }\n    const markedInstance = new Marked();\n    function marked(src, opt) {\n        return markedInstance.parse(src, opt);\n    }\n    /**\n     * Sets the default options.\n     *\n     * @param options Hash of options\n     */ marked.options = marked.setOptions = function(options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Gets the original marked default options.\n     */ marked.getDefaults = _getDefaults;\n    marked.defaults = exports1.defaults;\n    /**\n     * Use Extension\n     */ marked.use = function(...args) {\n        markedInstance.use(...args);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Run callback for every token\n     */ marked.walkTokens = function(tokens, callback) {\n        return markedInstance.walkTokens(tokens, callback);\n    };\n    /**\n     * Compiles markdown to HTML without enclosing `p` tag.\n     *\n     * @param src String of markdown source to be compiled\n     * @param options Hash of options\n     * @return String of compiled HTML\n     */ marked.parseInline = markedInstance.parseInline;\n    /**\n     * Expose\n     */ marked.Parser = _Parser;\n    marked.parser = _Parser.parse;\n    marked.Renderer = _Renderer;\n    marked.TextRenderer = _TextRenderer;\n    marked.Lexer = _Lexer;\n    marked.lexer = _Lexer.lex;\n    marked.Tokenizer = _Tokenizer;\n    marked.Hooks = _Hooks;\n    marked.parse = marked;\n    const options = marked.options;\n    const setOptions = marked.setOptions;\n    const use = marked.use;\n    const walkTokens = marked.walkTokens;\n    const parseInline = marked.parseInline;\n    const parse = marked;\n    const parser = _Parser.parse;\n    const lexer = _Lexer.lex;\n    exports1.Hooks = _Hooks;\n    exports1.Lexer = _Lexer;\n    exports1.Marked = Marked;\n    exports1.Parser = _Parser;\n    exports1.Renderer = _Renderer;\n    exports1.TextRenderer = _TextRenderer;\n    exports1.Tokenizer = _Tokenizer;\n    exports1.getDefaults = _getDefaults;\n    exports1.lexer = lexer;\n    exports1.marked = marked;\n    exports1.options = options;\n    exports1.parse = parse;\n    exports1.parseInline = parseInline;\n    exports1.parser = parser;\n    exports1.setOptions = setOptions;\n    exports1.use = use;\n    exports1.walkTokens = walkTokens;\n});\n\n\n\n\nconst $35da740d59af89ba$var$input_b64 = document.querySelector(\"#input_b64\");\nconst $35da740d59af89ba$var$input_md = document.querySelector(\"#input_md\");\nconst $35da740d59af89ba$var$output = document.querySelector(\"#output\");\n$35da740d59af89ba$var$input_b64.addEventListener(\"input\", (ev)=>{\n    const b64 = ev.currentTarget.value;\n    const ascii = atob(b64);\n    const parsed = (0, $d24e0eeb5f66fbc4$exports.marked).parse(ascii);\n    const sanitized = (0, $f123004b8678fd03$exports.sanitize)(parsed);\n    $35da740d59af89ba$var$output.innerHTML = sanitized;\n});\n$35da740d59af89ba$var$input_md.addEventListener(\"input\", (ev)=>{\n    const parsed = (0, $d24e0eeb5f66fbc4$exports.marked).parse(ev.currentTarget.value);\n    const sanitized = (0, $f123004b8678fd03$exports.sanitize)(parsed);\n    $35da740d59af89ba$var$output.innerHTML = sanitized;\n});\n\n\n//# sourceMappingURL=index.c3c3648a.js.map\n","import { sanitize } from \"dompurify\";\nimport { marked } from \"marked\";\n\n// Load css\nimport \"github-markdown-css\";\nimport \"./index.css\";\n\nconst input_b64 = document.querySelector(\"#input_b64\");\nconst input_md = document.querySelector(\"#input_md\");\nconst output = document.querySelector(\"#output\");\n\ninput_b64.addEventListener(\"input\", (ev) => {\n  const b64 = ev.currentTarget.value;\n  const ascii = atob(b64);\n  const parsed = marked.parse(ascii);\n  const sanitized = sanitize(parsed);\n\n  output.innerHTML = sanitized;\n});\n\ninput_md.addEventListener(\"input\", (ev) => {\n  const parsed = marked.parse(ev.currentTarget.value);\n  const sanitized = sanitize(parsed);\n\n  output.innerHTML = sanitized;\n});\n","/*! @license DOMPurify 3.0.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.6/LICENSE */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.DOMPurify = factory());\n})(this, (function () { 'use strict';\n\n  const {\n    entries,\n    setPrototypeOf,\n    isFrozen,\n    getPrototypeOf,\n    getOwnPropertyDescriptor\n  } = Object;\n  let {\n    freeze,\n    seal,\n    create\n  } = Object; // eslint-disable-line import/no-mutable-exports\n\n  let {\n    apply,\n    construct\n  } = typeof Reflect !== 'undefined' && Reflect;\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new Func(...args);\n    };\n  }\n\n  const arrayForEach = unapply(Array.prototype.forEach);\n  const arrayPop = unapply(Array.prototype.pop);\n  const arrayPush = unapply(Array.prototype.push);\n  const stringToLowerCase = unapply(String.prototype.toLowerCase);\n  const stringToString = unapply(String.prototype.toString);\n  const stringMatch = unapply(String.prototype.match);\n  const stringReplace = unapply(String.prototype.replace);\n  const stringIndexOf = unapply(String.prototype.indexOf);\n  const stringTrim = unapply(String.prototype.trim);\n  const regExpTest = unapply(RegExp.prototype.test);\n  const typeErrorCreate = unconstruct(TypeError);\n  /**\n   * Creates a new function that calls the given function with a specified thisArg and arguments.\n   *\n   * @param {Function} func - The function to be wrapped and called.\n   * @returns {Function} A new function that calls the given function with a specified thisArg and arguments.\n   */\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n  /**\n   * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n   *\n   * @param {Function} func - The constructor function to be wrapped and called.\n   * @returns {Function} A new function that constructs an instance of the given constructor function with the provided arguments.\n   */\n\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n  /**\n   * Add properties to a lookup table\n   *\n   * @param {Object} set - The set to which elements will be added.\n   * @param {Array} array - The array containing elements to be added to the set.\n   * @param {Function} transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n   * @returns {Object} The modified set with added elements.\n   */\n\n\n  function addToSet(set, array) {\n    let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    let l = array.length;\n\n    while (l--) {\n      let element = array[l];\n\n      if (typeof element === 'string') {\n        const lcElement = transformCaseFunc(element);\n\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n  /**\n   * Shallow clone an object\n   *\n   * @param {Object} object - The object to be cloned.\n   * @returns {Object} A new object that copies the original.\n   */\n\n\n  function clone(object) {\n    const newObject = create(null);\n\n    for (const [property, value] of entries(object)) {\n      if (getOwnPropertyDescriptor(object, property) !== undefined) {\n        newObject[property] = value;\n      }\n    }\n\n    return newObject;\n  }\n  /**\n   * This method automatically checks if the prop is function or getter and behaves accordingly.\n   *\n   * @param {Object} object - The object to look up the getter function in its prototype chain.\n   * @param {String} prop - The property name for which to find the getter function.\n   * @returns {Function} The getter function found in the prototype chain or a fallback function.\n   */\n\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      const desc = getOwnPropertyDescriptor(object, prop);\n\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG\n\n  const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n  const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n\n  const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n  const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']); // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n\n  const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n  const text = freeze(['#text']);\n\n  const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n  const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n  const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n  const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n\n  const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n  const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n  const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n\n  const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n\n  const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n  const DOCTYPE_NAME = seal(/^html$/i);\n\n  var EXPRESSIONS = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    ERB_EXPR: ERB_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR,\n    DATA_ATTR: DATA_ATTR,\n    ARIA_ATTR: ARIA_ATTR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    DOCTYPE_NAME: DOCTYPE_NAME\n  });\n\n  const getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported or creating the policy failed).\n   */\n\n\n  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    } // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n\n\n    let suffix = null;\n    const ATTR_NAME = 'data-tt-policy-suffix';\n\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n      suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n\n    const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML(html) {\n          return html;\n        },\n\n        createScriptURL(scriptUrl) {\n          return scriptUrl;\n        }\n\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    const DOMPurify = root => createDOMPurify(root);\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n\n\n    DOMPurify.version = '3.0.6';\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n      return DOMPurify;\n    }\n\n    let {\n      document\n    } = window;\n    const originalDocument = document;\n    const currentScript = originalDocument.currentScript;\n    const {\n      DocumentFragment,\n      HTMLTemplateElement,\n      Node,\n      Element,\n      NodeFilter,\n      NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n      HTMLFormElement,\n      DOMParser,\n      trustedTypes\n    } = window;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    const getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n\n    if (typeof HTMLTemplateElement === 'function') {\n      const template = document.createElement('template');\n\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    let trustedTypesPolicy;\n    let emptyHTML = '';\n    const {\n      implementation,\n      createNodeIterator,\n      createDocumentFragment,\n      getElementsByTagName\n    } = document;\n    const {\n      importNode\n    } = originalDocument;\n    let hooks = {};\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n\n    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n    const {\n      MUSTACHE_EXPR,\n      ERB_EXPR,\n      TMPLIT_EXPR,\n      DATA_ATTR,\n      ARIA_ATTR,\n      IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE\n    } = EXPRESSIONS;\n    let {\n      IS_ALLOWED_URI: IS_ALLOWED_URI$1\n    } = EXPRESSIONS;\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);\n    /* Allowed attribute names */\n\n    let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);\n    /*\n     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.\n     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n     */\n\n    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false\n      }\n    }));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n\n    let FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n\n    let FORBID_ATTR = null;\n    /* Decide if ARIA attributes are okay */\n\n    let ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */\n\n    let ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */\n\n    let ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Decide if self-closing tags in attributes are allowed.\n     * Usually removed due to a mXSS issue in jQuery 3.0 */\n\n    let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n\n    let SAFE_FOR_TEMPLATES = false;\n    /* Decide if document with <html>... should be returned */\n\n    let WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */\n\n    let SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n\n    let FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n\n    let RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n\n    let RETURN_DOM_FRAGMENT = false;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n\n    let RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks?\n     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n     */\n\n    let SANITIZE_DOM = true;\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n     *\n     * HTML/DOM spec rules that enable DOM Clobbering:\n     *   - Named Access on Window (§7.3.3)\n     *   - DOM Tree Accessors (§3.1.5)\n     *   - Form Element Parent-Child Relations (§4.10.3)\n     *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n     *   - HTMLCollection (§4.2.10.2)\n     *\n     * Namespace isolation is implemented by prefixing `id` and `name` attributes\n     * with a constant string, i.e., `user-content-`\n     */\n\n    let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n    /* Keep element content when removing element? */\n\n    let KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n\n    let IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */\n\n    let USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n\n    let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n    /* Tags that are safe for data: URIs */\n\n    let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n    /* Attributes safe for values like \"javascript:\" */\n\n    let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n    const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n\n    let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    /* Allowed XHTML+XML namespaces */\n\n    let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n    /* Parsing of strict XHTML documents */\n\n    let PARSER_MEDIA_TYPE = null;\n    const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    let transformCaseFunc = null;\n    /* Keep a reference to config to pass to hooks */\n\n    let CONFIG = null;\n    /* Ideally, do not touch anything below this line */\n\n    /* ______________________________________________ */\n\n    const formElement = document.createElement('form');\n\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n      return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n\n\n    const _parseConfig = function _parseConfig() {\n      let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n      /* Shield configuration object from tampering */\n\n\n      if (!cfg || typeof cfg !== 'object') {\n        cfg = {};\n      }\n      /* Shield configuration object from prototype pollution */\n\n\n      cfg = clone(cfg);\n      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n      /* Set configuration parameters */\n\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n      ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent\n      cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent\n      transformCaseFunc // eslint-disable-line indent\n      ) // eslint-disable-line indent\n      : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent\n      cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent\n      transformCaseFunc // eslint-disable-line indent\n      ) // eslint-disable-line indent\n      : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n\n      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n\n      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n\n      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n      }\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n      }\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n      }\n\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n      /* Parse profile info */\n\n\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [...text]);\n        ALLOWED_ATTR = [];\n\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html$1);\n          addToSet(ALLOWED_ATTR, html);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg$1);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl$1);\n          addToSet(ALLOWED_ATTR, mathMl);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n      /* Merge configuration parameters */\n\n\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n      }\n\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n      }\n      /* Add #text in case KEEP_CONTENT is set to true */\n\n\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n\n\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n\n\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      if (cfg.TRUSTED_TYPES_POLICY) {\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n        }\n\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n        } // Overwrite existing TrustedTypes policy.\n\n\n        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY; // Sign local variables required by `sanitize`.\n\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      } else {\n        // Uninitialized policy, attempt to initialize the internal dompurify policy.\n        if (trustedTypesPolicy === undefined) {\n          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n        } // If creating the internal policy succeeded sign internal variables.\n\n\n        if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        }\n      } // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n\n\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n    const HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n\n    const ALL_SVG_TAGS = addToSet({}, svg$1);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n    const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n    /**\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n\n    const _checkValidNamespace = function _checkValidNamespace(element) {\n      let parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      const tagName = stringToLowerCase(element.tagName);\n      const parentTagName = stringToLowerCase(parent.tagName);\n\n      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return false;\n      }\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        } // The only way to switch from MathML to SVG is via`\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n\n\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        } // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n\n\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        } // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n\n\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        } // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n\n\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        } // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n\n\n        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n      } // For XHTML and XML documents that support custom namespaces\n\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return true;\n      } // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n      // Return false just in case.\n\n\n      return false;\n    };\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n\n\n    const _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, {\n        element: node\n      });\n\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        node.remove();\n      }\n    };\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n\n\n    const _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name); // We void attribute values for unremovable \"is\"\" attributes\n\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n\n\n    const _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      let doc = null;\n      let leadingWhitespace = null;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n\n      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n      /* Use createHTMLDocument in case DOMParser is not available */\n\n\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n        } catch (_) {// Syntax error if dirtyPayload is invalid xml\n        }\n      }\n\n      const body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n      /* Work on whole document or just its body */\n\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n     * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n     *\n     * @param  {Node} root The root element or node to start traversing on.\n     * @return {NodeIterator} The created NodeIterator\n     */\n\n\n    const _createNodeIterator = function _createNodeIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null);\n    };\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n\n\n    const _isClobbered = function _isClobbered(elm) {\n      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n    };\n    /**\n     * Checks whether the given object is a DOM node.\n     *\n     * @param  {Node} object object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n\n\n    const _isNode = function _isNode(object) {\n      return typeof Node === 'function' && object instanceof Node;\n    };\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n\n\n    const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], hook => {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n\n\n    const _sanitizeElements = function _sanitizeElements(currentNode) {\n      let content = null;\n      /* Execute a hook if present */\n\n      _executeHook('beforeSanitizeElements', currentNode, null);\n      /* Check if element is clobbered or can clobber */\n\n\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Now let's check the element's type and name */\n\n\n      const tagName = transformCaseFunc(currentNode.nodeName);\n      /* Execute a hook if present */\n\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n      /* Detect mXSS attempts abusing namespace confusion */\n\n\n      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Remove element if anything forbids its presence */\n\n\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Check if we have a custom element to handle */\n        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n            return false;\n          }\n\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n            return false;\n          }\n        }\n        /* Keep content except for bad-listed elements */\n\n\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            const childCount = childNodes.length;\n\n            for (let i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Check whether element has a valid namespace */\n\n\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Make sure that older browsers don't get fallback-tag mXSS */\n\n\n      if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Sanitize element content to be template-safe */\n\n\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n          content = stringReplace(content, expr, ' ');\n        });\n\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, {\n            element: currentNode.cloneNode()\n          });\n          currentNode.textContent = content;\n        }\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n\n\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n\n\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {\n          return false;\n        }\n        /* Check value is safe. First, is attr inert? If so, is safe */\n\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {\n        return false;\n      } else ;\n\n      return true;\n    };\n    /**\n     * _isBasicCustomElement\n     * checks if at least one dash is included in tagName, and it's not the first char\n     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n     *\n     * @param {string} tagName name of the tag of the node to sanitize\n     * @returns {boolean} Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n     */\n\n\n    const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n      return tagName.indexOf('-') > 0;\n    };\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n\n\n    const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      const {\n        attributes\n      } = currentNode;\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      const hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      let l = attributes.length;\n      /* Go backwards over all attributes; safely remove bad ones */\n\n      while (l--) {\n        const attr = attributes[l];\n        const {\n          name,\n          namespaceURI,\n          value: attrValue\n        } = attr;\n        const lcName = transformCaseFunc(name);\n        let value = name === 'value' ? attrValue : stringTrim(attrValue);\n        /* Execute a hook if present */\n\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n        /* Remove attribute */\n\n\n        _removeAttribute(name, currentNode);\n        /* Did the hooks approve of the attribute? */\n\n\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n        /* Work around a security issue in jQuery 3.0 */\n\n\n        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n        /* Sanitize attribute content to be template-safe */\n\n\n        if (SAFE_FOR_TEMPLATES) {\n          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n            value = stringReplace(value, expr, ' ');\n          });\n        }\n        /* Is `value` valid for this attribute? */\n\n\n        const lcTag = transformCaseFunc(currentNode.nodeName);\n\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n        /* Full DOM Clobbering protection via namespace isolation,\n         * Prefix id and name attributes with `user-content-`\n         */\n\n\n        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n          // Remove the attribute with this value\n          _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value\n\n\n          value = SANITIZE_NAMED_PROPS_PREFIX + value;\n        }\n        /* Handle attributes that require Trusted Types */\n\n\n        if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n          if (namespaceURI) ; else {\n            switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML':\n                {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n\n              case 'TrustedScriptURL':\n                {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n            }\n          }\n        }\n        /* Handle invalid data-* attribute set by try-catching it */\n\n\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n\n\n    const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      let shadowNode = null;\n\n      const shadowIterator = _createNodeIterator(fragment);\n      /* Execute a hook if present */\n\n\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n        /* Sanitize tags and elements */\n\n\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n        /* Deep shadow DOM detected */\n\n\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n        /* Check attributes, sanitize if necessary */\n\n\n        _sanitizeAttributes(shadowNode);\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} cfg object\n     */\n    // eslint-disable-next-line complexity\n\n\n    DOMPurify.sanitize = function (dirty) {\n      let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let body = null;\n      let importedNode = null;\n      let currentNode = null;\n      let returnNode = null;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n\n      IS_EMPTY_INPUT = !dirty;\n\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n      /* Stringify, in case dirty is an object */\n\n\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        if (typeof dirty.toString === 'function') {\n          dirty = dirty.toString();\n\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        } else {\n          throw typeErrorCreate('toString is not a function');\n        }\n      }\n      /* Return dirty HTML if DOMPurify cannot run */\n\n\n      if (!DOMPurify.isSupported) {\n        return dirty;\n      }\n      /* Assign config vars */\n\n\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n      /* Clean up removed elements */\n\n\n      DOMPurify.removed = [];\n      /* Check if dirty is correctly typed for IN_PLACE */\n\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) {\n        /* Do some early pre-sanitization to avoid unsafe root nodes */\n        if (dirty.nodeName) {\n          const tagName = transformCaseFunc(dirty.nodeName);\n\n          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n          }\n        }\n      } else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n        /* Initialize the document to work on */\n\n\n        body = _initDocument(dirty);\n        /* Check we have a DOM node from the data */\n\n        if (!body) {\n          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n        }\n      }\n      /* Remove first element node (ours) if FORCE_BODY is set */\n\n\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n      /* Get node iterator */\n\n\n      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n      /* Now start iterating over the created document */\n\n\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n        /* Shadow DOM detected, sanitize it */\n\n\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n        /* Check attributes, sanitize if necessary */\n\n\n        _sanitizeAttributes(currentNode);\n      }\n      /* If we sanitized `dirty` in-place, return it. */\n\n\n      if (IN_PLACE) {\n        return dirty;\n      }\n      /* Return sanitized string or DOM */\n\n\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n      /* Serialize doctype if allowed */\n\n      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n      }\n      /* Sanitize final string template-safe */\n\n\n      if (SAFE_FOR_TEMPLATES) {\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n          serializedHTML = stringReplace(serializedHTML, expr, ' ');\n        });\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n\n\n    DOMPurify.setConfig = function () {\n      let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _parseConfig(cfg);\n\n      SET_CONFIG = true;\n    };\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n\n\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {String} tag Tag name of containing element.\n     * @param  {String} attr Attribute name.\n     * @param  {String} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n\n\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      const lcTag = transformCaseFunc(tag);\n      const lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n\n\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     * @return {Function} removed(popped) hook\n     */\n\n\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        return arrayPop(hooks[entryPoint]);\n      }\n    };\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n\n\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     */\n\n\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n","const {\n  entries,\n  setPrototypeOf,\n  isFrozen,\n  getPrototypeOf,\n  getOwnPropertyDescriptor,\n} = Object;\n\nlet { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports\nlet { apply, construct } = typeof Reflect !== 'undefined' && Reflect;\n\nif (!freeze) {\n  freeze = function (x) {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function (x) {\n    return x;\n  };\n}\n\nif (!apply) {\n  apply = function (fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\nif (!construct) {\n  construct = function (Func, args) {\n    return new Func(...args);\n  };\n}\n\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayIndexOf = unapply(Array.prototype.indexOf);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst arraySlice = unapply(Array.prototype.slice);\n\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\n\nconst regExpTest = unapply(RegExp.prototype.test);\n\nconst typeErrorCreate = unconstruct(TypeError);\n\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param {Function} func - The function to be wrapped and called.\n * @returns {Function} A new function that calls the given function with a specified thisArg and arguments.\n */\nfunction unapply(func) {\n  return (thisArg, ...args) => apply(func, thisArg, args);\n}\n\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param {Function} func - The constructor function to be wrapped and called.\n * @returns {Function} A new function that constructs an instance of the given constructor function with the provided arguments.\n */\nfunction unconstruct(func) {\n  return (...args) => construct(func, args);\n}\n\n/**\n * Add properties to a lookup table\n *\n * @param {Object} set - The set to which elements will be added.\n * @param {Array} array - The array containing elements to be added to the set.\n * @param {Function} transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns {Object} The modified set with added elements.\n */\nfunction addToSet(set, array, transformCaseFunc = stringToLowerCase) {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  let l = array.length;\n  while (l--) {\n    let element = array[l];\n    if (typeof element === 'string') {\n      const lcElement = transformCaseFunc(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/**\n * Shallow clone an object\n *\n * @param {Object} object - The object to be cloned.\n * @returns {Object} A new object that copies the original.\n */\nexport function clone(object) {\n  const newObject = create(null);\n\n  for (const [property, value] of entries(object)) {\n    if (getOwnPropertyDescriptor(object, property) !== undefined) {\n      newObject[property] = value;\n    }\n  }\n\n  return newObject;\n}\n\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param {Object} object - The object to look up the getter function in its prototype chain.\n * @param {String} prop - The property name for which to find the getter function.\n * @returns {Function} The getter function found in the prototype chain or a fallback function.\n */\nfunction lookupGetter(object, prop) {\n  while (object !== null) {\n    const desc = getOwnPropertyDescriptor(object, prop);\n\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n\n      if (typeof desc.value === 'function') {\n        return unapply(desc.value);\n      }\n    }\n\n    object = getPrototypeOf(object);\n  }\n\n  function fallbackValue(element) {\n    console.warn('fallback value for', element);\n    return null;\n  }\n\n  return fallbackValue;\n}\n\nexport {\n  // Array\n  arrayForEach,\n  arrayIndexOf,\n  arrayPop,\n  arrayPush,\n  arraySlice,\n  // Object\n  entries,\n  freeze,\n  getPrototypeOf,\n  getOwnPropertyDescriptor,\n  isFrozen,\n  setPrototypeOf,\n  seal,\n  create,\n  // RegExp\n  regExpTest,\n  // String\n  stringIndexOf,\n  stringMatch,\n  stringReplace,\n  stringToLowerCase,\n  stringToString,\n  stringTrim,\n  // Errors\n  typeErrorCreate,\n  // Other\n  lookupGetter,\n  addToSet,\n  // Reflect\n  unapply,\n  unconstruct,\n};\n","import { freeze } from './utils.js';\n\nexport const html = freeze([\n  'a',\n  'abbr',\n  'acronym',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'bdi',\n  'bdo',\n  'big',\n  'blink',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'center',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'content',\n  'data',\n  'datalist',\n  'dd',\n  'decorator',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'element',\n  'em',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'font',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'label',\n  'legend',\n  'li',\n  'main',\n  'map',\n  'mark',\n  'marquee',\n  'menu',\n  'menuitem',\n  'meter',\n  'nav',\n  'nobr',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'section',\n  'select',\n  'shadow',\n  'small',\n  'source',\n  'spacer',\n  'span',\n  'strike',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'template',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'tr',\n  'track',\n  'tt',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n]);\n\n// SVG\nexport const svg = freeze([\n  'svg',\n  'a',\n  'altglyph',\n  'altglyphdef',\n  'altglyphitem',\n  'animatecolor',\n  'animatemotion',\n  'animatetransform',\n  'circle',\n  'clippath',\n  'defs',\n  'desc',\n  'ellipse',\n  'filter',\n  'font',\n  'g',\n  'glyph',\n  'glyphref',\n  'hkern',\n  'image',\n  'line',\n  'lineargradient',\n  'marker',\n  'mask',\n  'metadata',\n  'mpath',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'radialgradient',\n  'rect',\n  'stop',\n  'style',\n  'switch',\n  'symbol',\n  'text',\n  'textpath',\n  'title',\n  'tref',\n  'tspan',\n  'view',\n  'vkern',\n]);\n\nexport const svgFilters = freeze([\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n]);\n\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nexport const svgDisallowed = freeze([\n  'animate',\n  'color-profile',\n  'cursor',\n  'discard',\n  'font-face',\n  'font-face-format',\n  'font-face-name',\n  'font-face-src',\n  'font-face-uri',\n  'foreignobject',\n  'hatch',\n  'hatchpath',\n  'mesh',\n  'meshgradient',\n  'meshpatch',\n  'meshrow',\n  'missing-glyph',\n  'script',\n  'set',\n  'solidcolor',\n  'unknown',\n  'use',\n]);\n\nexport const mathMl = freeze([\n  'math',\n  'menclose',\n  'merror',\n  'mfenced',\n  'mfrac',\n  'mglyph',\n  'mi',\n  'mlabeledtr',\n  'mmultiscripts',\n  'mn',\n  'mo',\n  'mover',\n  'mpadded',\n  'mphantom',\n  'mroot',\n  'mrow',\n  'ms',\n  'mspace',\n  'msqrt',\n  'mstyle',\n  'msub',\n  'msup',\n  'msubsup',\n  'mtable',\n  'mtd',\n  'mtext',\n  'mtr',\n  'munder',\n  'munderover',\n  'mprescripts',\n]);\n\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nexport const mathMlDisallowed = freeze([\n  'maction',\n  'maligngroup',\n  'malignmark',\n  'mlongdiv',\n  'mscarries',\n  'mscarry',\n  'msgroup',\n  'mstack',\n  'msline',\n  'msrow',\n  'semantics',\n  'annotation',\n  'annotation-xml',\n  'mprescripts',\n  'none',\n]);\n\nexport const text = freeze(['#text']);\n","import { freeze } from './utils.js';\n\nexport const html = freeze([\n  'accept',\n  'action',\n  'align',\n  'alt',\n  'autocapitalize',\n  'autocomplete',\n  'autopictureinpicture',\n  'autoplay',\n  'background',\n  'bgcolor',\n  'border',\n  'capture',\n  'cellpadding',\n  'cellspacing',\n  'checked',\n  'cite',\n  'class',\n  'clear',\n  'color',\n  'cols',\n  'colspan',\n  'controls',\n  'controlslist',\n  'coords',\n  'crossorigin',\n  'datetime',\n  'decoding',\n  'default',\n  'dir',\n  'disabled',\n  'disablepictureinpicture',\n  'disableremoteplayback',\n  'download',\n  'draggable',\n  'enctype',\n  'enterkeyhint',\n  'face',\n  'for',\n  'headers',\n  'height',\n  'hidden',\n  'high',\n  'href',\n  'hreflang',\n  'id',\n  'inputmode',\n  'integrity',\n  'ismap',\n  'kind',\n  'label',\n  'lang',\n  'list',\n  'loading',\n  'loop',\n  'low',\n  'max',\n  'maxlength',\n  'media',\n  'method',\n  'min',\n  'minlength',\n  'multiple',\n  'muted',\n  'name',\n  'nonce',\n  'noshade',\n  'novalidate',\n  'nowrap',\n  'open',\n  'optimum',\n  'pattern',\n  'placeholder',\n  'playsinline',\n  'poster',\n  'preload',\n  'pubdate',\n  'radiogroup',\n  'readonly',\n  'rel',\n  'required',\n  'rev',\n  'reversed',\n  'role',\n  'rows',\n  'rowspan',\n  'spellcheck',\n  'scope',\n  'selected',\n  'shape',\n  'size',\n  'sizes',\n  'span',\n  'srclang',\n  'start',\n  'src',\n  'srcset',\n  'step',\n  'style',\n  'summary',\n  'tabindex',\n  'title',\n  'translate',\n  'type',\n  'usemap',\n  'valign',\n  'value',\n  'width',\n  'xmlns',\n  'slot',\n]);\n\nexport const svg = freeze([\n  'accent-height',\n  'accumulate',\n  'additive',\n  'alignment-baseline',\n  'ascent',\n  'attributename',\n  'attributetype',\n  'azimuth',\n  'basefrequency',\n  'baseline-shift',\n  'begin',\n  'bias',\n  'by',\n  'class',\n  'clip',\n  'clippathunits',\n  'clip-path',\n  'clip-rule',\n  'color',\n  'color-interpolation',\n  'color-interpolation-filters',\n  'color-profile',\n  'color-rendering',\n  'cx',\n  'cy',\n  'd',\n  'dx',\n  'dy',\n  'diffuseconstant',\n  'direction',\n  'display',\n  'divisor',\n  'dur',\n  'edgemode',\n  'elevation',\n  'end',\n  'fill',\n  'fill-opacity',\n  'fill-rule',\n  'filter',\n  'filterunits',\n  'flood-color',\n  'flood-opacity',\n  'font-family',\n  'font-size',\n  'font-size-adjust',\n  'font-stretch',\n  'font-style',\n  'font-variant',\n  'font-weight',\n  'fx',\n  'fy',\n  'g1',\n  'g2',\n  'glyph-name',\n  'glyphref',\n  'gradientunits',\n  'gradienttransform',\n  'height',\n  'href',\n  'id',\n  'image-rendering',\n  'in',\n  'in2',\n  'k',\n  'k1',\n  'k2',\n  'k3',\n  'k4',\n  'kerning',\n  'keypoints',\n  'keysplines',\n  'keytimes',\n  'lang',\n  'lengthadjust',\n  'letter-spacing',\n  'kernelmatrix',\n  'kernelunitlength',\n  'lighting-color',\n  'local',\n  'marker-end',\n  'marker-mid',\n  'marker-start',\n  'markerheight',\n  'markerunits',\n  'markerwidth',\n  'maskcontentunits',\n  'maskunits',\n  'max',\n  'mask',\n  'media',\n  'method',\n  'mode',\n  'min',\n  'name',\n  'numoctaves',\n  'offset',\n  'operator',\n  'opacity',\n  'order',\n  'orient',\n  'orientation',\n  'origin',\n  'overflow',\n  'paint-order',\n  'path',\n  'pathlength',\n  'patterncontentunits',\n  'patterntransform',\n  'patternunits',\n  'points',\n  'preservealpha',\n  'preserveaspectratio',\n  'primitiveunits',\n  'r',\n  'rx',\n  'ry',\n  'radius',\n  'refx',\n  'refy',\n  'repeatcount',\n  'repeatdur',\n  'restart',\n  'result',\n  'rotate',\n  'scale',\n  'seed',\n  'shape-rendering',\n  'specularconstant',\n  'specularexponent',\n  'spreadmethod',\n  'startoffset',\n  'stddeviation',\n  'stitchtiles',\n  'stop-color',\n  'stop-opacity',\n  'stroke-dasharray',\n  'stroke-dashoffset',\n  'stroke-linecap',\n  'stroke-linejoin',\n  'stroke-miterlimit',\n  'stroke-opacity',\n  'stroke',\n  'stroke-width',\n  'style',\n  'surfacescale',\n  'systemlanguage',\n  'tabindex',\n  'targetx',\n  'targety',\n  'transform',\n  'transform-origin',\n  'text-anchor',\n  'text-decoration',\n  'text-rendering',\n  'textlength',\n  'type',\n  'u1',\n  'u2',\n  'unicode',\n  'values',\n  'viewbox',\n  'visibility',\n  'version',\n  'vert-adv-y',\n  'vert-origin-x',\n  'vert-origin-y',\n  'width',\n  'word-spacing',\n  'wrap',\n  'writing-mode',\n  'xchannelselector',\n  'ychannelselector',\n  'x',\n  'x1',\n  'x2',\n  'xmlns',\n  'y',\n  'y1',\n  'y2',\n  'z',\n  'zoomandpan',\n]);\n\nexport const mathMl = freeze([\n  'accent',\n  'accentunder',\n  'align',\n  'bevelled',\n  'close',\n  'columnsalign',\n  'columnlines',\n  'columnspan',\n  'denomalign',\n  'depth',\n  'dir',\n  'display',\n  'displaystyle',\n  'encoding',\n  'fence',\n  'frame',\n  'height',\n  'href',\n  'id',\n  'largeop',\n  'length',\n  'linethickness',\n  'lspace',\n  'lquote',\n  'mathbackground',\n  'mathcolor',\n  'mathsize',\n  'mathvariant',\n  'maxsize',\n  'minsize',\n  'movablelimits',\n  'notation',\n  'numalign',\n  'open',\n  'rowalign',\n  'rowlines',\n  'rowspacing',\n  'rowspan',\n  'rspace',\n  'rquote',\n  'scriptlevel',\n  'scriptminsize',\n  'scriptsizemultiplier',\n  'selection',\n  'separator',\n  'separators',\n  'stretchy',\n  'subscriptshift',\n  'supscriptshift',\n  'symmetric',\n  'voffset',\n  'width',\n  'xmlns',\n]);\n\nexport const xml = freeze([\n  'xlink:href',\n  'xml:id',\n  'xlink:title',\n  'xml:space',\n  'xmlns:xlink',\n]);\n","import { seal } from './utils.js';\n\n// eslint-disable-next-line unicorn/better-regex\nexport const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nexport const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nexport const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\nexport const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nexport const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nexport const IS_ALLOWED_URI = seal(\n  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nexport const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nexport const ATTR_WHITESPACE = seal(\n  /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nexport const DOCTYPE_NAME = seal(/^html$/i);\n","import * as TAGS from './tags.js';\nimport * as ATTRS from './attrs.js';\nimport * as EXPRESSIONS from './regexp.js';\nimport {\n  addToSet,\n  clone,\n  entries,\n  freeze,\n  arrayForEach,\n  arrayPop,\n  arrayPush,\n  stringMatch,\n  stringReplace,\n  stringToLowerCase,\n  stringToString,\n  stringIndexOf,\n  stringTrim,\n  regExpTest,\n  typeErrorCreate,\n  lookupGetter,\n  create,\n} from './utils.js';\n\nconst getGlobal = function () {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */\nconst _createTrustedTypesPolicy = function (trustedTypes, purifyHostElement) {\n  if (\n    typeof trustedTypes !== 'object' ||\n    typeof trustedTypes.createPolicy !== 'function'\n  ) {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  let suffix = null;\n  const ATTR_NAME = 'data-tt-policy-suffix';\n  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n    suffix = purifyHostElement.getAttribute(ATTR_NAME);\n  }\n\n  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML(html) {\n        return html;\n      },\n      createScriptURL(scriptUrl) {\n        return scriptUrl;\n      },\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn(\n      'TrustedTypes policy ' + policyName + ' could not be created.'\n    );\n    return null;\n  }\n};\n\nfunction createDOMPurify(window = getGlobal()) {\n  const DOMPurify = (root) => createDOMPurify(root);\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = VERSION;\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  let { document } = window;\n\n  const originalDocument = document;\n  const currentScript = originalDocument.currentScript;\n  const {\n    DocumentFragment,\n    HTMLTemplateElement,\n    Node,\n    Element,\n    NodeFilter,\n    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n    HTMLFormElement,\n    DOMParser,\n    trustedTypes,\n  } = window;\n\n  const ElementPrototype = Element.prototype;\n\n  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    const template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  let trustedTypesPolicy;\n  let emptyHTML = '';\n\n  const {\n    implementation,\n    createNodeIterator,\n    createDocumentFragment,\n    getElementsByTagName,\n  } = document;\n  const { importNode } = originalDocument;\n\n  let hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported =\n    typeof entries === 'function' &&\n    typeof getParentNode === 'function' &&\n    implementation &&\n    implementation.createHTMLDocument !== undefined;\n\n  const {\n    MUSTACHE_EXPR,\n    ERB_EXPR,\n    TMPLIT_EXPR,\n    DATA_ATTR,\n    ARIA_ATTR,\n    IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE,\n  } = EXPRESSIONS;\n\n  let { IS_ALLOWED_URI } = EXPRESSIONS;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n  let ALLOWED_TAGS = null;\n  const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n    ...TAGS.html,\n    ...TAGS.svg,\n    ...TAGS.svgFilters,\n    ...TAGS.mathMl,\n    ...TAGS.text,\n  ]);\n\n  /* Allowed attribute names */\n  let ALLOWED_ATTR = null;\n  const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n    ...ATTRS.html,\n    ...ATTRS.svg,\n    ...ATTRS.mathMl,\n    ...ATTRS.xml,\n  ]);\n\n  /*\n   * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */\n  let CUSTOM_ELEMENT_HANDLING = Object.seal(\n    create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false,\n      },\n    })\n  );\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  let FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  let FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  let ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  let ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  let ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */\n  let ALLOW_SELF_CLOSE_IN_ATTR = true;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  let SAFE_FOR_TEMPLATES = false;\n\n  /* Decide if document with <html>... should be returned */\n  let WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  let SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  let FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  let RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  let RETURN_DOM_FRAGMENT = false;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  let RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */\n  let SANITIZE_DOM = true;\n\n  /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (§7.3.3)\n   *   - DOM Tree Accessors (§3.1.5)\n   *   - Form Element Parent-Child Relations (§4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n   *   - HTMLCollection (§4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */\n  let SANITIZE_NAMED_PROPS = false;\n  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n\n  /* Keep element content when removing element? */\n  let KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  let IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  let USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  let FORBID_CONTENTS = null;\n  const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n    'annotation-xml',\n    'audio',\n    'colgroup',\n    'desc',\n    'foreignobject',\n    'head',\n    'iframe',\n    'math',\n    'mi',\n    'mn',\n    'mo',\n    'ms',\n    'mtext',\n    'noembed',\n    'noframes',\n    'noscript',\n    'plaintext',\n    'script',\n    'style',\n    'svg',\n    'template',\n    'thead',\n    'title',\n    'video',\n    'xmp',\n  ]);\n\n  /* Tags that are safe for data: URIs */\n  let DATA_URI_TAGS = null;\n  const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n    'audio',\n    'video',\n    'img',\n    'source',\n    'image',\n    'track',\n  ]);\n\n  /* Attributes safe for values like \"javascript:\" */\n  let URI_SAFE_ATTRIBUTES = null;\n  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n    'alt',\n    'class',\n    'for',\n    'id',\n    'label',\n    'name',\n    'pattern',\n    'placeholder',\n    'role',\n    'summary',\n    'title',\n    'value',\n    'style',\n    'xmlns',\n  ]);\n\n  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  /* Document namespace */\n  let NAMESPACE = HTML_NAMESPACE;\n  let IS_EMPTY_INPUT = false;\n\n  /* Allowed XHTML+XML namespaces */\n  let ALLOWED_NAMESPACES = null;\n  const DEFAULT_ALLOWED_NAMESPACES = addToSet(\n    {},\n    [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE],\n    stringToString\n  );\n\n  /* Parsing of strict XHTML documents */\n  let PARSER_MEDIA_TYPE = null;\n  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n  let transformCaseFunc = null;\n\n  /* Keep a reference to config to pass to hooks */\n  let CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  const formElement = document.createElement('form');\n\n  const isRegexOrFunction = function (testValue) {\n    return testValue instanceof RegExp || testValue instanceof Function;\n  };\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  const _parseConfig = function (cfg = {}) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || typeof cfg !== 'object') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n\n    PARSER_MEDIA_TYPE =\n      // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1\n        ? (PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE)\n        : (PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE);\n\n    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n    transformCaseFunc =\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml'\n        ? stringToString\n        : stringToLowerCase;\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS =\n      'ALLOWED_TAGS' in cfg\n        ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc)\n        : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR =\n      'ALLOWED_ATTR' in cfg\n        ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc)\n        : DEFAULT_ALLOWED_ATTR;\n    ALLOWED_NAMESPACES =\n      'ALLOWED_NAMESPACES' in cfg\n        ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString)\n        : DEFAULT_ALLOWED_NAMESPACES;\n    URI_SAFE_ATTRIBUTES =\n      'ADD_URI_SAFE_ATTR' in cfg\n        ? addToSet(\n            clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent\n            cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent\n            transformCaseFunc // eslint-disable-line indent\n          ) // eslint-disable-line indent\n        : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS =\n      'ADD_DATA_URI_TAGS' in cfg\n        ? addToSet(\n            clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent\n            cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent\n            transformCaseFunc // eslint-disable-line indent\n          ) // eslint-disable-line indent\n        : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS =\n      'FORBID_CONTENTS' in cfg\n        ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc)\n        : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS =\n      'FORBID_TAGS' in cfg\n        ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc)\n        : {};\n    FORBID_ATTR =\n      'FORBID_ATTR' in cfg\n        ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc)\n        : {};\n    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI = cfg.ALLOWED_URI_REGEXP || EXPRESSIONS.IS_ALLOWED_URI;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)\n    ) {\n      CUSTOM_ELEMENT_HANDLING.tagNameCheck =\n        cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n    }\n\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)\n    ) {\n      CUSTOM_ELEMENT_HANDLING.attributeNameCheck =\n        cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n    }\n\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements ===\n        'boolean'\n    ) {\n      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements =\n        cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n    }\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [...TAGS.text]);\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, TAGS.html);\n        addToSet(ALLOWED_ATTR, ATTRS.html);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, TAGS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, TAGS.svgFilters);\n        addToSet(ALLOWED_ATTR, ATTRS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, TAGS.mathMl);\n        addToSet(ALLOWED_ATTR, ATTRS.mathMl);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n    }\n\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    if (cfg.TRUSTED_TYPES_POLICY) {\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n        throw typeErrorCreate(\n          'TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.'\n        );\n      }\n\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n        throw typeErrorCreate(\n          'TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.'\n        );\n      }\n\n      // Overwrite existing TrustedTypes policy.\n      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n\n      // Sign local variables required by `sanitize`.\n      emptyHTML = trustedTypesPolicy.createHTML('');\n    } else {\n      // Uninitialized policy, attempt to initialize the internal dompurify policy.\n      if (trustedTypesPolicy === undefined) {\n        trustedTypesPolicy = _createTrustedTypesPolicy(\n          trustedTypes,\n          currentScript\n        );\n      }\n\n      // If creating the internal policy succeeded sign internal variables.\n      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      }\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n    'mi',\n    'mo',\n    'mn',\n    'ms',\n    'mtext',\n  ]);\n\n  const HTML_INTEGRATION_POINTS = addToSet({}, [\n    'foreignobject',\n    'desc',\n    'title',\n    'annotation-xml',\n  ]);\n\n  // Certain elements are allowed in both SVG and HTML\n  // namespace. We need to specify them explicitly\n  // so that they don't get erroneously deleted from\n  // HTML namespace.\n  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n    'title',\n    'style',\n    'font',\n    'a',\n    'script',\n  ]);\n\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  const ALL_SVG_TAGS = addToSet({}, TAGS.svg);\n  addToSet(ALL_SVG_TAGS, TAGS.svgFilters);\n  addToSet(ALL_SVG_TAGS, TAGS.svgDisallowed);\n\n  const ALL_MATHML_TAGS = addToSet({}, TAGS.mathMl);\n  addToSet(ALL_MATHML_TAGS, TAGS.mathMlDisallowed);\n\n  /**\n   * @param  {Element} element a DOM element whose namespace is being checked\n   * @returns {boolean} Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  const _checkValidNamespace = function (element) {\n    let parent = getParentNode(element);\n\n    // In JSDOM, if we're inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: NAMESPACE,\n        tagName: 'template',\n      };\n    }\n\n    const tagName = stringToLowerCase(element.tagName);\n    const parentTagName = stringToLowerCase(parent.tagName);\n\n    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n      return false;\n    }\n\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'svg';\n      }\n\n      // The only way to switch from MathML to SVG is via`\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return (\n          tagName === 'svg' &&\n          (parentTagName === 'annotation-xml' ||\n            MATHML_TEXT_INTEGRATION_POINTS[parentTagName])\n        );\n      }\n\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'math';\n      }\n\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (\n        parent.namespaceURI === SVG_NAMESPACE &&\n        !HTML_INTEGRATION_POINTS[parentTagName]\n      ) {\n        return false;\n      }\n\n      if (\n        parent.namespaceURI === MATHML_NAMESPACE &&\n        !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]\n      ) {\n        return false;\n      }\n\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return (\n        !ALL_MATHML_TAGS[tagName] &&\n        (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName])\n      );\n    }\n\n    // For XHTML and XML documents that support custom namespaces\n    if (\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml' &&\n      ALLOWED_NAMESPACES[element.namespaceURI]\n    ) {\n      return true;\n    }\n\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n    // Return false just in case.\n    return false;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  const _forceRemove = function (node) {\n    arrayPush(DOMPurify.removed, { element: node });\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      node.parentNode.removeChild(node);\n    } catch (_) {\n      node.remove();\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  const _removeAttribute = function (name, node) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: node.getAttributeNode(name),\n        from: node,\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: node,\n      });\n    }\n\n    node.removeAttribute(name);\n\n    // We void attribute values for unremovable \"is\"\" attributes\n    if (name === 'is' && !ALLOWED_ATTR[name]) {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(node);\n        } catch (_) {}\n      } else {\n        try {\n          node.setAttribute(name, '');\n        } catch (_) {}\n      }\n    }\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  const _initDocument = function (dirty) {\n    /* Create a HTML document */\n    let doc = null;\n    let leadingWhitespace = null;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    if (\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml' &&\n      NAMESPACE === HTML_NAMESPACE\n    ) {\n      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n      dirty =\n        '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' +\n        dirty +\n        '</body></html>';\n    }\n\n    const dirtyPayload = trustedTypesPolicy\n      ? trustedTypesPolicy.createHTML(dirty)\n      : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_) {}\n    }\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, 'template', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT\n          ? emptyHTML\n          : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n\n    const body = doc.body || doc.documentElement;\n\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(\n        document.createTextNode(leadingWhitespace),\n        body.childNodes[0] || null\n      );\n    }\n\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(\n        doc,\n        WHOLE_DOCUMENT ? 'html' : 'body'\n      )[0];\n    }\n\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n\n  /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param  {Node} root The root element or node to start traversing on.\n   * @return {NodeIterator} The created NodeIterator\n   */\n  const _createNodeIterator = function (root) {\n    return createNodeIterator.call(\n      root.ownerDocument || root,\n      root,\n      // eslint-disable-next-line no-bitwise\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,\n      null\n    );\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  const _isClobbered = function (elm) {\n    return (\n      elm instanceof HTMLFormElement &&\n      (typeof elm.nodeName !== 'string' ||\n        typeof elm.textContent !== 'string' ||\n        typeof elm.removeChild !== 'function' ||\n        !(elm.attributes instanceof NamedNodeMap) ||\n        typeof elm.removeAttribute !== 'function' ||\n        typeof elm.setAttribute !== 'function' ||\n        typeof elm.namespaceURI !== 'string' ||\n        typeof elm.insertBefore !== 'function' ||\n        typeof elm.hasChildNodes !== 'function')\n    );\n  };\n\n  /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param  {Node} object object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  const _isNode = function (object) {\n    return typeof Node === 'function' && object instanceof Node;\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  const _executeHook = function (entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    arrayForEach(hooks[entryPoint], (hook) => {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  const _sanitizeElements = function (currentNode) {\n    let content = null;\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeElements', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    const tagName = transformCaseFunc(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName,\n      allowedTags: ALLOWED_TAGS,\n    });\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (\n      currentNode.hasChildNodes() &&\n      !_isNode(currentNode.firstElementChild) &&\n      regExpTest(/<[/\\w]/g, currentNode.innerHTML) &&\n      regExpTest(/<[/\\w]/g, currentNode.textContent)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Check if we have a custom element to handle */\n      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n        if (\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n          regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)\n        ) {\n          return false;\n        }\n\n        if (\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)\n        ) {\n          return false;\n        }\n      }\n\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n        if (childNodes && parentNode) {\n          const childCount = childNodes.length;\n\n          for (let i = childCount - 1; i >= 0; --i) {\n            parentNode.insertBefore(\n              cloneNode(childNodes[i], true),\n              getNextSibling(currentNode)\n            );\n          }\n        }\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Make sure that older browsers don't get fallback-tag mXSS */\n    if (\n      (tagName === 'noscript' ||\n        tagName === 'noembed' ||\n        tagName === 'noframes') &&\n      regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr) => {\n        content = stringReplace(content, expr, ' ');\n      });\n\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeElements', currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  const _isValidAttribute = function (lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (\n      SANITIZE_DOM &&\n      (lcName === 'id' || lcName === 'name') &&\n      (value in document || value in formElement)\n    ) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (\n      ALLOW_DATA_ATTR &&\n      !FORBID_ATTR[lcName] &&\n      regExpTest(DATA_ATTR, lcName)\n    ) {\n      // This attribute is safe\n    } else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) {\n      // This attribute is safe\n      /* Otherwise, check the name is permitted */\n    } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      if (\n        // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n        (_isBasicCustomElement(lcTag) &&\n          ((CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag)) ||\n            (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag))) &&\n          ((CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName)) ||\n            (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)))) ||\n        // Alternative, second condition checks if it's an `is`-attribute, AND\n        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        (lcName === 'is' &&\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements &&\n          ((CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value)) ||\n            (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))))\n      ) {\n        // If user has supplied a regexp or function in CUSTOM_ELEMENT_HANDLING.tagNameCheck, we need to also allow derived custom elements using the same tagName test.\n        // Additionally, we need to allow attributes passing the CUSTOM_ELEMENT_HANDLING.attributeNameCheck user has configured, as custom elements can define these at their own discretion.\n      } else {\n        return false;\n      }\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) {\n      // This attribute is safe\n      /* Check no script, data or unknown possibly unsafe URI\n        unless we know URI values are safe for that attribute */\n    } else if (\n      regExpTest(IS_ALLOWED_URI, stringReplace(value, ATTR_WHITESPACE, ''))\n    ) {\n      // This attribute is safe\n      /* Keep image data URIs alive if src/xlink:href is allowed */\n      /* Further prevent gadget XSS for dynamically built script tags */\n    } else if (\n      (lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') &&\n      lcTag !== 'script' &&\n      stringIndexOf(value, 'data:') === 0 &&\n      DATA_URI_TAGS[lcTag]\n    ) {\n      // This attribute is safe\n      /* Allow unknown protocols: This provides support for links that\n        are handled by protocol handlers which may be unknown ahead of\n        time, e.g. fb:, spotify: */\n    } else if (\n      ALLOW_UNKNOWN_PROTOCOLS &&\n      !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))\n    ) {\n      // This attribute is safe\n      /* Check for binary attributes */\n    } else if (value) {\n      return false;\n    } else {\n      // Binary attributes are safe at this point\n      /* Anything else, presume unsafe, do not add it back */\n    }\n\n    return true;\n  };\n\n  /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param {string} tagName name of the tag of the node to sanitize\n   * @returns {boolean} Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */\n  const _isBasicCustomElement = function (tagName) {\n    return tagName.indexOf('-') > 0;\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  const _sanitizeAttributes = function (currentNode) {\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n    const { attributes } = currentNode;\n\n    /* Check if we have attributes; if not we might have a text node */\n    if (!attributes) {\n      return;\n    }\n\n    const hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR,\n    };\n    let l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      const attr = attributes[l];\n      const { name, namespaceURI, value: attrValue } = attr;\n      const lcName = transformCaseFunc(name);\n\n      let value = name === 'value' ? attrValue : stringTrim(attrValue);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Remove attribute */\n      _removeAttribute(name, currentNode);\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr) => {\n          value = stringReplace(value, expr, ' ');\n        });\n      }\n\n      /* Is `value` valid for this attribute? */\n      const lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */\n      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n        // Remove the attribute with this value\n        _removeAttribute(name, currentNode);\n\n        // Prefix the value and later re-create the attribute with the sanitized value\n        value = SANITIZE_NAMED_PROPS_PREFIX + value;\n      }\n\n      /* Handle attributes that require Trusted Types */\n      if (\n        trustedTypesPolicy &&\n        typeof trustedTypes === 'object' &&\n        typeof trustedTypes.getAttributeType === 'function'\n      ) {\n        if (namespaceURI) {\n          /* Namespaces are not yet supported, see https://bugs.chromium.org/p/chromium/issues/detail?id=1305293 */\n        } else {\n          switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n            case 'TrustedHTML': {\n              value = trustedTypesPolicy.createHTML(value);\n              break;\n            }\n\n            case 'TrustedScriptURL': {\n              value = trustedTypesPolicy.createScriptURL(value);\n              break;\n            }\n\n            default: {\n              break;\n            }\n          }\n        }\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n\n        arrayPop(DOMPurify.removed);\n      } catch (_) {}\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  const _sanitizeShadowDOM = function (fragment) {\n    let shadowNode = null;\n    const shadowIterator = _createNodeIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n    while ((shadowNode = shadowIterator.nextNode())) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} cfg object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg = {}) {\n    let body = null;\n    let importedNode = null;\n    let currentNode = null;\n    let returnNode = null;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      if (typeof dirty.toString === 'function') {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      } else {\n        throw typeErrorCreate('toString is not a function');\n      }\n    }\n\n    /* Return dirty HTML if DOMPurify cannot run */\n    if (!DOMPurify.isSupported) {\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) {\n      /* Do some early pre-sanitization to avoid unsafe root nodes */\n      if (dirty.nodeName) {\n        const tagName = transformCaseFunc(dirty.nodeName);\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          throw typeErrorCreate(\n            'root node is forbidden and cannot be sanitized in-place'\n          );\n        }\n      }\n    } else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (\n        !RETURN_DOM &&\n        !SAFE_FOR_TEMPLATES &&\n        !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1\n      ) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE\n          ? trustedTypesPolicy.createHTML(dirty)\n          : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while ((currentNode = nodeIterator.nextNode())) {\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n    }\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Serialize doctype if allowed */\n    if (\n      WHOLE_DOCUMENT &&\n      ALLOWED_TAGS['!doctype'] &&\n      body.ownerDocument &&\n      body.ownerDocument.doctype &&\n      body.ownerDocument.doctype.name &&\n      regExpTest(EXPRESSIONS.DOCTYPE_NAME, body.ownerDocument.doctype.name)\n    ) {\n      serializedHTML =\n        '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n    }\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr) => {\n        serializedHTML = stringReplace(serializedHTML, expr, ' ');\n      });\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE\n      ? trustedTypesPolicy.createHTML(serializedHTML)\n      : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function (cfg = {}) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {String} tag Tag name of containing element.\n   * @param  {String} attr Attribute name.\n   * @param  {String} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    const lcTag = transformCaseFunc(tag);\n    const lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   * @return {Function} removed(popped) hook\n   */\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      return arrayPop(hooks[entryPoint]);\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   */\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nexport default createDOMPurify();\n","/**\n * marked v11.0.0 - a markdown parser\n * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));\n})(this, (function (exports) { 'use strict';\n\n    /**\n     * Gets the original marked default options.\n     */\n    function _getDefaults() {\n        return {\n            async: false,\n            breaks: false,\n            extensions: null,\n            gfm: true,\n            hooks: null,\n            pedantic: false,\n            renderer: null,\n            silent: false,\n            tokenizer: null,\n            walkTokens: null\n        };\n    }\n    exports.defaults = _getDefaults();\n    function changeDefaults(newDefaults) {\n        exports.defaults = newDefaults;\n    }\n\n    /**\n     * Helpers\n     */\n    const escapeTest = /[&<>\"']/;\n    const escapeReplace = new RegExp(escapeTest.source, 'g');\n    const escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\n    const escapeReplacements = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;'\n    };\n    const getEscapeReplacement = (ch) => escapeReplacements[ch];\n    function escape$1(html, encode) {\n        if (encode) {\n            if (escapeTest.test(html)) {\n                return html.replace(escapeReplace, getEscapeReplacement);\n            }\n        }\n        else {\n            if (escapeTestNoEncode.test(html)) {\n                return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n            }\n        }\n        return html;\n    }\n    const unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n    function unescape(html) {\n        // explicitly match decimal, hex, and named HTML entities\n        return html.replace(unescapeTest, (_, n) => {\n            n = n.toLowerCase();\n            if (n === 'colon')\n                return ':';\n            if (n.charAt(0) === '#') {\n                return n.charAt(1) === 'x'\n                    ? String.fromCharCode(parseInt(n.substring(2), 16))\n                    : String.fromCharCode(+n.substring(1));\n            }\n            return '';\n        });\n    }\n    const caret = /(^|[^\\[])\\^/g;\n    function edit(regex, opt) {\n        let source = typeof regex === 'string' ? regex : regex.source;\n        opt = opt || '';\n        const obj = {\n            replace: (name, val) => {\n                let valSource = typeof val === 'string' ? val : val.source;\n                valSource = valSource.replace(caret, '$1');\n                source = source.replace(name, valSource);\n                return obj;\n            },\n            getRegex: () => {\n                return new RegExp(source, opt);\n            }\n        };\n        return obj;\n    }\n    function cleanUrl(href) {\n        try {\n            href = encodeURI(href).replace(/%25/g, '%');\n        }\n        catch (e) {\n            return null;\n        }\n        return href;\n    }\n    const noopTest = { exec: () => null };\n    function splitCells(tableRow, count) {\n        // ensure that every cell-delimiting pipe has a space\n        // before it to distinguish it from an escaped pipe\n        const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n            let escaped = false;\n            let curr = offset;\n            while (--curr >= 0 && str[curr] === '\\\\')\n                escaped = !escaped;\n            if (escaped) {\n                // odd number of slashes means | is escaped\n                // so we leave it alone\n                return '|';\n            }\n            else {\n                // add space before unescaped |\n                return ' |';\n            }\n        }), cells = row.split(/ \\|/);\n        let i = 0;\n        // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n        if (!cells[0].trim()) {\n            cells.shift();\n        }\n        if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n            cells.pop();\n        }\n        if (count) {\n            if (cells.length > count) {\n                cells.splice(count);\n            }\n            else {\n                while (cells.length < count)\n                    cells.push('');\n            }\n        }\n        for (; i < cells.length; i++) {\n            // leading or trailing whitespace is ignored per the gfm spec\n            cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n        }\n        return cells;\n    }\n    /**\n     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n     * /c*$/ is vulnerable to REDOS.\n     *\n     * @param str\n     * @param c\n     * @param invert Remove suffix of non-c chars instead. Default falsey.\n     */\n    function rtrim(str, c, invert) {\n        const l = str.length;\n        if (l === 0) {\n            return '';\n        }\n        // Length of suffix matching the invert condition.\n        let suffLen = 0;\n        // Step left until we fail to match the invert condition.\n        while (suffLen < l) {\n            const currChar = str.charAt(l - suffLen - 1);\n            if (currChar === c && !invert) {\n                suffLen++;\n            }\n            else if (currChar !== c && invert) {\n                suffLen++;\n            }\n            else {\n                break;\n            }\n        }\n        return str.slice(0, l - suffLen);\n    }\n    function findClosingBracket(str, b) {\n        if (str.indexOf(b[1]) === -1) {\n            return -1;\n        }\n        let level = 0;\n        for (let i = 0; i < str.length; i++) {\n            if (str[i] === '\\\\') {\n                i++;\n            }\n            else if (str[i] === b[0]) {\n                level++;\n            }\n            else if (str[i] === b[1]) {\n                level--;\n                if (level < 0) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    function outputLink(cap, link, raw, lexer) {\n        const href = link.href;\n        const title = link.title ? escape$1(link.title) : null;\n        const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n        if (cap[0].charAt(0) !== '!') {\n            lexer.state.inLink = true;\n            const token = {\n                type: 'link',\n                raw,\n                href,\n                title,\n                text,\n                tokens: lexer.inlineTokens(text)\n            };\n            lexer.state.inLink = false;\n            return token;\n        }\n        return {\n            type: 'image',\n            raw,\n            href,\n            title,\n            text: escape$1(text)\n        };\n    }\n    function indentCodeCompensation(raw, text) {\n        const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n        if (matchIndentToCode === null) {\n            return text;\n        }\n        const indentToCode = matchIndentToCode[1];\n        return text\n            .split('\\n')\n            .map(node => {\n            const matchIndentInNode = node.match(/^\\s+/);\n            if (matchIndentInNode === null) {\n                return node;\n            }\n            const [indentInNode] = matchIndentInNode;\n            if (indentInNode.length >= indentToCode.length) {\n                return node.slice(indentToCode.length);\n            }\n            return node;\n        })\n            .join('\\n');\n    }\n    /**\n     * Tokenizer\n     */\n    class _Tokenizer {\n        options;\n        rules; // set by the lexer\n        lexer; // set by the lexer\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        space(src) {\n            const cap = this.rules.block.newline.exec(src);\n            if (cap && cap[0].length > 0) {\n                return {\n                    type: 'space',\n                    raw: cap[0]\n                };\n            }\n        }\n        code(src) {\n            const cap = this.rules.block.code.exec(src);\n            if (cap) {\n                const text = cap[0].replace(/^ {1,4}/gm, '');\n                return {\n                    type: 'code',\n                    raw: cap[0],\n                    codeBlockStyle: 'indented',\n                    text: !this.options.pedantic\n                        ? rtrim(text, '\\n')\n                        : text\n                };\n            }\n        }\n        fences(src) {\n            const cap = this.rules.block.fences.exec(src);\n            if (cap) {\n                const raw = cap[0];\n                const text = indentCodeCompensation(raw, cap[3] || '');\n                return {\n                    type: 'code',\n                    raw,\n                    lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                    text\n                };\n            }\n        }\n        heading(src) {\n            const cap = this.rules.block.heading.exec(src);\n            if (cap) {\n                let text = cap[2].trim();\n                // remove trailing #s\n                if (/#$/.test(text)) {\n                    const trimmed = rtrim(text, '#');\n                    if (this.options.pedantic) {\n                        text = trimmed.trim();\n                    }\n                    else if (!trimmed || / $/.test(trimmed)) {\n                        // CommonMark requires space before trailing #s\n                        text = trimmed.trim();\n                    }\n                }\n                return {\n                    type: 'heading',\n                    raw: cap[0],\n                    depth: cap[1].length,\n                    text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        hr(src) {\n            const cap = this.rules.block.hr.exec(src);\n            if (cap) {\n                return {\n                    type: 'hr',\n                    raw: cap[0]\n                };\n            }\n        }\n        blockquote(src) {\n            const cap = this.rules.block.blockquote.exec(src);\n            if (cap) {\n                const text = rtrim(cap[0].replace(/^ *>[ \\t]?/gm, ''), '\\n');\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                const tokens = this.lexer.blockTokens(text);\n                this.lexer.state.top = top;\n                return {\n                    type: 'blockquote',\n                    raw: cap[0],\n                    tokens,\n                    text\n                };\n            }\n        }\n        list(src) {\n            let cap = this.rules.block.list.exec(src);\n            if (cap) {\n                let bull = cap[1].trim();\n                const isordered = bull.length > 1;\n                const list = {\n                    type: 'list',\n                    raw: '',\n                    ordered: isordered,\n                    start: isordered ? +bull.slice(0, -1) : '',\n                    loose: false,\n                    items: []\n                };\n                bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n                if (this.options.pedantic) {\n                    bull = isordered ? bull : '[*+-]';\n                }\n                // Get next list item\n                const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n                let raw = '';\n                let itemContents = '';\n                let endsWithBlankLine = false;\n                // Check if current bullet point can start a new List Item\n                while (src) {\n                    let endEarly = false;\n                    if (!(cap = itemRegex.exec(src))) {\n                        break;\n                    }\n                    if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                        break;\n                    }\n                    raw = cap[0];\n                    src = src.substring(raw.length);\n                    let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n                    let nextLine = src.split('\\n', 1)[0];\n                    let indent = 0;\n                    if (this.options.pedantic) {\n                        indent = 2;\n                        itemContents = line.trimStart();\n                    }\n                    else {\n                        indent = cap[2].search(/[^ ]/); // Find first non-space char\n                        indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                        itemContents = line.slice(indent);\n                        indent += cap[1].length;\n                    }\n                    let blankLine = false;\n                    if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n                        raw += nextLine + '\\n';\n                        src = src.substring(nextLine.length + 1);\n                        endEarly = true;\n                    }\n                    if (!endEarly) {\n                        const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                        const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                        const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                        const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                        // Check if following lines should be included in List Item\n                        while (src) {\n                            const rawLine = src.split('\\n', 1)[0];\n                            nextLine = rawLine;\n                            // Re-align to follow commonmark nesting rules\n                            if (this.options.pedantic) {\n                                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                            }\n                            // End list item if found code fences\n                            if (fencesBeginRegex.test(nextLine)) {\n                                break;\n                            }\n                            // End list item if found start of new heading\n                            if (headingBeginRegex.test(nextLine)) {\n                                break;\n                            }\n                            // End list item if found start of new bullet\n                            if (nextBulletRegex.test(nextLine)) {\n                                break;\n                            }\n                            // Horizontal rule found\n                            if (hrRegex.test(src)) {\n                                break;\n                            }\n                            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                                itemContents += '\\n' + nextLine.slice(indent);\n                            }\n                            else {\n                                // not enough indentation\n                                if (blankLine) {\n                                    break;\n                                }\n                                // paragraph continuation unless last line was a different block level element\n                                if (line.search(/[^ ]/) >= 4) { // indented code block\n                                    break;\n                                }\n                                if (fencesBeginRegex.test(line)) {\n                                    break;\n                                }\n                                if (headingBeginRegex.test(line)) {\n                                    break;\n                                }\n                                if (hrRegex.test(line)) {\n                                    break;\n                                }\n                                itemContents += '\\n' + nextLine;\n                            }\n                            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                                blankLine = true;\n                            }\n                            raw += rawLine + '\\n';\n                            src = src.substring(rawLine.length + 1);\n                            line = nextLine.slice(indent);\n                        }\n                    }\n                    if (!list.loose) {\n                        // If the previous item ended with a blank line, the list is loose\n                        if (endsWithBlankLine) {\n                            list.loose = true;\n                        }\n                        else if (/\\n *\\n *$/.test(raw)) {\n                            endsWithBlankLine = true;\n                        }\n                    }\n                    let istask = null;\n                    let ischecked;\n                    // Check for task list items\n                    if (this.options.gfm) {\n                        istask = /^\\[[ xX]\\] /.exec(itemContents);\n                        if (istask) {\n                            ischecked = istask[0] !== '[ ] ';\n                            itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                        }\n                    }\n                    list.items.push({\n                        type: 'list_item',\n                        raw,\n                        task: !!istask,\n                        checked: ischecked,\n                        loose: false,\n                        text: itemContents,\n                        tokens: []\n                    });\n                    list.raw += raw;\n                }\n                // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n                list.items[list.items.length - 1].raw = raw.trimEnd();\n                (list.items[list.items.length - 1]).text = itemContents.trimEnd();\n                list.raw = list.raw.trimEnd();\n                // Item child tokens handled here at end because we needed to have the final item to trim it first\n                for (let i = 0; i < list.items.length; i++) {\n                    this.lexer.state.top = false;\n                    list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                    if (!list.loose) {\n                        // Check if list should be loose\n                        const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                        const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n                        list.loose = hasMultipleLineBreaks;\n                    }\n                }\n                // Set all items to loose if list is loose\n                if (list.loose) {\n                    for (let i = 0; i < list.items.length; i++) {\n                        list.items[i].loose = true;\n                    }\n                }\n                return list;\n            }\n        }\n        html(src) {\n            const cap = this.rules.block.html.exec(src);\n            if (cap) {\n                const token = {\n                    type: 'html',\n                    block: true,\n                    raw: cap[0],\n                    pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                    text: cap[0]\n                };\n                return token;\n            }\n        }\n        def(src) {\n            const cap = this.rules.block.def.exec(src);\n            if (cap) {\n                const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n                const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n                const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n                return {\n                    type: 'def',\n                    tag,\n                    raw: cap[0],\n                    href,\n                    title\n                };\n            }\n        }\n        table(src) {\n            const cap = this.rules.block.table.exec(src);\n            if (!cap) {\n                return;\n            }\n            if (!/[:|]/.test(cap[2])) {\n                // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n                return;\n            }\n            const headers = splitCells(cap[1]);\n            const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n            const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n            const item = {\n                type: 'table',\n                raw: cap[0],\n                header: [],\n                align: [],\n                rows: []\n            };\n            if (headers.length !== aligns.length) {\n                // header and align columns must be equal, rows can be different.\n                return;\n            }\n            for (const align of aligns) {\n                if (/^ *-+: *$/.test(align)) {\n                    item.align.push('right');\n                }\n                else if (/^ *:-+: *$/.test(align)) {\n                    item.align.push('center');\n                }\n                else if (/^ *:-+ *$/.test(align)) {\n                    item.align.push('left');\n                }\n                else {\n                    item.align.push(null);\n                }\n            }\n            for (const header of headers) {\n                item.header.push({\n                    text: header,\n                    tokens: this.lexer.inline(header)\n                });\n            }\n            for (const row of rows) {\n                item.rows.push(splitCells(row, item.header.length).map(cell => {\n                    return {\n                        text: cell,\n                        tokens: this.lexer.inline(cell)\n                    };\n                }));\n            }\n            return item;\n        }\n        lheading(src) {\n            const cap = this.rules.block.lheading.exec(src);\n            if (cap) {\n                return {\n                    type: 'heading',\n                    raw: cap[0],\n                    depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                    text: cap[1],\n                    tokens: this.lexer.inline(cap[1])\n                };\n            }\n        }\n        paragraph(src) {\n            const cap = this.rules.block.paragraph.exec(src);\n            if (cap) {\n                const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                    ? cap[1].slice(0, -1)\n                    : cap[1];\n                return {\n                    type: 'paragraph',\n                    raw: cap[0],\n                    text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        text(src) {\n            const cap = this.rules.block.text.exec(src);\n            if (cap) {\n                return {\n                    type: 'text',\n                    raw: cap[0],\n                    text: cap[0],\n                    tokens: this.lexer.inline(cap[0])\n                };\n            }\n        }\n        escape(src) {\n            const cap = this.rules.inline.escape.exec(src);\n            if (cap) {\n                return {\n                    type: 'escape',\n                    raw: cap[0],\n                    text: escape$1(cap[1])\n                };\n            }\n        }\n        tag(src) {\n            const cap = this.rules.inline.tag.exec(src);\n            if (cap) {\n                if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                    this.lexer.state.inLink = true;\n                }\n                else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                    this.lexer.state.inLink = false;\n                }\n                if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                    this.lexer.state.inRawBlock = true;\n                }\n                else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                    this.lexer.state.inRawBlock = false;\n                }\n                return {\n                    type: 'html',\n                    raw: cap[0],\n                    inLink: this.lexer.state.inLink,\n                    inRawBlock: this.lexer.state.inRawBlock,\n                    block: false,\n                    text: cap[0]\n                };\n            }\n        }\n        link(src) {\n            const cap = this.rules.inline.link.exec(src);\n            if (cap) {\n                const trimmedUrl = cap[2].trim();\n                if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                    // commonmark requires matching angle brackets\n                    if (!(/>$/.test(trimmedUrl))) {\n                        return;\n                    }\n                    // ending angle bracket cannot be escaped\n                    const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                    if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                        return;\n                    }\n                }\n                else {\n                    // find closing parenthesis\n                    const lastParenIndex = findClosingBracket(cap[2], '()');\n                    if (lastParenIndex > -1) {\n                        const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                        const linkLen = start + cap[1].length + lastParenIndex;\n                        cap[2] = cap[2].substring(0, lastParenIndex);\n                        cap[0] = cap[0].substring(0, linkLen).trim();\n                        cap[3] = '';\n                    }\n                }\n                let href = cap[2];\n                let title = '';\n                if (this.options.pedantic) {\n                    // split pedantic href and title\n                    const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                    if (link) {\n                        href = link[1];\n                        title = link[3];\n                    }\n                }\n                else {\n                    title = cap[3] ? cap[3].slice(1, -1) : '';\n                }\n                href = href.trim();\n                if (/^</.test(href)) {\n                    if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                        // pedantic allows starting angle bracket without ending angle bracket\n                        href = href.slice(1);\n                    }\n                    else {\n                        href = href.slice(1, -1);\n                    }\n                }\n                return outputLink(cap, {\n                    href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                    title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title\n                }, cap[0], this.lexer);\n            }\n        }\n        reflink(src, links) {\n            let cap;\n            if ((cap = this.rules.inline.reflink.exec(src))\n                || (cap = this.rules.inline.nolink.exec(src))) {\n                const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n                const link = links[linkString.toLowerCase()];\n                if (!link) {\n                    const text = cap[0].charAt(0);\n                    return {\n                        type: 'text',\n                        raw: text,\n                        text\n                    };\n                }\n                return outputLink(cap, link, cap[0], this.lexer);\n            }\n        }\n        emStrong(src, maskedSrc, prevChar = '') {\n            let match = this.rules.inline.emStrongLDelim.exec(src);\n            if (!match)\n                return;\n            // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n            if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n                return;\n            const nextChar = match[1] || match[2] || '';\n            if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n                // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n                const lLength = [...match[0]].length - 1;\n                let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n                const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n                endReg.lastIndex = 0;\n                // Clip maskedSrc to same section of string as src (move to lexer?)\n                maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n                while ((match = endReg.exec(maskedSrc)) != null) {\n                    rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                    if (!rDelim)\n                        continue; // skip single * in __abc*abc__\n                    rLength = [...rDelim].length;\n                    if (match[3] || match[4]) { // found another Left Delim\n                        delimTotal += rLength;\n                        continue;\n                    }\n                    else if (match[5] || match[6]) { // either Left or Right Delim\n                        if (lLength % 3 && !((lLength + rLength) % 3)) {\n                            midDelimTotal += rLength;\n                            continue; // CommonMark Emphasis Rules 9-10\n                        }\n                    }\n                    delimTotal -= rLength;\n                    if (delimTotal > 0)\n                        continue; // Haven't found enough closing delimiters\n                    // Remove extra characters. *a*** -> *a*\n                    rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                    // char length can be >1 for unicode characters;\n                    const lastCharLength = [...match[0]][0].length;\n                    const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                    // Create `em` if smallest delimiter has odd char count. *a***\n                    if (Math.min(lLength, rLength) % 2) {\n                        const text = raw.slice(1, -1);\n                        return {\n                            type: 'em',\n                            raw,\n                            text,\n                            tokens: this.lexer.inlineTokens(text)\n                        };\n                    }\n                    // Create 'strong' if smallest delimiter has even char count. **a***\n                    const text = raw.slice(2, -2);\n                    return {\n                        type: 'strong',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n            }\n        }\n        codespan(src) {\n            const cap = this.rules.inline.code.exec(src);\n            if (cap) {\n                let text = cap[2].replace(/\\n/g, ' ');\n                const hasNonSpaceChars = /[^ ]/.test(text);\n                const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n                if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                    text = text.substring(1, text.length - 1);\n                }\n                text = escape$1(text, true);\n                return {\n                    type: 'codespan',\n                    raw: cap[0],\n                    text\n                };\n            }\n        }\n        br(src) {\n            const cap = this.rules.inline.br.exec(src);\n            if (cap) {\n                return {\n                    type: 'br',\n                    raw: cap[0]\n                };\n            }\n        }\n        del(src) {\n            const cap = this.rules.inline.del.exec(src);\n            if (cap) {\n                return {\n                    type: 'del',\n                    raw: cap[0],\n                    text: cap[2],\n                    tokens: this.lexer.inlineTokens(cap[2])\n                };\n            }\n        }\n        autolink(src) {\n            const cap = this.rules.inline.autolink.exec(src);\n            if (cap) {\n                let text, href;\n                if (cap[2] === '@') {\n                    text = escape$1(cap[1]);\n                    href = 'mailto:' + text;\n                }\n                else {\n                    text = escape$1(cap[1]);\n                    href = text;\n                }\n                return {\n                    type: 'link',\n                    raw: cap[0],\n                    text,\n                    href,\n                    tokens: [\n                        {\n                            type: 'text',\n                            raw: text,\n                            text\n                        }\n                    ]\n                };\n            }\n        }\n        url(src) {\n            let cap;\n            if (cap = this.rules.inline.url.exec(src)) {\n                let text, href;\n                if (cap[2] === '@') {\n                    text = escape$1(cap[0]);\n                    href = 'mailto:' + text;\n                }\n                else {\n                    // do extended autolink path validation\n                    let prevCapZero;\n                    do {\n                        prevCapZero = cap[0];\n                        cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                    } while (prevCapZero !== cap[0]);\n                    text = escape$1(cap[0]);\n                    if (cap[1] === 'www.') {\n                        href = 'http://' + cap[0];\n                    }\n                    else {\n                        href = cap[0];\n                    }\n                }\n                return {\n                    type: 'link',\n                    raw: cap[0],\n                    text,\n                    href,\n                    tokens: [\n                        {\n                            type: 'text',\n                            raw: text,\n                            text\n                        }\n                    ]\n                };\n            }\n        }\n        inlineText(src) {\n            const cap = this.rules.inline.text.exec(src);\n            if (cap) {\n                let text;\n                if (this.lexer.state.inRawBlock) {\n                    text = cap[0];\n                }\n                else {\n                    text = escape$1(cap[0]);\n                }\n                return {\n                    type: 'text',\n                    raw: cap[0],\n                    text\n                };\n            }\n        }\n    }\n\n    /**\n     * Block-Level Grammar\n     */\n    const newline = /^(?: *(?:\\n|$))+/;\n    const blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\n    const fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n    const hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n    const heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n    const bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n    const lheading = edit(/^(?!bull )((?:.|\\n(?!\\s*?\\n|bull ))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n        .replace(/bull/g, bullet) // lists can interrupt\n        .getRegex();\n    const _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n    const blockText = /^[^\\n]+/;\n    const _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n    const def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/)\n        .replace('label', _blockLabel)\n        .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n        .getRegex();\n    const list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n        .replace(/bull/g, bullet)\n        .getRegex();\n    const _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n        + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n        + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n        + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n        + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n        + '|track|ul';\n    const _comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\n    const html = edit('^ {0,3}(?:' // optional indentation\n        + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n        + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n        + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n        + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n        + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n        + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n        + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n        + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n        + ')', 'i')\n        .replace('comment', _comment)\n        .replace('tag', _tag)\n        .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n        .getRegex();\n    const paragraph = edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex();\n    const blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n        .replace('paragraph', paragraph)\n        .getRegex();\n    /**\n     * Normal Block Grammar\n     */\n    const blockNormal = {\n        blockquote,\n        code: blockCode,\n        def,\n        fences,\n        heading,\n        hr,\n        html,\n        lheading,\n        list,\n        newline,\n        paragraph,\n        table: noopTest,\n        text: blockText\n    };\n    /**\n     * GFM Block Grammar\n     */\n    const gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n        + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n        + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('blockquote', ' {0,3}>')\n        .replace('code', ' {4}[^\\\\n]')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n        .getRegex();\n    const blockGfm = {\n        ...blockNormal,\n        table: gfmTable,\n        paragraph: edit(_paragraph)\n            .replace('hr', hr)\n            .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n            .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n            .replace('table', gfmTable) // interrupt paragraphs with table\n            .replace('blockquote', ' {0,3}>')\n            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n            .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n            .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n            .getRegex()\n    };\n    /**\n     * Pedantic grammar (original John Gruber's loose markdown specification)\n     */\n    const blockPedantic = {\n        ...blockNormal,\n        html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n            + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n            + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n            .replace('comment', _comment)\n            .replace(/tag/g, '(?!(?:'\n            + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n            + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n            + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n            .getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: noopTest, // fences not supported\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: edit(_paragraph)\n            .replace('hr', hr)\n            .replace('heading', ' *#{1,6} *[^\\n]')\n            .replace('lheading', lheading)\n            .replace('|table', '')\n            .replace('blockquote', ' {0,3}>')\n            .replace('|fences', '')\n            .replace('|list', '')\n            .replace('|html', '')\n            .replace('|tag', '')\n            .getRegex()\n    };\n    /**\n     * Inline-Level Grammar\n     */\n    const escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n    const inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n    const br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n    const inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n    // list of unicode punctuation marks, plus any missing characters from CommonMark spec\n    const _punctuation = '\\\\p{P}$+<=>`^|~';\n    const punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n        .replace(/punctuation/g, _punctuation).getRegex();\n    // sequences em should skip over [title](link), `code`, <html>\n    const blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\n    const emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n        + '|[^*]+(?=[^*])' // Consume to delim\n        + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n        + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n        + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n        + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n        + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n        + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    // (6) Not allowed for _\n    const emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n        + '|[^_]+(?=[^_])' // Consume to delim\n        + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n        + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n        + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n        + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n        + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const anyPunctuation = edit(/\\\\([punct])/, 'gu')\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n        .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n        .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n        .getRegex();\n    const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\n    const tag = edit('^comment'\n        + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n        + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n        + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n        + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n        + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n        .replace('comment', _inlineComment)\n        .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n        .getRegex();\n    const _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n    const link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n        .replace('label', _inlineLabel)\n        .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n        .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n        .getRegex();\n    const reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n        .replace('label', _inlineLabel)\n        .replace('ref', _blockLabel)\n        .getRegex();\n    const nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n        .replace('ref', _blockLabel)\n        .getRegex();\n    const reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n        .replace('reflink', reflink)\n        .replace('nolink', nolink)\n        .getRegex();\n    /**\n     * Normal Inline Grammar\n     */\n    const inlineNormal = {\n        _backpedal: noopTest, // only used for GFM url\n        anyPunctuation,\n        autolink,\n        blockSkip,\n        br,\n        code: inlineCode,\n        del: noopTest,\n        emStrongLDelim,\n        emStrongRDelimAst,\n        emStrongRDelimUnd,\n        escape,\n        link,\n        nolink,\n        punctuation,\n        reflink,\n        reflinkSearch,\n        tag,\n        text: inlineText,\n        url: noopTest\n    };\n    /**\n     * Pedantic Inline Grammar\n     */\n    const inlinePedantic = {\n        ...inlineNormal,\n        link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n            .replace('label', _inlineLabel)\n            .getRegex(),\n        reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n            .replace('label', _inlineLabel)\n            .getRegex()\n    };\n    /**\n     * GFM Inline Grammar\n     */\n    const inlineGfm = {\n        ...inlineNormal,\n        escape: edit(escape).replace('])', '~|])').getRegex(),\n        url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n            .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n            .getRegex(),\n        _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n    };\n    /**\n     * GFM + Line Breaks Inline Grammar\n     */\n    const inlineBreaks = {\n        ...inlineGfm,\n        br: edit(br).replace('{2,}', '*').getRegex(),\n        text: edit(inlineGfm.text)\n            .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n            .replace(/\\{2,\\}/g, '*')\n            .getRegex()\n    };\n    /**\n     * exports\n     */\n    const block = {\n        normal: blockNormal,\n        gfm: blockGfm,\n        pedantic: blockPedantic\n    };\n    const inline = {\n        normal: inlineNormal,\n        gfm: inlineGfm,\n        breaks: inlineBreaks,\n        pedantic: inlinePedantic\n    };\n\n    /**\n     * Block Lexer\n     */\n    class _Lexer {\n        tokens;\n        options;\n        state;\n        tokenizer;\n        inlineQueue;\n        constructor(options) {\n            // TokenList cannot be created in one go\n            this.tokens = [];\n            this.tokens.links = Object.create(null);\n            this.options = options || exports.defaults;\n            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n            this.tokenizer = this.options.tokenizer;\n            this.tokenizer.options = this.options;\n            this.tokenizer.lexer = this;\n            this.inlineQueue = [];\n            this.state = {\n                inLink: false,\n                inRawBlock: false,\n                top: true\n            };\n            const rules = {\n                block: block.normal,\n                inline: inline.normal\n            };\n            if (this.options.pedantic) {\n                rules.block = block.pedantic;\n                rules.inline = inline.pedantic;\n            }\n            else if (this.options.gfm) {\n                rules.block = block.gfm;\n                if (this.options.breaks) {\n                    rules.inline = inline.breaks;\n                }\n                else {\n                    rules.inline = inline.gfm;\n                }\n            }\n            this.tokenizer.rules = rules;\n        }\n        /**\n         * Expose Rules\n         */\n        static get rules() {\n            return {\n                block,\n                inline\n            };\n        }\n        /**\n         * Static Lex Method\n         */\n        static lex(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.lex(src);\n        }\n        /**\n         * Static Lex Inline Method\n         */\n        static lexInline(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.inlineTokens(src);\n        }\n        /**\n         * Preprocessing\n         */\n        lex(src) {\n            src = src\n                .replace(/\\r\\n|\\r/g, '\\n');\n            this.blockTokens(src, this.tokens);\n            let next;\n            while (next = this.inlineQueue.shift()) {\n                this.inlineTokens(next.src, next.tokens);\n            }\n            return this.tokens;\n        }\n        blockTokens(src, tokens = []) {\n            if (this.options.pedantic) {\n                src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n            }\n            else {\n                src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n                    return leading + '    '.repeat(tabs.length);\n                });\n            }\n            let token;\n            let lastToken;\n            let cutSrc;\n            let lastParagraphClipped;\n            while (src) {\n                if (this.options.extensions\n                    && this.options.extensions.block\n                    && this.options.extensions.block.some((extTokenizer) => {\n                        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                            src = src.substring(token.raw.length);\n                            tokens.push(token);\n                            return true;\n                        }\n                        return false;\n                    })) {\n                    continue;\n                }\n                // newline\n                if (token = this.tokenizer.space(src)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.length === 1 && tokens.length > 0) {\n                        // if there's a single \\n as a spacer, it's terminating the last line,\n                        // so move it there so that we don't get unnecessary paragraph tags\n                        tokens[tokens.length - 1].raw += '\\n';\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.code(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    // An indented code block cannot interrupt a paragraph.\n                    if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // fences\n                if (token = this.tokenizer.fences(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // heading\n                if (token = this.tokenizer.heading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // hr\n                if (token = this.tokenizer.hr(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // blockquote\n                if (token = this.tokenizer.blockquote(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // list\n                if (token = this.tokenizer.list(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // html\n                if (token = this.tokenizer.html(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // def\n                if (token = this.tokenizer.def(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.raw;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else if (!this.tokens.links[token.tag]) {\n                        this.tokens.links[token.tag] = {\n                            href: token.href,\n                            title: token.title\n                        };\n                    }\n                    continue;\n                }\n                // table (gfm)\n                if (token = this.tokenizer.table(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // lheading\n                if (token = this.tokenizer.lheading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // top-level paragraph\n                // prevent paragraph consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startBlock) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startBlock.forEach((getStartIndex) => {\n                        tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                        if (typeof tempStart === 'number' && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                }\n                if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastParagraphClipped && lastToken.type === 'paragraph') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    lastParagraphClipped = (cutSrc.length !== src.length);\n                    src = src.substring(token.raw.length);\n                    continue;\n                }\n                // text\n                if (token = this.tokenizer.text(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === 'text') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                if (src) {\n                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n            this.state.top = true;\n            return tokens;\n        }\n        inline(src, tokens = []) {\n            this.inlineQueue.push({ src, tokens });\n            return tokens;\n        }\n        /**\n         * Lexing/Compiling\n         */\n        inlineTokens(src, tokens = []) {\n            let token, lastToken, cutSrc;\n            // String with links masked to avoid interference with em and strong\n            let maskedSrc = src;\n            let match;\n            let keepPrevChar, prevChar;\n            // Mask out reflinks\n            if (this.tokens.links) {\n                const links = Object.keys(this.tokens.links);\n                if (links.length > 0) {\n                    while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                        if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                        }\n                    }\n                }\n            }\n            // Mask out other blocks\n            while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n                maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n            }\n            // Mask out escaped characters\n            while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n                maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n            }\n            while (src) {\n                if (!keepPrevChar) {\n                    prevChar = '';\n                }\n                keepPrevChar = false;\n                // extensions\n                if (this.options.extensions\n                    && this.options.extensions.inline\n                    && this.options.extensions.inline.some((extTokenizer) => {\n                        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                            src = src.substring(token.raw.length);\n                            tokens.push(token);\n                            return true;\n                        }\n                        return false;\n                    })) {\n                    continue;\n                }\n                // escape\n                if (token = this.tokenizer.escape(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // tag\n                if (token = this.tokenizer.tag(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // link\n                if (token = this.tokenizer.link(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // reflink, nolink\n                if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // em & strong\n                if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.codespan(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // br\n                if (token = this.tokenizer.br(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // del (gfm)\n                if (token = this.tokenizer.del(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // autolink\n                if (token = this.tokenizer.autolink(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // url (gfm)\n                if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // text\n                // prevent inlineText consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startInline) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startInline.forEach((getStartIndex) => {\n                        tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                        if (typeof tempStart === 'number' && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                }\n                if (token = this.tokenizer.inlineText(cutSrc)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                        prevChar = token.raw.slice(-1);\n                    }\n                    keepPrevChar = true;\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                if (src) {\n                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n            return tokens;\n        }\n    }\n\n    /**\n     * Renderer\n     */\n    class _Renderer {\n        options;\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        code(code, infostring, escaped) {\n            const lang = (infostring || '').match(/^\\S*/)?.[0];\n            code = code.replace(/\\n$/, '') + '\\n';\n            if (!lang) {\n                return '<pre><code>'\n                    + (escaped ? code : escape$1(code, true))\n                    + '</code></pre>\\n';\n            }\n            return '<pre><code class=\"language-'\n                + escape$1(lang)\n                + '\">'\n                + (escaped ? code : escape$1(code, true))\n                + '</code></pre>\\n';\n        }\n        blockquote(quote) {\n            return `<blockquote>\\n${quote}</blockquote>\\n`;\n        }\n        html(html, block) {\n            return html;\n        }\n        heading(text, level, raw) {\n            // ignore IDs\n            return `<h${level}>${text}</h${level}>\\n`;\n        }\n        hr() {\n            return '<hr>\\n';\n        }\n        list(body, ordered, start) {\n            const type = ordered ? 'ol' : 'ul';\n            const startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n            return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n        }\n        listitem(text, task, checked) {\n            return `<li>${text}</li>\\n`;\n        }\n        checkbox(checked) {\n            return '<input '\n                + (checked ? 'checked=\"\" ' : '')\n                + 'disabled=\"\" type=\"checkbox\">';\n        }\n        paragraph(text) {\n            return `<p>${text}</p>\\n`;\n        }\n        table(header, body) {\n            if (body)\n                body = `<tbody>${body}</tbody>`;\n            return '<table>\\n'\n                + '<thead>\\n'\n                + header\n                + '</thead>\\n'\n                + body\n                + '</table>\\n';\n        }\n        tablerow(content) {\n            return `<tr>\\n${content}</tr>\\n`;\n        }\n        tablecell(content, flags) {\n            const type = flags.header ? 'th' : 'td';\n            const tag = flags.align\n                ? `<${type} align=\"${flags.align}\">`\n                : `<${type}>`;\n            return tag + content + `</${type}>\\n`;\n        }\n        /**\n         * span level renderer\n         */\n        strong(text) {\n            return `<strong>${text}</strong>`;\n        }\n        em(text) {\n            return `<em>${text}</em>`;\n        }\n        codespan(text) {\n            return `<code>${text}</code>`;\n        }\n        br() {\n            return '<br>';\n        }\n        del(text) {\n            return `<del>${text}</del>`;\n        }\n        link(href, title, text) {\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) {\n                return text;\n            }\n            href = cleanHref;\n            let out = '<a href=\"' + href + '\"';\n            if (title) {\n                out += ' title=\"' + title + '\"';\n            }\n            out += '>' + text + '</a>';\n            return out;\n        }\n        image(href, title, text) {\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) {\n                return text;\n            }\n            href = cleanHref;\n            let out = `<img src=\"${href}\" alt=\"${text}\"`;\n            if (title) {\n                out += ` title=\"${title}\"`;\n            }\n            out += '>';\n            return out;\n        }\n        text(text) {\n            return text;\n        }\n    }\n\n    /**\n     * TextRenderer\n     * returns only the textual part of the token\n     */\n    class _TextRenderer {\n        // no need for block level renderers\n        strong(text) {\n            return text;\n        }\n        em(text) {\n            return text;\n        }\n        codespan(text) {\n            return text;\n        }\n        del(text) {\n            return text;\n        }\n        html(text) {\n            return text;\n        }\n        text(text) {\n            return text;\n        }\n        link(href, title, text) {\n            return '' + text;\n        }\n        image(href, title, text) {\n            return '' + text;\n        }\n        br() {\n            return '';\n        }\n    }\n\n    /**\n     * Parsing & Compiling\n     */\n    class _Parser {\n        options;\n        renderer;\n        textRenderer;\n        constructor(options) {\n            this.options = options || exports.defaults;\n            this.options.renderer = this.options.renderer || new _Renderer();\n            this.renderer = this.options.renderer;\n            this.renderer.options = this.options;\n            this.textRenderer = new _TextRenderer();\n        }\n        /**\n         * Static Parse Method\n         */\n        static parse(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parse(tokens);\n        }\n        /**\n         * Static Parse Inline Method\n         */\n        static parseInline(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parseInline(tokens);\n        }\n        /**\n         * Parse Loop\n         */\n        parse(tokens, top = true) {\n            let out = '';\n            for (let i = 0; i < tokens.length; i++) {\n                const token = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                    const genericToken = token;\n                    const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                    if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                        out += ret || '';\n                        continue;\n                    }\n                }\n                switch (token.type) {\n                    case 'space': {\n                        continue;\n                    }\n                    case 'hr': {\n                        out += this.renderer.hr();\n                        continue;\n                    }\n                    case 'heading': {\n                        const headingToken = token;\n                        out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));\n                        continue;\n                    }\n                    case 'code': {\n                        const codeToken = token;\n                        out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                        continue;\n                    }\n                    case 'table': {\n                        const tableToken = token;\n                        let header = '';\n                        // header\n                        let cell = '';\n                        for (let j = 0; j < tableToken.header.length; j++) {\n                            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });\n                        }\n                        header += this.renderer.tablerow(cell);\n                        let body = '';\n                        for (let j = 0; j < tableToken.rows.length; j++) {\n                            const row = tableToken.rows[j];\n                            cell = '';\n                            for (let k = 0; k < row.length; k++) {\n                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });\n                            }\n                            body += this.renderer.tablerow(cell);\n                        }\n                        out += this.renderer.table(header, body);\n                        continue;\n                    }\n                    case 'blockquote': {\n                        const blockquoteToken = token;\n                        const body = this.parse(blockquoteToken.tokens);\n                        out += this.renderer.blockquote(body);\n                        continue;\n                    }\n                    case 'list': {\n                        const listToken = token;\n                        const ordered = listToken.ordered;\n                        const start = listToken.start;\n                        const loose = listToken.loose;\n                        let body = '';\n                        for (let j = 0; j < listToken.items.length; j++) {\n                            const item = listToken.items[j];\n                            const checked = item.checked;\n                            const task = item.task;\n                            let itemBody = '';\n                            if (item.task) {\n                                const checkbox = this.renderer.checkbox(!!checked);\n                                if (loose) {\n                                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                                        item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                                            item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                                        }\n                                    }\n                                    else {\n                                        item.tokens.unshift({\n                                            type: 'text',\n                                            text: checkbox + ' '\n                                        });\n                                    }\n                                }\n                                else {\n                                    itemBody += checkbox + ' ';\n                                }\n                            }\n                            itemBody += this.parse(item.tokens, loose);\n                            body += this.renderer.listitem(itemBody, task, !!checked);\n                        }\n                        out += this.renderer.list(body, ordered, start);\n                        continue;\n                    }\n                    case 'html': {\n                        const htmlToken = token;\n                        out += this.renderer.html(htmlToken.text, htmlToken.block);\n                        continue;\n                    }\n                    case 'paragraph': {\n                        const paragraphToken = token;\n                        out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                        continue;\n                    }\n                    case 'text': {\n                        let textToken = token;\n                        let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                        while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                            textToken = tokens[++i];\n                            body += '\\n' + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                        }\n                        out += top ? this.renderer.paragraph(body) : body;\n                        continue;\n                    }\n                    default: {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return '';\n                        }\n                        else {\n                            throw new Error(errMsg);\n                        }\n                    }\n                }\n            }\n            return out;\n        }\n        /**\n         * Parse Inline Tokens\n         */\n        parseInline(tokens, renderer) {\n            renderer = renderer || this.renderer;\n            let out = '';\n            for (let i = 0; i < tokens.length; i++) {\n                const token = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                    const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n                    if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n                        out += ret || '';\n                        continue;\n                    }\n                }\n                switch (token.type) {\n                    case 'escape': {\n                        const escapeToken = token;\n                        out += renderer.text(escapeToken.text);\n                        break;\n                    }\n                    case 'html': {\n                        const tagToken = token;\n                        out += renderer.html(tagToken.text);\n                        break;\n                    }\n                    case 'link': {\n                        const linkToken = token;\n                        out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                        break;\n                    }\n                    case 'image': {\n                        const imageToken = token;\n                        out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                        break;\n                    }\n                    case 'strong': {\n                        const strongToken = token;\n                        out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                        break;\n                    }\n                    case 'em': {\n                        const emToken = token;\n                        out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                        break;\n                    }\n                    case 'codespan': {\n                        const codespanToken = token;\n                        out += renderer.codespan(codespanToken.text);\n                        break;\n                    }\n                    case 'br': {\n                        out += renderer.br();\n                        break;\n                    }\n                    case 'del': {\n                        const delToken = token;\n                        out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                        break;\n                    }\n                    case 'text': {\n                        const textToken = token;\n                        out += renderer.text(textToken.text);\n                        break;\n                    }\n                    default: {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return '';\n                        }\n                        else {\n                            throw new Error(errMsg);\n                        }\n                    }\n                }\n            }\n            return out;\n        }\n    }\n\n    class _Hooks {\n        options;\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        static passThroughHooks = new Set([\n            'preprocess',\n            'postprocess'\n        ]);\n        /**\n         * Process markdown before marked\n         */\n        preprocess(markdown) {\n            return markdown;\n        }\n        /**\n         * Process HTML after marked is finished\n         */\n        postprocess(html) {\n            return html;\n        }\n    }\n\n    class Marked {\n        defaults = _getDefaults();\n        options = this.setOptions;\n        parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n        parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n        Parser = _Parser;\n        Renderer = _Renderer;\n        TextRenderer = _TextRenderer;\n        Lexer = _Lexer;\n        Tokenizer = _Tokenizer;\n        Hooks = _Hooks;\n        constructor(...args) {\n            this.use(...args);\n        }\n        /**\n         * Run callback for every token\n         */\n        walkTokens(tokens, callback) {\n            let values = [];\n            for (const token of tokens) {\n                values = values.concat(callback.call(this, token));\n                switch (token.type) {\n                    case 'table': {\n                        const tableToken = token;\n                        for (const cell of tableToken.header) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows) {\n                            for (const cell of row) {\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                    case 'list': {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                    default: {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                                values = values.concat(this.walkTokens(genericToken[childTokens], callback));\n                            });\n                        }\n                        else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n                }\n            }\n            return values;\n        }\n        use(...args) {\n            const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n            args.forEach((pack) => {\n                // copy options to new object\n                const opts = { ...pack };\n                // set async to true if it was set to true before\n                opts.async = this.defaults.async || opts.async || false;\n                // ==-- Parse \"addon\" extensions --== //\n                if (pack.extensions) {\n                    pack.extensions.forEach((ext) => {\n                        if (!ext.name) {\n                            throw new Error('extension name required');\n                        }\n                        if ('renderer' in ext) { // Renderer extensions\n                            const prevRenderer = extensions.renderers[ext.name];\n                            if (prevRenderer) {\n                                // Replace extension with func to run new extension but fall back if false\n                                extensions.renderers[ext.name] = function (...args) {\n                                    let ret = ext.renderer.apply(this, args);\n                                    if (ret === false) {\n                                        ret = prevRenderer.apply(this, args);\n                                    }\n                                    return ret;\n                                };\n                            }\n                            else {\n                                extensions.renderers[ext.name] = ext.renderer;\n                            }\n                        }\n                        if ('tokenizer' in ext) { // Tokenizer Extensions\n                            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                                throw new Error(\"extension level must be 'block' or 'inline'\");\n                            }\n                            const extLevel = extensions[ext.level];\n                            if (extLevel) {\n                                extLevel.unshift(ext.tokenizer);\n                            }\n                            else {\n                                extensions[ext.level] = [ext.tokenizer];\n                            }\n                            if (ext.start) { // Function to check for start of token\n                                if (ext.level === 'block') {\n                                    if (extensions.startBlock) {\n                                        extensions.startBlock.push(ext.start);\n                                    }\n                                    else {\n                                        extensions.startBlock = [ext.start];\n                                    }\n                                }\n                                else if (ext.level === 'inline') {\n                                    if (extensions.startInline) {\n                                        extensions.startInline.push(ext.start);\n                                    }\n                                    else {\n                                        extensions.startInline = [ext.start];\n                                    }\n                                }\n                            }\n                        }\n                        if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                            extensions.childTokens[ext.name] = ext.childTokens;\n                        }\n                    });\n                    opts.extensions = extensions;\n                }\n                // ==-- Parse \"overwrite\" extensions --== //\n                if (pack.renderer) {\n                    const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                    for (const prop in pack.renderer) {\n                        if (!(prop in renderer) || prop === 'options') {\n                            throw new Error(`renderer '${prop}' does not exist`);\n                        }\n                        const rendererProp = prop;\n                        const rendererFunc = pack.renderer[rendererProp];\n                        const prevRenderer = renderer[rendererProp];\n                        // Replace renderer with func to run extension, but fall back if false\n                        renderer[rendererProp] = (...args) => {\n                            let ret = rendererFunc.apply(renderer, args);\n                            if (ret === false) {\n                                ret = prevRenderer.apply(renderer, args);\n                            }\n                            return ret || '';\n                        };\n                    }\n                    opts.renderer = renderer;\n                }\n                if (pack.tokenizer) {\n                    const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                    for (const prop in pack.tokenizer) {\n                        if (!(prop in tokenizer) || ['options', 'rules', 'lexer'].includes(prop)) {\n                            throw new Error(`tokenizer '${prop}' does not exist`);\n                        }\n                        const tokenizerProp = prop;\n                        const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                        const prevTokenizer = tokenizer[tokenizerProp];\n                        // Replace tokenizer with func to run extension, but fall back if false\n                        // @ts-expect-error cannot type tokenizer function dynamically\n                        tokenizer[tokenizerProp] = (...args) => {\n                            let ret = tokenizerFunc.apply(tokenizer, args);\n                            if (ret === false) {\n                                ret = prevTokenizer.apply(tokenizer, args);\n                            }\n                            return ret;\n                        };\n                    }\n                    opts.tokenizer = tokenizer;\n                }\n                // ==-- Parse Hooks extensions --== //\n                if (pack.hooks) {\n                    const hooks = this.defaults.hooks || new _Hooks();\n                    for (const prop in pack.hooks) {\n                        if (!(prop in hooks) || prop === 'options') {\n                            throw new Error(`hook '${prop}' does not exist`);\n                        }\n                        const hooksProp = prop;\n                        const hooksFunc = pack.hooks[hooksProp];\n                        const prevHook = hooks[hooksProp];\n                        if (_Hooks.passThroughHooks.has(prop)) {\n                            hooks[hooksProp] = (arg) => {\n                                if (this.defaults.async) {\n                                    return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                        return prevHook.call(hooks, ret);\n                                    });\n                                }\n                                const ret = hooksFunc.call(hooks, arg);\n                                return prevHook.call(hooks, ret);\n                            };\n                        }\n                        else {\n                            hooks[hooksProp] = (...args) => {\n                                let ret = hooksFunc.apply(hooks, args);\n                                if (ret === false) {\n                                    ret = prevHook.apply(hooks, args);\n                                }\n                                return ret;\n                            };\n                        }\n                    }\n                    opts.hooks = hooks;\n                }\n                // ==-- Parse WalkTokens extensions --== //\n                if (pack.walkTokens) {\n                    const walkTokens = this.defaults.walkTokens;\n                    const packWalktokens = pack.walkTokens;\n                    opts.walkTokens = function (token) {\n                        let values = [];\n                        values.push(packWalktokens.call(this, token));\n                        if (walkTokens) {\n                            values = values.concat(walkTokens.call(this, token));\n                        }\n                        return values;\n                    };\n                }\n                this.defaults = { ...this.defaults, ...opts };\n            });\n            return this;\n        }\n        setOptions(opt) {\n            this.defaults = { ...this.defaults, ...opt };\n            return this;\n        }\n        lexer(src, options) {\n            return _Lexer.lex(src, options ?? this.defaults);\n        }\n        parser(tokens, options) {\n            return _Parser.parse(tokens, options ?? this.defaults);\n        }\n        #parseMarkdown(lexer, parser) {\n            return (src, options) => {\n                const origOpt = { ...options };\n                const opt = { ...this.defaults, ...origOpt };\n                // Show warning if an extension set async to true but the parse was called with async: false\n                if (this.defaults.async === true && origOpt.async === false) {\n                    if (!opt.silent) {\n                        console.warn('marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.');\n                    }\n                    opt.async = true;\n                }\n                const throwError = this.#onError(!!opt.silent, !!opt.async);\n                // throw error in case of non string input\n                if (typeof src === 'undefined' || src === null) {\n                    return throwError(new Error('marked(): input parameter is undefined or null'));\n                }\n                if (typeof src !== 'string') {\n                    return throwError(new Error('marked(): input parameter is of type '\n                        + Object.prototype.toString.call(src) + ', string expected'));\n                }\n                if (opt.hooks) {\n                    opt.hooks.options = opt;\n                }\n                if (opt.async) {\n                    return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                        .then(src => lexer(src, opt))\n                        .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                        .then(tokens => parser(tokens, opt))\n                        .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                        .catch(throwError);\n                }\n                try {\n                    if (opt.hooks) {\n                        src = opt.hooks.preprocess(src);\n                    }\n                    const tokens = lexer(src, opt);\n                    if (opt.walkTokens) {\n                        this.walkTokens(tokens, opt.walkTokens);\n                    }\n                    let html = parser(tokens, opt);\n                    if (opt.hooks) {\n                        html = opt.hooks.postprocess(html);\n                    }\n                    return html;\n                }\n                catch (e) {\n                    return throwError(e);\n                }\n            };\n        }\n        #onError(silent, async) {\n            return (e) => {\n                e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n                if (silent) {\n                    const msg = '<p>An error occurred:</p><pre>'\n                        + escape$1(e.message + '', true)\n                        + '</pre>';\n                    if (async) {\n                        return Promise.resolve(msg);\n                    }\n                    return msg;\n                }\n                if (async) {\n                    return Promise.reject(e);\n                }\n                throw e;\n            };\n        }\n    }\n\n    const markedInstance = new Marked();\n    function marked(src, opt) {\n        return markedInstance.parse(src, opt);\n    }\n    /**\n     * Sets the default options.\n     *\n     * @param options Hash of options\n     */\n    marked.options =\n        marked.setOptions = function (options) {\n            markedInstance.setOptions(options);\n            marked.defaults = markedInstance.defaults;\n            changeDefaults(marked.defaults);\n            return marked;\n        };\n    /**\n     * Gets the original marked default options.\n     */\n    marked.getDefaults = _getDefaults;\n    marked.defaults = exports.defaults;\n    /**\n     * Use Extension\n     */\n    marked.use = function (...args) {\n        markedInstance.use(...args);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Run callback for every token\n     */\n    marked.walkTokens = function (tokens, callback) {\n        return markedInstance.walkTokens(tokens, callback);\n    };\n    /**\n     * Compiles markdown to HTML without enclosing `p` tag.\n     *\n     * @param src String of markdown source to be compiled\n     * @param options Hash of options\n     * @return String of compiled HTML\n     */\n    marked.parseInline = markedInstance.parseInline;\n    /**\n     * Expose\n     */\n    marked.Parser = _Parser;\n    marked.parser = _Parser.parse;\n    marked.Renderer = _Renderer;\n    marked.TextRenderer = _TextRenderer;\n    marked.Lexer = _Lexer;\n    marked.lexer = _Lexer.lex;\n    marked.Tokenizer = _Tokenizer;\n    marked.Hooks = _Hooks;\n    marked.parse = marked;\n    const options = marked.options;\n    const setOptions = marked.setOptions;\n    const use = marked.use;\n    const walkTokens = marked.walkTokens;\n    const parseInline = marked.parseInline;\n    const parse = marked;\n    const parser = _Parser.parse;\n    const lexer = _Lexer.lex;\n\n    exports.Hooks = _Hooks;\n    exports.Lexer = _Lexer;\n    exports.Marked = Marked;\n    exports.Parser = _Parser;\n    exports.Renderer = _Renderer;\n    exports.TextRenderer = _TextRenderer;\n    exports.Tokenizer = _Tokenizer;\n    exports.getDefaults = _getDefaults;\n    exports.lexer = lexer;\n    exports.marked = marked;\n    exports.options = options;\n    exports.parse = parse;\n    exports.parseInline = parseInline;\n    exports.parser = parser;\n    exports.setOptions = setOptions;\n    exports.use = use;\n    exports.walkTokens = walkTokens;\n\n}));\n//# sourceMappingURL=marked.umd.js.map\n","/**\n * Gets the original marked default options.\n */\nexport function _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null\n    };\n}\nexport let _defaults = _getDefaults();\nexport function changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n","/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nexport function escape(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    }\n    else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\nexport function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n) => {\n        n = n.toLowerCase();\n        if (n === 'colon')\n            return ':';\n        if (n.charAt(0) === '#') {\n            return n.charAt(1) === 'x'\n                ? String.fromCharCode(parseInt(n.substring(2), 16))\n                : String.fromCharCode(+n.substring(1));\n        }\n        return '';\n    });\n}\nconst caret = /(^|[^\\[])\\^/g;\nexport function edit(regex, opt) {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    opt = opt || '';\n    const obj = {\n        replace: (name, val) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        }\n    };\n    return obj;\n}\nexport function cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(/%25/g, '%');\n    }\n    catch (e) {\n        return null;\n    }\n    return href;\n}\nexport const noopTest = { exec: () => null };\nexport function splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n        let escaped = false;\n        let curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\')\n            escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n        }\n        else {\n            // add space before unescaped |\n            return ' |';\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        }\n        else {\n            while (cells.length < count)\n                cells.push('');\n        }\n    }\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        }\n        else if (currChar !== c && invert) {\n            suffLen++;\n        }\n        else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nexport function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        }\n        else if (str[i] === b[0]) {\n            level++;\n        }\n        else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n","import { _defaults } from './defaults.ts';\nimport { rtrim, splitCells, escape, findClosingBracket } from './helpers.ts';\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text: escape(text)\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text\n        .split('\\n')\n        .map(node => {\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    })\n        .join('\\n');\n}\n/**\n * Tokenizer\n */\nexport class _Tokenizer {\n    options;\n    rules; // set by the lexer\n    lexer; // set by the lexer\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '');\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                }\n                else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: cap[0]\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            const text = rtrim(cap[0].replace(/^ *>[ \\t]?/gm, ''), '\\n');\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: 'blockquote',\n                raw: cap[0],\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let raw = '';\n            let itemContents = '';\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                }\n                else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                let blankLine = false;\n                if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLine.slice(indent);\n                        }\n                        else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += '\\n' + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    }\n                    else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                    }\n                }\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: []\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimEnd();\n            (list.items[list.items.length - 1]).text = itemContents.trimEnd();\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0]\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!/[:|]/.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n        const item = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: []\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns) {\n            if (/^ *-+: *$/.test(align)) {\n                item.align.push('right');\n            }\n            else if (/^ *:-+: *$/.test(align)) {\n                item.align.push('center');\n            }\n            else if (/^ *:-+ *$/.test(align)) {\n                item.align.push('left');\n            }\n            else {\n                item.align.push(null);\n            }\n        }\n        for (const header of headers) {\n            item.header.push({\n                text: header,\n                tokens: this.lexer.inline(header)\n            });\n        }\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map(cell => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell)\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: escape(cap[1])\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            }\n            else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            }\n            else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(/>$/.test(trimmedUrl))) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            }\n            else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            }\n            else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                }\n                else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = '') {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match)\n            return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n            return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim)\n                    continue; // skip single * in __abc*abc__\n                rLength = [...rDelim].length;\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                }\n                else if (match[5] || match[6]) { // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0)\n                    continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...match[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, ' ');\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape(cap[1]);\n                href = 'mailto:' + text;\n            }\n            else {\n                text = escape(cap[1]);\n                href = text;\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape(cap[0]);\n                href = 'mailto:' + text;\n            }\n            else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                } while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                }\n                else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            }\n            else {\n                text = escape(cap[0]);\n            }\n            return {\n                type: 'text',\n                raw: cap[0],\n                text\n            };\n        }\n    }\n}\n","import { edit, noopTest } from './helpers.ts';\n/**\n * Block-Level Grammar\n */\nconst newline = /^(?: *(?:\\n|$))+/;\nconst blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(/^(?!bull )((?:.|\\n(?!\\s*?\\n|bull ))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n    + '|track|ul';\nconst _comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nconst html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n/**\n * Normal Block Grammar\n */\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText\n};\n/**\n * GFM Block Grammar\n */\nconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', ' {4}[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex()\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\nconst blockPedantic = {\n    ...blockNormal,\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n        + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex()\n};\n/**\n * Inline-Level Grammar\n */\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = '\\\\p{P}$+<=>`^|~';\nconst punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n    .replace(/punctuation/g, _punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n    + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst anyPunctuation = edit(/\\\\([punct])/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n    .getRegex();\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit('^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n/**\n * Normal Inline Grammar\n */\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest\n};\n/**\n * Pedantic Inline Grammar\n */\nconst inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex()\n};\n/**\n * GFM Inline Grammar\n */\nconst inlineGfm = {\n    ...inlineNormal,\n    escape: edit(escape).replace('])', '~|])').getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */\nconst inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex()\n};\n/**\n * exports\n */\nexport const block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic\n};\nexport const inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic\n};\n","import { _Tokenizer } from './Tokenizer.ts';\nimport { _defaults } from './defaults.ts';\nimport { block, inline } from './rules.ts';\n/**\n * Block Lexer\n */\nexport class _Lexer {\n    tokens;\n    options;\n    state;\n    tokenizer;\n    inlineQueue;\n    constructor(options) {\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        }\n        else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            }\n            else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n     * Static Lex Method\n     */\n    static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    lex(src) {\n        src = src\n            .replace(/\\r\\n|\\r/g, '\\n');\n        this.blockTokens(src, this.tokens);\n        let next;\n        while (next = this.inlineQueue.shift()) {\n            this.inlineTokens(next.src, next.tokens);\n        }\n        return this.tokens;\n    }\n    blockTokens(src, tokens = []) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n        }\n        else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n                return leading + '    '.repeat(tabs.length);\n            });\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        let lastParagraphClipped;\n        while (src) {\n            if (this.options.extensions\n                && this.options.extensions.block\n                && this.options.extensions.block.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += '\\n';\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = (cutSrc.length !== src.length);\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({ src, tokens });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions\n                && this.options.extensions.inline\n                && this.options.extensions.inline.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n","import { _defaults } from './defaults.ts';\nimport { cleanUrl, escape } from './helpers.ts';\n/**\n * Renderer\n */\nexport class _Renderer {\n    options;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    code(code, infostring, escaped) {\n        const lang = (infostring || '').match(/^\\S*/)?.[0];\n        code = code.replace(/\\n$/, '') + '\\n';\n        if (!lang) {\n            return '<pre><code>'\n                + (escaped ? code : escape(code, true))\n                + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-'\n            + escape(lang)\n            + '\">'\n            + (escaped ? code : escape(code, true))\n            + '</code></pre>\\n';\n    }\n    blockquote(quote) {\n        return `<blockquote>\\n${quote}</blockquote>\\n`;\n    }\n    html(html, block) {\n        return html;\n    }\n    heading(text, level, raw) {\n        // ignore IDs\n        return `<h${level}>${text}</h${level}>\\n`;\n    }\n    hr() {\n        return '<hr>\\n';\n    }\n    list(body, ordered, start) {\n        const type = ordered ? 'ol' : 'ul';\n        const startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    }\n    listitem(text, task, checked) {\n        return `<li>${text}</li>\\n`;\n    }\n    checkbox(checked) {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph(text) {\n        return `<p>${text}</p>\\n`;\n    }\n    table(header, body) {\n        if (body)\n            body = `<tbody>${body}</tbody>`;\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n    tablerow(content) {\n        return `<tr>\\n${content}</tr>\\n`;\n    }\n    tablecell(content, flags) {\n        const type = flags.header ? 'th' : 'td';\n        const tag = flags.align\n            ? `<${type} align=\"${flags.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */\n    strong(text) {\n        return `<strong>${text}</strong>`;\n    }\n    em(text) {\n        return `<em>${text}</em>`;\n    }\n    codespan(text) {\n        return `<code>${text}</code>`;\n    }\n    br() {\n        return '<br>';\n    }\n    del(text) {\n        return `<del>${text}</del>`;\n    }\n    link(href, title, text) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n    image(href, title, text) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += '>';\n        return out;\n    }\n    text(text) {\n        return text;\n    }\n}\n","/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer {\n    // no need for block level renderers\n    strong(text) {\n        return text;\n    }\n    em(text) {\n        return text;\n    }\n    codespan(text) {\n        return text;\n    }\n    del(text) {\n        return text;\n    }\n    html(text) {\n        return text;\n    }\n    text(text) {\n        return text;\n    }\n    link(href, title, text) {\n        return '' + text;\n    }\n    image(href, title, text) {\n        return '' + text;\n    }\n    br() {\n        return '';\n    }\n}\n","import { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _defaults } from './defaults.ts';\nimport { unescape } from './helpers.ts';\n/**\n * Parsing & Compiling\n */\nexport class _Parser {\n    options;\n    renderer;\n    textRenderer;\n    constructor(options) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    parse(tokens, top = true) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const genericToken = token;\n                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            switch (token.type) {\n                case 'space': {\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr();\n                    continue;\n                }\n                case 'heading': {\n                    const headingToken = token;\n                    out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));\n                    continue;\n                }\n                case 'code': {\n                    const codeToken = token;\n                    out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                    continue;\n                }\n                case 'table': {\n                    const tableToken = token;\n                    let header = '';\n                    // header\n                    let cell = '';\n                    for (let j = 0; j < tableToken.header.length; j++) {\n                        cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });\n                    }\n                    header += this.renderer.tablerow(cell);\n                    let body = '';\n                    for (let j = 0; j < tableToken.rows.length; j++) {\n                        const row = tableToken.rows[j];\n                        cell = '';\n                        for (let k = 0; k < row.length; k++) {\n                            cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });\n                        }\n                        body += this.renderer.tablerow(cell);\n                    }\n                    out += this.renderer.table(header, body);\n                    continue;\n                }\n                case 'blockquote': {\n                    const blockquoteToken = token;\n                    const body = this.parse(blockquoteToken.tokens);\n                    out += this.renderer.blockquote(body);\n                    continue;\n                }\n                case 'list': {\n                    const listToken = token;\n                    const ordered = listToken.ordered;\n                    const start = listToken.start;\n                    const loose = listToken.loose;\n                    let body = '';\n                    for (let j = 0; j < listToken.items.length; j++) {\n                        const item = listToken.items[j];\n                        const checked = item.checked;\n                        const task = item.task;\n                        let itemBody = '';\n                        if (item.task) {\n                            const checkbox = this.renderer.checkbox(!!checked);\n                            if (loose) {\n                                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                                    }\n                                }\n                                else {\n                                    item.tokens.unshift({\n                                        type: 'text',\n                                        text: checkbox + ' '\n                                    });\n                                }\n                            }\n                            else {\n                                itemBody += checkbox + ' ';\n                            }\n                        }\n                        itemBody += this.parse(item.tokens, loose);\n                        body += this.renderer.listitem(itemBody, task, !!checked);\n                    }\n                    out += this.renderer.list(body, ordered, start);\n                    continue;\n                }\n                case 'html': {\n                    const htmlToken = token;\n                    out += this.renderer.html(htmlToken.text, htmlToken.block);\n                    continue;\n                }\n                case 'paragraph': {\n                    const paragraphToken = token;\n                    out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token;\n                    let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i];\n                        body += '\\n' + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                    }\n                    out += top ? this.renderer.paragraph(body) : body;\n                    continue;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            switch (token.type) {\n                case 'escape': {\n                    const escapeToken = token;\n                    out += renderer.text(escapeToken.text);\n                    break;\n                }\n                case 'html': {\n                    const tagToken = token;\n                    out += renderer.html(tagToken.text);\n                    break;\n                }\n                case 'link': {\n                    const linkToken = token;\n                    out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                    break;\n                }\n                case 'image': {\n                    const imageToken = token;\n                    out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                    break;\n                }\n                case 'strong': {\n                    const strongToken = token;\n                    out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                    break;\n                }\n                case 'em': {\n                    const emToken = token;\n                    out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                    break;\n                }\n                case 'codespan': {\n                    const codespanToken = token;\n                    out += renderer.codespan(codespanToken.text);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br();\n                    break;\n                }\n                case 'del': {\n                    const delToken = token;\n                    out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                    break;\n                }\n                case 'text': {\n                    const textToken = token;\n                    out += renderer.text(textToken.text);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n","import { _defaults } from './defaults.ts';\nexport class _Hooks {\n    options;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess'\n    ]);\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html) {\n        return html;\n    }\n}\n","import { _getDefaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { escape } from './helpers.ts';\nexport class Marked {\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n    parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Lexer = _Lexer;\n    Tokenizer = _Tokenizer;\n    Hooks = _Hooks;\n    constructor(...args) {\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            values = values.concat(this.walkTokens(genericToken[childTokens], callback));\n                        });\n                    }\n                    else if (genericToken.tokens) {\n                        values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                    }\n                }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = { ...pack };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        }\n                        else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        }\n                        else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                }\n                                else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            }\n                            else if (ext.level === 'inline') {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                }\n                                else {\n                                    extensions.startInline = [ext.start];\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer) || prop === 'options') {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer) || ['options', 'rules', 'lexer'].includes(prop)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks) || prop === 'options') {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        hooks[hooksProp] = (arg) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    }\n                    else {\n                        hooks[hooksProp] = (...args) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = { ...this.defaults, ...opt };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    #parseMarkdown(lexer, parser) {\n        return (src, options) => {\n            const origOpt = { ...options };\n            const opt = { ...this.defaults, ...origOpt };\n            // Show warning if an extension set async to true but the parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                if (!opt.silent) {\n                    console.warn('marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.');\n                }\n                opt.async = true;\n            }\n            const throwError = this.#onError(!!opt.silent, !!opt.async);\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                    .then(src => lexer(src, opt))\n                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                    .then(tokens => parser(tokens, opt))\n                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                    .catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                const tokens = lexer(src, opt);\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            }\n            catch (e) {\n                return throwError(e);\n            }\n        };\n    }\n    #onError(silent, async) {\n        return (e) => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\n","import { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { Marked } from './Instance.ts';\nimport { _getDefaults, changeDefaults, _defaults } from './defaults.ts';\nconst markedInstance = new Marked();\nexport function marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */\nmarked.use = function (...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */\nmarked.walkTokens = function (tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport { _defaults as defaults, _getDefaults as getDefaults } from './defaults.ts';\nexport { _Lexer as Lexer } from './Lexer.ts';\nexport { _Parser as Parser } from './Parser.ts';\nexport { _Tokenizer as Tokenizer } from './Tokenizer.ts';\nexport { _Renderer as Renderer } from './Renderer.ts';\nexport { _TextRenderer as TextRenderer } from './TextRenderer.ts';\nexport { _Hooks as Hooks } from './Hooks.ts';\nexport { Marked } from './Instance.ts';\n"],"names":["$f123004b8678fd03$exports","factory","entries","setPrototypeOf","isFrozen","getPrototypeOf","getOwnPropertyDescriptor","Object","freeze","seal","create","apply","construct","Reflect","x","fun","thisValue","args","Func","arrayForEach","unapply","Array","prototype","forEach","arrayPop","pop","arrayPush","push","stringToLowerCase","String","toLowerCase","stringToString","toString","stringMatch","match","stringReplace","replace","stringIndexOf","indexOf","stringTrim","trim","regExpTest","RegExp","test","typeErrorCreate","func","TypeError","_len2","arguments","length","_key2","thisArg","_len","_key","addToSet","set","array","transformCaseFunc","undefined","l","element","lcElement","clone","object","newObject","property","value","lookupGetter","prop","desc","get","console","warn","html$1","svg$1","svgFilters","svgDisallowed","mathMl$1","mathMlDisallowed","text","html","svg","mathMl","xml","MUSTACHE_EXPR","ERB_EXPR","TMPLIT_EXPR","DATA_ATTR","ARIA_ATTR","IS_ALLOWED_URI","IS_SCRIPT_OR_DATA","ATTR_WHITESPACE","DOCTYPE_NAME","EXPRESSIONS","__proto__","_createTrustedTypesPolicy","trustedTypes","purifyHostElement","createPolicy","suffix","ATTR_NAME","hasAttribute","getAttribute","policyName","createHTML","createScriptURL","scriptUrl","_","createDOMPurify","trustedTypesPolicy","window1","window","DOMPurify","root","version","removed","document","nodeType","isSupported","originalDocument","currentScript","DocumentFragment","HTMLTemplateElement","Node","Element","NodeFilter","NamedNodeMap","MozNamedAttrMap","HTMLFormElement","DOMParser","ElementPrototype","cloneNode","getNextSibling","getChildNodes","getParentNode","template","createElement","content","ownerDocument","emptyHTML","implementation","createNodeIterator","createDocumentFragment","getElementsByTagName","importNode","hooks","createHTMLDocument","IS_ALLOWED_URI$1","ALLOWED_TAGS","DEFAULT_ALLOWED_TAGS","ALLOWED_ATTR","DEFAULT_ALLOWED_ATTR","CUSTOM_ELEMENT_HANDLING","tagNameCheck","writable","configurable","enumerable","attributeNameCheck","allowCustomizedBuiltInElements","FORBID_TAGS","FORBID_ATTR","ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","ALLOW_SELF_CLOSE_IN_ATTR","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","SET_CONFIG","FORCE_BODY","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_TRUSTED_TYPE","SANITIZE_DOM","SANITIZE_NAMED_PROPS","KEEP_CONTENT","IN_PLACE","USE_PROFILES","FORBID_CONTENTS","DEFAULT_FORBID_CONTENTS","DATA_URI_TAGS","DEFAULT_DATA_URI_TAGS","URI_SAFE_ATTRIBUTES","DEFAULT_URI_SAFE_ATTRIBUTES","MATHML_NAMESPACE","SVG_NAMESPACE","HTML_NAMESPACE","NAMESPACE","IS_EMPTY_INPUT","ALLOWED_NAMESPACES","DEFAULT_ALLOWED_NAMESPACES","PARSER_MEDIA_TYPE","SUPPORTED_PARSER_MEDIA_TYPES","CONFIG","formElement","isRegexOrFunction","testValue","Function","_parseConfig","cfg","ADD_URI_SAFE_ATTR","ADD_DATA_URI_TAGS","ALLOWED_URI_REGEXP","ADD_TAGS","ADD_ATTR","table","tbody","TRUSTED_TYPES_POLICY","MATHML_TEXT_INTEGRATION_POINTS","HTML_INTEGRATION_POINTS","COMMON_SVG_AND_HTML_ELEMENTS","ALL_SVG_TAGS","ALL_MATHML_TAGS","_checkValidNamespace","parent","tagName","namespaceURI","parentTagName","Boolean","_forceRemove","node","parentNode","removeChild","remove","_removeAttribute","name","attribute","getAttributeNode","from","removeAttribute","setAttribute","_initDocument","dirty","doc","leadingWhitespace","matches","dirtyPayload","parseFromString","documentElement","createDocument","innerHTML","body","insertBefore","createTextNode","childNodes","call","_createNodeIterator","SHOW_ELEMENT","SHOW_COMMENT","SHOW_TEXT","_isNode","_executeHook","entryPoint","currentNode","data","hook","_sanitizeElements","elm","nodeName","textContent","attributes","hasChildNodes","allowedTags","firstElementChild","_isBasicCustomElement","childCount","i","expr","_isValidAttribute","lcTag","lcName","_sanitizeAttributes","hookEvent","attrName","attrValue","keepAttr","allowedAttributes","forceKeepAttr","SANITIZE_NAMED_PROPS_PREFIX","getAttributeType","setAttributeNS","_sanitizeShadowDOM","fragment","shadowNode","shadowIterator","nextNode","sanitize","importedNode","returnNode","appendChild","firstChild","nodeIterator","shadowroot","shadowrootmode","serializedHTML","outerHTML","doctype","setConfig","clearConfig","isValidAttribute","tag","attr","addHook","hookFunction","removeHook","removeHooks","removeAllHooks","$d24e0eeb5f66fbc4$exports","exports1","_getDefaults","async","breaks","extensions","gfm","pedantic","renderer","silent","tokenizer","walkTokens","changeDefaults","newDefaults","defaults","escapeTest","escapeReplace","source","escapeTestNoEncode","escapeReplaceNoEncode","escapeReplacements","getEscapeReplacement","ch","escape$1","encode","unescapeTest","caret","edit","regex","opt","obj","val","valSource","getRegex","cleanUrl","href","encodeURI","e","noopTest","exec","splitCells","tableRow","count","cells","row","offset","str","escaped","curr","split","shift","splice","rtrim","c","invert","suffLen","currChar","charAt","slice","outputLink","cap","link","raw","lexer","title","state","inLink","token","type","tokens","inlineTokens","_Tokenizer","options","rules","constructor","space","src","block","newline","code","codeBlockStyle","fences","indentCodeCompensation","matchIndentToCode","indentToCode","map","matchIndentInNode","indentInNode","join","lang","inline","anyPunctuation","heading","trimmed","depth","hr","blockquote","top","blockTokens","list","bull","isordered","ordered","start","loose","items","itemRegex","itemContents","endsWithBlankLine","ischecked","endEarly","substring","line","t","repeat","nextLine","indent","trimStart","search","blankLine","nextBulletRegex","Math","min","hrRegex","fencesBeginRegex","headingBeginRegex","rawLine","istask","task","checked","trimEnd","spacers","filter","hasMultipleLineBreaks","some","pre","def","headers","aligns","rows","item","header","align","cell","lheading","paragraph","escape","inRawBlock","trimmedUrl","rtrimSlash","lastParenIndex","findClosingBracket","b","level","linkLen","reflink","links","nolink","linkString","emStrong","maskedSrc","prevChar","emStrongLDelim","punctuation","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","emStrongRDelimAst","emStrongRDelimUnd","lastIndex","lastCharLength","index","codespan","hasNonSpaceChars","hasSpaceCharsOnBothEnds","br","del","autolink","url","prevCapZero","_backpedal","inlineText","bullet","_paragraph","_blockLabel","_tag","_comment","blockNormal","gfmTable","blockGfm","blockPedantic","_punctuation","_inlineComment","_inlineLabel","reflinkSearch","inlineNormal","blockSkip","inlinePedantic","inlineGfm","inlineBreaks","normal","_Lexer","inlineQueue","lex","lexInline","next","lastToken","cutSrc","lastParagraphClipped","leading","tabs","extTokenizer","startBlock","tempStart","startIndex","Infinity","tempSrc","getStartIndex","errMsg","charCodeAt","error","Error","keepPrevChar","keys","includes","lastIndexOf","startInline","_Renderer","infostring","quote","listitem","checkbox","tablerow","tablecell","flags","strong","em","cleanHref","out","image","_TextRenderer","_Parser","textRenderer","parse","parser","parseInline","renderers","ret","genericToken","headingToken","n","fromCharCode","parseInt","codeToken","j","tableToken","k","blockquoteToken","listToken","itemBody","unshift","htmlToken","paragraphToken","textToken","escapeToken","tagToken","linkToken","imageToken","strongToken","emToken","codespanToken","delToken","_Hooks","passThroughHooks","Set","preprocess","markdown","postprocess","Marked","setOptions","parseMarkdown","Parser","Renderer","TextRenderer","Lexer","Tokenizer","Hooks","use","callback","values","concat","childTokens","pack","opts","ext","prevRenderer","extLevel","rendererFunc","tokenizerFunc","prevTokenizer","hooksFunc","prevHook","has","arg","Promise","resolve","then","packWalktokens","origOpt","throwError","onError","all","catch","message","msg","reject","markedInstance","marked","getDefaults","$35da740d59af89ba$var$input_b64","querySelector","$35da740d59af89ba$var$input_md","$35da740d59af89ba$var$output","addEventListener","ev","ascii","atob","currentTarget","parsed","sanitized","unconstruct","fallbackValue","getGlobal","VERSION","TAGS","ATTRS","DEFAULT_PARSER_MEDIA_TYPE","_isClobbered","_defaults"],"version":3,"file":"index.c3c3648a.js.map"}